import{apFirst as t,apS as a,apSecond as e}from"./Apply.mjs";import{bind as r,tap as p}from"./Chain.mjs";import{dual as n,identity as o,pipe as i}from"./function.mjs";import{bindTo as m,flap as s,let as l}from"./Functor.mjs";import{emptyReadonlyArray as d,head as S,isNonEmpty as f}from"./internal.mjs";let c=()=>t=>[t,t],u=t=>()=>[void 0,t],h=t=>a=>[void 0,t(a)],y=t=>a=>[t(a),a],v=(t,a)=>i(t,_(a)),A=(t,a)=>i(t,x(a)),_=t=>a=>e=>{let[r,p]=a(e);return[t(r),p]},x=t=>a=>e=>{let[r,p]=a(e),[n,o]=t(p);return[r(n),o]},F=t=>a=>[t,a],j=n(2,(t,a)=>e=>{let[r,p]=t(e);return a(r)(p)}),b=j(o),I="State",g={URI:I,map:v},R=s(g),W={URI:I,of:F},C={URI:I,map:v,ap:A},M=t(C),T=e(C),q={URI:I,map:v,ap:A,of:F},E={URI:I,map:v,ap:A,chain:j},N={URI:I,map:v,ap:A,of:F,chain:j},P=n(2,p(E)),U={URI:I,fromState:o},k=t=>a=>a(t)[0],w=t=>a=>a(t)[1],z=m(g),B=l(g),D=r(E),G=a(C),H=t=>a=>e=>{let[r,p]=t(0,S(a))(e),n=[r],o=p;for(let e=1;e<a.length;e++){let[r,p]=t(e,a[e])(o);n.push(r),o=p}return[n,o]},J=t=>{let a=H(t);return t=>f(t)?a(t):F(d)},K=J,L=t=>J((a,e)=>t(e)),O=L(o),Q=j,V=P,X=(t,a)=>t(a)[0],Y=(t,a)=>t(a)[1],Z=N;export{q as Applicative,C as Apply,E as Chain,U as FromState,g as Functor,N as Monad,W as Pointed,I as URI,x as ap,M as apFirst,G as apS,T as apSecond,D as bind,z as bindTo,Q as chain,V as chainFirst,X as evalState,k as evaluate,Y as execState,w as execute,R as flap,j as flatMap,b as flatten,c as get,y as gets,B as let,_ as map,h as modify,F as of,u as put,O as sequenceArray,Z as state,P as tap,L as traverseArray,K as traverseArrayWithIndex,J as traverseReadonlyArrayWithIndex,H as traverseReadonlyNonEmptyArrayWithIndex};