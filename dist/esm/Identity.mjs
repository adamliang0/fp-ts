import{apFirst as a,apS as t,apSecond as e}from"./Apply.mjs";import{bind as p,tap as i}from"./Chain.mjs";import{tailRec as n}from"./ChainRec.mjs";import{dual as r,identity as d,pipe as m}from"./function.mjs";import{bindTo as o,flap as c,let as l}from"./Functor.mjs";import{emptyRecord as s}from"./internal.mjs";let h=(a,t)=>m(a,g(t)),f=(a,t)=>m(a,j(t)),u=(a,t,e)=>m(a,A(t,e)),y=a=>(t,e)=>m(t,T(a)(e)),I=(a,t,e)=>m(a,q(t,e)),R=(a,t)=>m(a,P(t)),_=(a,t)=>m(a,v(t)),b=a=>{let t=w(a);return(a,e)=>m(a,t(e))},g=a=>t=>a(t),j=a=>t=>t(a),F=d,M=r(2,(a,t)=>t(a)),v=a=>t=>a(t),x=d,C=v(d),S=M(d),A=(a,t)=>e=>t(a,e),T=()=>a=>t=>a(t),q=(a,t)=>e=>t(e,a),w=a=>t=>e=>a.map(t(e),d),D=a=>t=>a.map(t,d),E=()=>d,P=E,U="Identity",W=d,k=d,z={URI:U,map:h},B=c(z),G={URI:U,of:F},H={URI:U,map:h,ap:f},J=a(H),K=e(H),L={URI:U,map:h,ap:f,of:F},N={URI:U,map:h,ap:f,chain:M},O={URI:U,map:h,ap:f,of:F,chain:M},Q=r(2,i(N)),V=Q,X={URI:U,reduce:u,foldMap:y,reduceRight:I},Y={URI:U,map:h,reduce:u,foldMap:y,reduceRight:I,traverse:b,sequence:D},Z={URI:U,map:h,alt:R},$={URI:U,map:h,extend:_,extract:x},aa={URI:U,map:h,ap:f,chain:M,chainRec:n},at=F(s),ae=o(z),ap=l(z),ai=p(N),an=t(H),ar=M,ad={URI:U,map:h,ap:f,of:F,chain:M,reduce:u,foldMap:y,reduceRight:I,traverse:b,sequence:D,alt:R,extract:x,extend:_,chainRec:n};export{Z as Alt,L as Applicative,H as Apply,N as Chain,aa as ChainRec,$ as Comonad,at as Do,X as Foldable,z as Functor,O as Monad,G as Pointed,Y as Traversable,U as URI,P as alt,E as altW,j as ap,J as apFirst,an as apS,K as apSecond,ai as bind,ae as bindTo,ar as chain,V as chainFirst,C as duplicate,v as extend,x as extract,B as flap,M as flatMap,S as flatten,T as foldMap,k as getEq,W as getShow,ad as identity,ap as let,g as map,F as of,A as reduce,q as reduceRight,D as sequence,Q as tap,w as traverse};