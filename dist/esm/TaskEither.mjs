import{getApplicativeMonoid as a}from"./Applicative.mjs";import{ap as t,apFirst as r,apS as e,apSecond as i,getApplySemigroup as s}from"./Apply.mjs";import{bind as o,tap as p}from"./Chain.mjs";import{compact as n,separate as l}from"./Compactable.mjs";import{Functor as h,fromOption as m,getApplicativeValidation as f,getCompactable as E,getFilterable as k,getSemigroup as T,map as c,traverseReadonlyNonEmptyArrayWithIndex as _}from"./Either.mjs";import{alt as u,altValidation as O,ap as d,chainNullableK as y,flatMap as I,fromNullable as K,fromNullableK as W,getOrElseW as A,left as b,leftF as v,map as g,mapBoth as F,mapError as M,match as S,matchE as j,orElse as N,orLeft as q,right as P,rightF as x,swap as w,tapError as C,toUnion as L}from"./EitherT.mjs";import{filter as R,filterMap as U,partition as B,partitionMap as V}from"./Filterable.mjs";import{chainOptionK as D,filterOrElse as z,fromEitherK as G,fromOption as H,fromOptionK as J,fromPredicate as Q,tapEither as X}from"./FromEither.mjs";import{fromIOK as Y,tapIO as Z}from"./FromIO.mjs";import{fromTaskK as $,tapTask as aa}from"./FromTask.mjs";import{SK as at,dual as ar,flow as ae,identity as ai,pipe as as}from"./function.mjs";import{as as ao,asUnit as ap,bindTo as an,flap as al,let as ah}from"./Functor.mjs";import{emptyReadonlyArray as am,emptyRecord as af,flatMapEither as aE,flatMapIO as ak,flatMapNullable as aT,flatMapOption as ac,flatMapTask as a_,head as au,isLeft as aO,isNonEmpty as ad,left as ay,liftNullable as aI,liftOption as aK,right as aW,singleton as aA,tail as ab}from"./internal.mjs";import{ApplicativePar as av,ApplyPar as ag,ApplySeq as aF,Functor as aM,Monad as aS,Pointed as aj,flatMap as aN,fromIO as aq,map as aP,of as ax,traverseReadonlyNonEmptyArrayWithIndex as aw}from"./Task.mjs";function aC(a,t,r,e,i,s,o){try{var p=a[s](o),n=p.value}catch(a){r(a);return}p.done?t(n):Promise.resolve(n).then(e,i)}let aL=b(aj),aR=P(aj),aU=x(aM),aB=v(aM),aV=ae(aq,aU),aD=ae(aq,aB),az=aV,aG=aU,aH=ax,aJ=aq,aQ=a=>aP(m(a)),aX=S(aM),aY=aX,aZ=j(aS),a$=aZ,a2=aZ,a0=a2,a3=A(aS),a1=a3,a4=(a,t)=>()=>{var r;return(r=function*(){try{return yield a().then(aW)}catch(a){return ay(t(a))}},function(){var a=this,t=arguments;return new Promise(function(e,i){var s=r.apply(a,t);function o(a){aC(s,e,i,o,p,"next",a)}function p(a){aC(s,e,i,o,p,"throw",a)}o(void 0)})})()},a5=(a,t)=>(...r)=>a4(()=>a(...r),t),a6=L(aM),a7=K(aj),a8=W(aj),a9=y(aS),ta=N(aS),tt=ta,tr=ar(2,C(aS)),te=a=>tr(ry(a)),ti=a=>tr(rW(a)),ts=q(aS),to=w(aM),tp=a=>{let t=aQ(a);return a=>ae(a,t)},tn=a=>t=>r=>tI(r,tp(a)(t)),tl=tn,th=a=>ae(a,aJ),tm=(a,t)=>as(a,tT(t)),tf=(a,t)=>as(a,td(t)),tE=(a,t)=>tI(a,a=>as(t,tT(a))),tk=(a,t)=>as(a,tA(t)),tT=g(aM),tc=ar(3,F(aM)),t_=tc,tu=ar(2,M(aM)),tO=tu,td=d(ag),ty=td,tI=ar(2,I(aS)),tK=tI(ai),tW=tK,tA=u(aS),tb=tA,tv=aR,tg=aL,tF="TaskEither";function tM(a,r){let e=t(a,f(r));return{URI:tF,_E:void 0,map:tm,ap:(a,t)=>as(a,e(t)),of:tv}}function tS(a){let t=O(aS,a);return{URI:tF,_E:void 0,map:tm,alt:(a,r)=>as(a,t(r))}}let tj=a=>{let t=E(a);return{URI:tF,_E:void 0,compact:n(aM,t),separate:l(aM,t,h)}};function tN(a){let t=k(a),r=tj(a),e=R(aM,t),i=U(aM,t),s=B(aM,t),o=V(aM,t);return{URI:tF,_E:void 0,map:tm,compact:r.compact,separate:r.separate,filter:(a,t)=>as(a,e(t)),filterMap:(a,t)=>as(a,i(t)),partition:(a,t)=>as(a,s(t)),partitionMap:(a,t)=>as(a,o(t))}}let tq={URI:tF,map:tm},tP=ar(2,ao(tq)),tx=ap(tq),tw=al(tq),tC={URI:tF,of:tv},tL={URI:tF,map:tm,ap:tf},tR=r(tL),tU=tR,tB=i(tL),tV=tB,tD={URI:tF,map:tm,ap:tf,of:tv},tz={URI:tF,map:tm,ap:tE},tG={URI:tF,map:tm,ap:tE,of:tv},tH={URI:tF,map:tm,ap:tf,chain:tI},tJ={URI:tF,map:tm,ap:tf,chain:tI,of:tv},tQ={URI:tF,map:tm,ap:tf,chain:tI,of:tv,fromIO:az},tX={URI:tF,map:tm,ap:tf,chain:tI,of:tv,fromIO:az,fromTask:aG},tY={URI:tF,map:tm,ap:tf,chain:tI,of:tv,throwError:tg},tZ={URI:tF,fromEither:aH},t$={URI:tF,fromIO:az},t2={URI:tF,fromIO:az,fromTask:aG},t0=ar(2,p(tH)),t3=ar(2,X(tZ,tH)),t1=ar(2,Z(t$,tH)),t4=ar(2,aa(t2,tH)),t5={URI:tF,bimap:tc,mapLeft:tu},t6={URI:tF,map:tm,alt:tk},t7=H(tZ),t8=J(tZ),t9=D(tZ,tH),ra=t9,rt={fromEither:tZ.fromEither},rr=aI(rt),re=aK(rt),ri={flatMap:tI},rs={fromIO:t$.fromIO},ro=aT(rt,ri),rp=ac(rt,ri),rn=aE(rt,ri),rl=ak(rs,ri),rh=a_({fromTask:aG},ri),rm=ar(2,(a,t)=>tI(a,th(t))),rf=ar(3,(a,t,r)=>tI(a,a=>aQ(()=>r(a))(t(a)))),rE=rn,rk=rn,rT=t3,rc=t3,r_=Q(tZ),ru=z(tZ,tH),rO=ru,rd=G(tZ),ry=Y(t$),rI=rl,rK=t1,rW=$(t2),rA=rh,rb=t4,rv=rm,rg=rm;function rF(a){return function(){let t=Array.prototype.slice.call(arguments);return()=>new Promise(r=>{a.apply(null,t.concat((a,t)=>null!=a?r(ay(a)):r(aW(t))))})}}let rM=(a,t,r)=>rS(a,t,r),rS=(a,t,r)=>tI(a,a=>aN(t(a),t=>tI(r(a,t),()=>ax(t)))),rj=tv(af),rN=an(tq),rq=ah(tq),rP=o(tH),rx=rP,rw=e(tL),rC=rw,rL=tv(am),rR=a=>ae(aw(a),aP(_(at))),rU=a=>{let t=rR(a);return a=>ad(a)?t(a):rL},rB=a=>t=>()=>ab(t).reduce((t,r,e)=>t.then(i=>aO(i)?t:a(e+1,r)().then(a=>aO(a)?a:(i.right.push(a.right),i))),a(0,au(t))().then(c(aA))),rV=a=>{let t=rB(a);return a=>ad(a)?t(a):rL},rD=rU,rz=a=>rU((t,r)=>a(r)),rG=rz(ai),rH=rV,rJ=a=>rV((t,r)=>a(r)),rQ=rJ(ai),rX=tI,rY=tI,rZ=t0,r$=t0,r2=tr,r0=tr,r3={URI:tF,bimap:tc,mapLeft:tu,map:tm,of:tv,ap:tf,chain:tI,alt:tk,fromIO:az,fromTask:aG,throwError:tg},r1={URI:tF,bimap:tc,mapLeft:tu,map:tm,of:tv,ap:tE,chain:tI,alt:tk,fromIO:az,fromTask:aG,throwError:tg},r4=s(tz),r5=a(tG),r6=a=>s(aF)(T(a));function r7(a){let t=tM(av,a),r=tS(a);return{URI:tF,_E:void 0,map:tm,ap:t.ap,of:tv,chain:tI,bimap:tc,mapLeft:tu,alt:r.alt,fromIO:az,fromTask:aG,throwError:tg}}export{t6 as Alt,rL as ApT,tD as ApplicativePar,tG as ApplicativeSeq,tL as ApplyPar,tz as ApplySeq,t5 as Bifunctor,tH as Chain,rj as Do,tZ as FromEither,t$ as FromIO,t2 as FromTask,tq as Functor,tJ as Monad,tQ as MonadIO,tX as MonadTask,tY as MonadThrow,tC as Pointed,tF as URI,tA as alt,tb as altW,td as ap,tR as apFirst,tU as apFirstW,rw as apS,rC as apSW,tB as apSecond,tV as apSecondW,ty as apW,tP as as,tx as asUnit,t_ as bimap,rP as bind,rN as bindTo,rx as bindW,rM as bracket,rS as bracketW,rX as chain,rE as chainEitherK,rk as chainEitherKW,rZ as chainFirst,rT as chainFirstEitherK,rc as chainFirstEitherKW,rK as chainFirstIOK,rb as chainFirstTaskK,r$ as chainFirstW,rg as chainIOEitherK,rv as chainIOEitherKW,rI as chainIOK,a9 as chainNullableK,t9 as chainOptionK,ra as chainOptionKW,rA as chainTaskK,tl as chainTaskOptionK,tn as chainTaskOptionKW,rY as chainW,ru as filterOrElse,rO as filterOrElseW,tw as flap,tI as flatMap,rn as flatMapEither,rl as flatMapIO,rm as flatMapIOEither,ro as flatMapNullable,rp as flatMapOption,rh as flatMapTask,rf as flatMapTaskOption,tW as flatten,tK as flattenW,a$ as fold,a0 as foldW,aH as fromEither,rd as fromEitherK,az as fromIO,aJ as fromIOEither,th as fromIOEitherK,ry as fromIOK,a7 as fromNullable,a8 as fromNullableK,t7 as fromOption,t8 as fromOptionK,r_ as fromPredicate,aG as fromTask,rW as fromTaskK,aQ as fromTaskOption,tp as fromTaskOptionK,tS as getAltTaskValidation,tM as getApplicativeTaskValidation,r5 as getApplyMonoid,r4 as getApplySemigroup,tj as getCompactable,tN as getFilterable,a1 as getOrElse,a3 as getOrElseW,r6 as getSemigroup,r7 as getTaskValidation,aL as left,aD as leftIO,aB as leftTask,rq as let,rr as liftNullable,re as liftOption,tT as map,tc as mapBoth,tu as mapError,tO as mapLeft,aX as match,aZ as matchE,a2 as matchEW,aY as matchW,tv as of,ta as orElse,r2 as orElseFirst,te as orElseFirstIOK,ti as orElseFirstTaskK,r0 as orElseFirstW,tt as orElseW,ts as orLeft,aR as right,aV as rightIO,aU as rightTask,rG as sequenceArray,rQ as sequenceSeqArray,to as swap,t0 as tap,t3 as tapEither,tr as tapError,t1 as tapIO,t4 as tapTask,r3 as taskEither,r1 as taskEitherSeq,rF as taskify,tg as throwError,a6 as toUnion,rz as traverseArray,rD as traverseArrayWithIndex,rU as traverseReadonlyArrayWithIndex,rV as traverseReadonlyArrayWithIndexSeq,rR as traverseReadonlyNonEmptyArrayWithIndex,rB as traverseReadonlyNonEmptyArrayWithIndexSeq,rJ as traverseSeqArray,rH as traverseSeqArrayWithIndex,a4 as tryCatch,a5 as tryCatchK};