import{getApplicativeMonoid as e}from"./Applicative.mjs";import{apFirst as t,apS as a,apSecond as r,getApplySemigroup as i}from"./Apply.mjs";import{bind as o,tap as p}from"./Chain.mjs";import{chainEitherK as l,fromEitherK as n,tapEither as m}from"./FromEither.mjs";import{constNull as u,constUndefined as s,dual as f,flow as c,identity as d,pipe as h}from"./function.mjs";import{as as v,asUnit as g,bindTo as O,flap as _,let as M}from"./Functor.mjs";import{emptyReadonlyArray as y,emptyRecord as E,head as b,isNonEmpty as A,isSome as j,none as w,some as F}from"./internal.mjs";import{not as R}from"./Predicate.mjs";import{first as S,last as x}from"./Semigroup.mjs";import{separated as W}from"./Separated.mjs";import{wiltDefault as q,witherDefault as K}from"./Witherable.mjs";import{guard as N}from"./Zero.mjs";let C=w,T=F;function I(e){return t=>e(t)?T(t):C}let U=e=>"Right"===e._tag?C:T(e.left),L=e=>"Left"===e._tag?C:T(e.right),P=(e,t)=>h(e,er(t)),Z=(e,t)=>h(e,em(t)),z=(e,t,a)=>h(e,eh(t,a)),D=e=>{let t=ev(e);return(e,a)=>h(e,t(a))},$=(e,t,a)=>h(e,eg(t,a)),k=e=>{let t=eU(e);return(e,a)=>h(e,t(a))},B=(e,t)=>h(e,ey(t)),G=(e,t)=>h(e,eK(t)),H=(e,t)=>h(e,eN(t)),J=(e,t)=>h(e,eF(t)),Q=(e,t)=>h(e,eC(t)),V=(e,t)=>h(e,eT(t)),X="Option",Y=e=>({show:t=>eV(t)?"none":`some(${e.show(t.value)})`}),ee=e=>({equals:(t,a)=>t===a||(eV(t)?eV(a):!eV(a)&&e.equals(t.value,a.value))}),et=e=>({equals:ee(e).equals,compare:(t,a)=>t===a?0:eQ(t)?eQ(a)?e.compare(t.value,a.value):1:eQ(a)?-1:0}),ea=e=>({concat:(t,a)=>eV(t)?a:eV(a)?t:T(e.concat(t.value,a.value)),empty:C}),er=e=>t=>eV(t)?C:T(e(t.value)),ei={URI:X,map:P},eo=f(2,v(ei)),ep=g(ei),el=T,en={URI:X,of:el},em=e=>t=>eV(t)||eV(e)?C:T(t.value(e.value)),eu={URI:X,map:P,ap:Z},es={URI:X,map:P,ap:Z,of:el},ef=f(2,(e,t)=>eV(e)?C:t(e.value)),ec={URI:X,map:P,ap:Z,chain:ef},ed={URI:X,map:P,ap:Z,of:el,chain:ef},eh=(e,t)=>a=>eV(a)?e:t(e,a.value),ev=e=>t=>a=>eV(a)?e.empty:t(a.value),eg=(e,t)=>a=>eV(a)?e:t(a.value,e),eO={URI:X,reduce:z,foldMap:D,reduceRight:$},e_=f(2,(e,t)=>eV(e)?t():e),eM=e_,ey=e_,eE={URI:X,map:P,alt:B},eb=()=>C,eA={URI:X,zero:eb},ej=N(eA,en),ew={URI:X,map:P,ap:Z,of:el,alt:B,zero:eb},eF=e=>t=>eV(t)?C:T(e(t)),eR={URI:X,map:P,extend:J},eS=ef(d),ex=W(C,C),eW=e=>eV(e)?ex:W(U(e.value),L(e.value)),eq={URI:X,compact:eS,separate:eW},eK=e=>t=>eV(t)?C:e(t.value)?t:C,eN=e=>t=>eV(t)?C:e(t.value),eC=e=>t=>W(G(t,R(e)),G(t,e)),eT=e=>c(er(e),eW),eI={URI:X,map:P,compact:eS,separate:eW,filter:G,filterMap:H,partition:Q,partitionMap:V},eU=e=>t=>a=>eV(a)?e.of(C):e.map(t(a.value),T),eL=e=>t=>eV(t)?e.of(C):e.map(t.value,T),eP={URI:X,map:P,reduce:z,foldMap:D,reduceRight:$,traverse:k,sequence:eL},eZ=K(eP,eq),ez=q(eP,eq),eD=e=>{let t=eZ(e);return e=>a=>t(a,e)},e$=e=>{let t=ez(e);return e=>a=>t(a,e)},ek={URI:X,map:P,reduce:z,foldMap:D,reduceRight:$,traverse:k,sequence:eL,compact:eS,separate:eW,filter:G,filterMap:H,partition:Q,partitionMap:V,wither:eZ,wilt:ez},eB=()=>C,eG={URI:X,map:P,ap:Z,of:el,chain:ef,throwError:eB},eH=L,eJ={URI:X,fromEither:eH},eQ=j,eV=e=>"None"===e._tag,eX=(e,t)=>a=>eV(a)?e():t(a.value),eY=eX,e2=eX,e0=e2,e1=e=>t=>eV(t)?e():t.value,e3=e1,e4=_(ei),e5=t(eu),e6=r(eu),e7=eS,e8=f(2,p(ec)),e9=f(2,m(eJ,ec)),te=eF(d),tt=n(eJ),ta=l(eJ,ec),tr=e9,ti=e=>null==e?C:T(e),to=e=>{try{return T(e())}catch(e){return C}},tp=e=>(...t)=>to(()=>e(...t)),tl=e=>c(e,ti),tn=e=>t=>eV(t)?C:ti(e(t.value)),tm=e2(u,d),tu=e2(s,d);function ts(e){return(t,a)=>{if(void 0===a){let a=ts(e);return e=>a(t,e)}return!eV(a)&&e.equals(t,a.value)}}let tf=e=>t=>!eV(t)&&e(t.value),tc=el(E),td=O(ei),th=M(ei),tv=o(ec),tg=a(eu),tO=el(y),t_=e=>t=>{let a=e(0,b(t));if(eV(a))return C;let r=[a.value];for(let a=1;a<t.length;a++){let i=e(a,t[a]);if(eV(i))return C;r.push(i.value)}return T(r)},tM=e=>{let t=t_(e);return e=>A(e)?t(e):tO},ty=tM,tE=e=>tM((t,a)=>e(a)),tb=tE(d),tA=ef,tj=e8;function tw(e){return t=>eQ(e(t))}let tF=tn,tR={URI:X,map:P,of:el,ap:Z,chain:ef,reduce:z,foldMap:D,reduceRight:$,traverse:k,sequence:eL,zero:eb,alt:B,extend:J,compact:eS,separate:eW,filter:G,filterMap:H,partition:Q,partitionMap:V,wither:eZ,wilt:ez,throwError:eB},tS=i(eu),tx=e(es),tW=()=>ea(S()),tq=()=>ea(x());export{eE as Alt,ew as Alternative,tO as ApT,es as Applicative,eu as Apply,ec as Chain,eq as Compactable,tc as Do,eR as Extend,eI as Filterable,eO as Foldable,eJ as FromEither,ei as Functor,ed as Monad,eG as MonadThrow,en as Pointed,eP as Traversable,X as URI,ek as Witherable,eA as Zero,ey as alt,eM as altW,em as ap,e5 as apFirst,tg as apS,e6 as apSecond,eo as as,ep as asUnit,tv as bind,td as bindTo,tA as chain,ta as chainEitherK,tj as chainFirst,tr as chainFirstEitherK,tn as chainNullableK,eS as compact,te as duplicate,ts as elem,tf as exists,eF as extend,eK as filter,eN as filterMap,e4 as flap,ef as flatMap,e7 as flatten,e0 as fold,ev as foldMap,eY as foldW,eH as fromEither,tt as fromEitherK,ti as fromNullable,tl as fromNullableK,I as fromPredicate,tx as getApplyMonoid,tS as getApplySemigroup,ee as getEq,tW as getFirstMonoid,tq as getLastMonoid,U as getLeft,ea as getMonoid,e3 as getOrElse,e1 as getOrElseW,et as getOrd,tw as getRefinement,L as getRight,Y as getShow,ej as guard,eV as isNone,eQ as isSome,th as let,er as map,tF as mapNullable,e2 as match,eX as matchW,C as none,el as of,tR as option,e_ as orElse,eC as partition,eT as partitionMap,eh as reduce,eg as reduceRight,eW as separate,eL as sequence,tb as sequenceArray,T as some,e8 as tap,e9 as tapEither,eB as throwError,tm as toNullable,tu as toUndefined,eU as traverse,tE as traverseArray,ty as traverseArrayWithIndex,tM as traverseReadonlyArrayWithIndex,t_ as traverseReadonlyNonEmptyArrayWithIndex,to as tryCatch,tp as tryCatchK,e$ as wilt,eD as wither,eb as zero};