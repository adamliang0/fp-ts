import{pipe as t}from"./function.mjs";import{snd as n}from"./ReadonlyTuple.mjs";function o(t){return n=>o=>t.of([n,o])}function e(t){return n=>o=>e=>t.map(o(e),([t,o])=>[n(t),o])}function r(t){return n=>o=>e=>t.chain(o(e),([o,e])=>t.map(n(e),([t,n])=>[o(t),n]))}function f(t){let n=u(t);return t=>o=>n(o,t)}function u(t){return(n,o)=>e=>t.chain(n(e),([t,n])=>o(t)(n))}function a(t){return n=>o=>t.of(n(o))}function i(t){return n=>o=>t.map(n,t=>[t,o])}function m(t){return n=>o=>t.map(o(n),([t])=>t)}function c(t){return o=>e=>t.map(e(o),n)}function p(n){let u=r(n),p=e(n),l=f(n),S=m(n),d=c(n);return{map:(n,o)=>t(n,p(o)),ap:(n,o)=>t(n,u(o)),of:o(n),chain:(n,o)=>t(n,l(o)),get:()=>t=>n.of([t,t]),put:t=>()=>n.of([void 0,t]),modify:t=>o=>n.of([void 0,t(o)]),gets:t=>o=>n.of([t(o),o]),fromState:a(n),fromM:i(n),evalState:(n,o)=>t(n,S(o)),execState:(n,o)=>t(n,d(o))}}export{r as ap,f as chain,m as evaluate,c as execute,u as flatMap,i as fromF,a as fromState,p as getStateM,e as map,o as of};