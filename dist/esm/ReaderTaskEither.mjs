import{getApplicativeMonoid as a}from"./Applicative.mjs";import{ap as e,apFirst as r,apS as t,apSecond as i,getApplySemigroup as s}from"./Apply.mjs";import{bind as h,tap as o}from"./Chain.mjs";import{compact as p,separate as d}from"./Compactable.mjs";import{Functor as m,getCompactable as l,getFilterable as n,getSemigroup as E}from"./Either.mjs";import{alt as f,altValidation as R,ap as k,chainNullableK as T,flatMap as c,fromNullable as _,fromNullableK as K,getOrElse as O,left as W,leftF as I,map as u,mapBoth as F,mapError as y,match as M,matchE as b,orElse as g,orLeft as A,right as v,rightF as S,swap as j,tapError as N,toUnion as q}from"./EitherT.mjs";import{filter as x,filterMap as L,partition as P,partitionMap as C}from"./Filterable.mjs";import{chainOptionK as U,filterOrElse as w,fromEitherK as B,fromOption as V,fromOptionK as D,fromPredicate as z,tapEither as G}from"./FromEither.mjs";import{fromIOK as H,tapIO as J}from"./FromIO.mjs";import{ask as Q,asks as X,fromReaderK as Y,tapReader as Z}from"./FromReader.mjs";import{fromTaskK as $,tapTask as aa}from"./FromTask.mjs";import{SK as ae,dual as ar,flow as at,identity as ai,pipe as as}from"./function.mjs";import{as as ah,asUnit as ao,bindTo as ap,flap as ad,let as am}from"./Functor.mjs";import{emptyReadonlyArray as al,emptyRecord as an,flatMapEither as aE,flatMapIO as af,flatMapNullable as aR,flatMapOption as ak,flatMapReader as aT,flatMapTask as ac,isNonEmpty as a_,liftNullable as aK,liftOption as aO}from"./internal.mjs";import{Apply as aW,asksReaderW as aI,local as au,map as aF,of as ay,traverseReadonlyNonEmptyArrayWithIndex as aM}from"./Reader.mjs";import{ApplyPar as ab,ApplySeq as ag,Chain as aA,Functor as av,Monad as aS,Pointed as aj,of as aN}from"./ReaderTask.mjs";import{ApplicativePar as aq}from"./Task.mjs";import{bracketW as ax,fromEither as aL,fromIOEither as aP,getApplicativeTaskValidation as aC,left as aU,leftIO as aw,leftTask as aB,right as aV,rightIO as aD,rightTask as az,traverseReadonlyNonEmptyArrayWithIndex as aG,traverseReadonlyNonEmptyArrayWithIndexSeq as aH}from"./TaskEither.mjs";let aJ=ay,aQ=W(aj),aX=v(aj),aY=at(az,aJ),aZ=at(aB,aJ),a$=a=>at(a,aV),a2=a=>at(a,aU),a0=S(av),a3=I(av),a1=at(aD,aJ),a4=at(aw,aJ),a5=a=>at(a,aD),a6=a=>at(a,aw),a7=aN,a8=a$,a9=a1,ea=aY,ee=at(aP,aJ),er=a=>at(a,aL),et=M(av),ei=et,es=b(aA),eh=es,eo=es,ep=eo,ed=O(aS),em=ed,el=q(av),en=_(aj),eE=K(aj),ef=T(aS),eR=au,ek=aI,eT=ek,ec=g(aS),e_=ec,eK=ar(2,N(aS)),eO=A(aS),eW=eO,eI=j(av),eu=a=>at(a,ee),eF=a=>at(a,aJ),ey=a=>at(a,er),eM=(a,e)=>as(a,ev(e)),eb=(a,e)=>as(a,ex(e)),eg=(a,e)=>eC(a,a=>as(e,ev(a))),eA=(a,e)=>as(a,eB(e)),ev=u(av),eS=ar(3,F(av)),ej=eS,eN=ar(2,y(av)),eq=eN,ex=k(ab),eL=ex,eP=aX,eC=ar(2,c(aS)),eU=eC(ai),ew=eU,eB=f(aS),eV=eB,eD=aQ,ez="ReaderTaskEither",eG=a=>{let e=l(a);return{URI:ez,_E:void 0,compact:p(av,e),separate:d(av,e,m)}};function eH(a){let e=n(a),r=eG(a),t=x(av,e),i=L(av,e),s=P(av,e),h=C(av,e);return{URI:ez,_E:void 0,map:eM,compact:r.compact,separate:r.separate,filter:(a,e)=>as(a,t(e)),filterMap:(a,e)=>as(a,i(e)),partition:(a,e)=>as(a,s(e)),partitionMap:(a,e)=>as(a,h(e))}}function eJ(a,r){let t=e(aW,aC(a,r));return{URI:ez,_E:void 0,map:eM,ap:(a,e)=>as(a,t(e)),of:eP}}function eQ(a){let e=R(aS,a);return{URI:ez,_E:void 0,map:eM,alt:(a,r)=>as(a,e(r))}}let eX={URI:ez,map:eM},eY=ar(2,ah(eX)),eZ=ao(eX),e$=ad(eX),e2={URI:ez,of:eP},e0={URI:ez,map:eM,ap:eb},e3=r(e0),e1=e3,e4=i(e0),e5=e4,e6={URI:ez,map:eM,ap:eb,of:eP},e7={URI:ez,map:eM,ap:eg},e8={URI:ez,map:eM,ap:eg,of:eP},e9={URI:ez,map:eM,ap:eb,chain:eC},ra={URI:ez,map:eM,ap:eb,chain:eC,of:eP},re={URI:ez,map:eM,ap:eb,chain:eC,of:eP,fromIO:a9},rr={URI:ez,map:eM,ap:eb,chain:eC,of:eP,fromIO:a9,fromTask:ea},rt={URI:ez,map:eM,ap:eb,chain:eC,of:eP,throwError:eD},ri={URI:ez,fromEither:a7},rs={URI:ez,fromIO:a9},rh={URI:ez,fromIO:a9,fromTask:ea},ro={URI:ez,fromReader:a8},rp=ar(2,o(e9)),rd=ar(2,G(ri,e9)),rm=ar(2,J(rs,e9)),rl=ar(2,aa(rh,e9)),rn=ar(2,Z(ro,e9)),rE=ar(2,(a,e)=>rp(a,ey(e))),rf=ar(2,(a,e)=>rp(a,eF(e))),rR=ar(2,(a,e)=>rp(a,rb(e))),rk=ar(2,(a,e)=>rp(a,rv(e))),rT={URI:ez,bimap:eS,mapLeft:eN},rc={URI:ez,map:eM,alt:eA},r_=Q(ro),rK=X(ro),rO=Y(ro),rW=rn,rI=rn,ru=rE,rF=rE,ry=rf,rM=rf,rb=a=>(...e)=>a0(a(...e)),rg=rR,rA=rR,rv=a=>(...e)=>a5(a(...e)),rS=rk,rj=rk,rN=V(ri),rq=D(ri),rx=U(ri,e9),rL=rx,rP={fromEither:ri.fromEither},rC=aK(rP),rU=aO(rP),rw={flatMap:eC},rB=aR(rP,rw),rV=ak(rP,rw),rD=aE(rP,rw),rz=ar(2,(a,e)=>eC(a,eF(e))),rG=ar(2,(a,e)=>eC(a,rb(e))),rH=af({fromIO:a9},rw),rJ=ac({fromTask:ea},rw),rQ=aT({fromReader:a8},rw),rX=ar(2,(a,e)=>eC(a,rv(e))),rY=ar(2,(a,e)=>eC(a,eu(e))),rZ=ar(2,(a,e)=>eC(a,ey(e))),r$=rD,r2=rD,r0=rd,r3=rd,r1=rz,r4=rz,r5=rG,r6=rG,r7=z(ri),r8=w(ri,e9),r9=r8,ta=B(ri),te=H(rs),tr=rH,tt=rm,ti=$(rh),ts=rJ,th=rl,to=rQ,tp=rQ,td=rX,tm=rX,tl=rY,tn=rY,tE=rZ,tf=rZ;function tR(a,e,r){return tk(a,e,r)}function tk(a,e,r){return t=>ax(a(t),a=>e(a)(t),(a,e)=>r(a,e)(t))}let tT=eP(an),tc=ap(eX),t_=am(eX),tK=h(e9),tO=tK,tW=t(e0),tI=tW,tu=eP(al),tF=a=>at(aM(a),aF(aG(ae))),ty=a=>{let e=tF(a);return a=>a_(a)?e(a):tu},tM=a=>at(aM(a),aF(aH(ae))),tb=a=>{let e=tM(a);return a=>a_(a)?e(a):tu},tg=ty,tA=a=>ty((e,r)=>a(r)),tv=tA(ai),tS=tb,tj=a=>tb((e,r)=>a(r)),tN=tj(ai),tq=eC,tx=eC,tL=rp,tP=rp,tC=eK,tU=eK,tw={URI:ez,map:eM,of:eP,ap:eb,chain:eC,alt:eA,bimap:eS,mapLeft:eN,fromIO:a9,fromTask:ea,throwError:eD},tB={URI:ez,map:eM,of:eP,ap:eg,chain:eC,alt:eA,bimap:eS,mapLeft:eN,fromIO:a9,fromTask:ea,throwError:eD},tV=s(e7),tD=a(e8),tz=a=>s(ag)(E(a));function tG(a){let e=eJ(aq,a),r=eQ(a);return{URI:ez,_E:void 0,map:eM,of:eP,chain:eC,bimap:eS,mapLeft:eN,ap:e.ap,alt:r.alt,fromIO:a9,fromTask:ea,throwError:eD}}function tH(a,e){return a(e)()}export{rc as Alt,tu as ApT,e6 as ApplicativePar,e8 as ApplicativeSeq,e0 as ApplyPar,e7 as ApplySeq,rT as Bifunctor,e9 as Chain,tT as Do,ri as FromEither,rs as FromIO,ro as FromReader,rh as FromTask,eX as Functor,ra as Monad,re as MonadIO,rr as MonadTask,rt as MonadThrow,e2 as Pointed,ez as URI,eB as alt,eV as altW,ex as ap,e3 as apFirst,e1 as apFirstW,tW as apS,tI as apSW,e4 as apSecond,e5 as apSecondW,eL as apW,eY as as,eZ as asUnit,r_ as ask,rK as asks,eT as asksReaderTaskEither,ek as asksReaderTaskEitherW,ej as bimap,tK as bind,tc as bindTo,tO as bindW,tR as bracket,tk as bracketW,tq as chain,r$ as chainEitherK,r2 as chainEitherKW,tL as chainFirst,r0 as chainFirstEitherK,r3 as chainFirstEitherKW,tt as chainFirstIOK,rF as chainFirstReaderEitherK,ru as chainFirstReaderEitherKW,rj as chainFirstReaderIOK,rS as chainFirstReaderIOKW,rW as chainFirstReaderK,rI as chainFirstReaderKW,rA as chainFirstReaderTaskK,rg as chainFirstReaderTaskKW,rM as chainFirstTaskEitherK,ry as chainFirstTaskEitherKW,th as chainFirstTaskK,tP as chainFirstW,tn as chainIOEitherK,tl as chainIOEitherKW,tr as chainIOK,ef as chainNullableK,rx as chainOptionK,rL as chainOptionKW,tf as chainReaderEitherK,tE as chainReaderEitherKW,tm as chainReaderIOK,td as chainReaderIOKW,to as chainReaderK,tp as chainReaderKW,r6 as chainReaderTaskK,r5 as chainReaderTaskKW,r4 as chainTaskEitherK,r1 as chainTaskEitherKW,ts as chainTaskK,tx as chainW,r8 as filterOrElse,r9 as filterOrElseW,e$ as flap,eC as flatMap,rD as flatMapEither,rH as flatMapIO,rY as flatMapIOEither,rB as flatMapNullable,rV as flatMapOption,rQ as flatMapReader,rZ as flatMapReaderEither,rX as flatMapReaderIO,rG as flatMapReaderTask,rJ as flatMapTask,rz as flatMapTaskEither,ew as flatten,eU as flattenW,eh as fold,ep as foldW,a7 as fromEither,ta as fromEitherK,a9 as fromIO,ee as fromIOEither,eu as fromIOEitherK,te as fromIOK,en as fromNullable,eE as fromNullableK,rN as fromOption,rq as fromOptionK,r7 as fromPredicate,a8 as fromReader,er as fromReaderEither,ey as fromReaderEitherK,rv as fromReaderIOK,rO as fromReaderK,rb as fromReaderTaskK,ea as fromTask,aJ as fromTaskEither,eF as fromTaskEitherK,ti as fromTaskK,eQ as getAltReaderTaskValidation,eJ as getApplicativeReaderTaskValidation,tD as getApplyMonoid,tV as getApplySemigroup,eG as getCompactable,eH as getFilterable,ed as getOrElse,em as getOrElseW,tG as getReaderTaskValidation,tz as getSemigroup,aQ as left,a4 as leftIO,a2 as leftReader,a6 as leftReaderIO,a3 as leftReaderTask,aZ as leftTask,t_ as let,rC as liftNullable,rU as liftOption,eR as local,ev as map,eS as mapBoth,eN as mapError,eq as mapLeft,et as match,es as matchE,eo as matchEW,ei as matchW,eP as of,ec as orElse,tC as orElseFirst,tU as orElseFirstW,e_ as orElseW,eO as orLeft,eW as orLeftW,tw as readerTaskEither,tB as readerTaskEitherSeq,aX as right,a1 as rightIO,a$ as rightReader,a5 as rightReaderIO,a0 as rightReaderTask,aY as rightTask,tH as run,tv as sequenceArray,tN as sequenceSeqArray,eI as swap,rp as tap,rd as tapEither,eK as tapError,rm as tapIO,rn as tapReader,rE as tapReaderEither,rk as tapReaderIO,rR as tapReaderTask,rl as tapTask,rf as tapTaskEither,eD as throwError,el as toUnion,tA as traverseArray,tg as traverseArrayWithIndex,ty as traverseReadonlyArrayWithIndex,tb as traverseReadonlyArrayWithIndexSeq,tF as traverseReadonlyNonEmptyArrayWithIndex,tM as traverseReadonlyNonEmptyArrayWithIndexSeq,tj as traverseSeqArray,tS as traverseSeqArrayWithIndex};