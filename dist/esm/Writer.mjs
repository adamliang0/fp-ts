import{pipe as t}from"./function.mjs";import{flap as e}from"./Functor.mjs";let r=t=>()=>[void 0,t],n=t=>()=>{let[e,r]=t();return[[e,r],r]},a=t=>()=>{let[[e,r],n]=t();return[e,r(n)]},o=t=>e=>()=>{let[r,n]=e();return[[r,t(n)],n]},i=t=>e=>()=>{let[r,n]=e();return[r,t(n)]},p=(e,r)=>t(e,l(r)),l=t=>e=>()=>{let[r,n]=e();return[t(r),n]},u="Writer",c=t=>({URI:u,_E:void 0,of:e=>()=>[e,t.empty]}),m=t=>({URI:u,_E:void 0,map:p,ap:(e,r)=>()=>{let[n,a]=e(),[o,i]=r();return[n(o),t.concat(a,i)]}}),f=t=>{let e=m(t),r=c(t);return{URI:u,_E:void 0,map:p,ap:e.ap,of:r.of}};function s(t){return{URI:u,_E:void 0,map:p,ap:m(t).ap,chain:(e,r)=>()=>{let[n,a]=e(),[o,i]=r(n)();return[o,t.concat(a,i)]}}}function v(t){let e=f(t),r=s(t);return{URI:u,_E:void 0,map:p,ap:e.ap,of:e.of,chain:r.chain}}let d={URI:u,map:p},_=e(d),g=t=>t()[0],E=t=>t()[1],h=t=>t()[0],W=t=>t()[1],x=d;export{d as Functor,u as URI,i as censor,h as evalWriter,g as evaluate,W as execWriter,E as execute,_ as flap,f as getApplicative,m as getApply,s as getChain,v as getMonad,c as getPointed,n as listen,o as listens,l as map,a as pass,r as tell,x as writer};