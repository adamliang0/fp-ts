import{apFirst as a,apS as e,apSecond as r}from"./Apply.mjs";import{bind as s,tap as d}from"./Chain.mjs";import{fromIOK as o,tapIO as p}from"./FromIO.mjs";import{ask as t,asks as m,fromReaderK as R,tapReader as n}from"./FromReader.mjs";import{SK as I,dual as i,flow as O,identity as f,pipe as _}from"./function.mjs";import{as as l,asUnit as c,bindTo as h,flap as y}from"./Functor.mjs";import{emptyReadonlyArray as F,emptyRecord as W,flatMapIO as A,flatMapReader as j,isNonEmpty as K}from"./internal.mjs";import{Apply as M,Functor as v,Monad as k,Pointed as u,traverseReadonlyNonEmptyArrayWithIndex as x}from"./IO.mjs";import{asksReaderW as b,local as S,map as T,of as E,traverseReadonlyNonEmptyArrayWithIndex as N}from"./Reader.mjs";import{ap as U,flatMap as C,fromReader as P,map as q,of as D}from"./ReaderT.mjs";let g=P(u),w=E,z=S,B=b,G=B,H=(a,e)=>_(a,L(e)),J=(a,e)=>_(a,Q(e)),L=q(v),Q=U(M),V=Q,X=D(u),Y=i(2,C(k)),Z=Y(f),$=Z,aa="ReaderIO",ae={URI:aa,map:H},ar=i(2,l(ae)),as=c(ae),ad=y(ae),ao={URI:aa,of:X},ap={URI:aa,map:H,ap:J},at=a(ap),am=r(ap),aR={URI:aa,map:H,ap:J,of:X},an={URI:aa,map:H,ap:J,chain:Y},aI={URI:aa,map:H,of:X,ap:J,chain:Y},ai={URI:aa,map:H,of:X,ap:J,chain:Y,fromIO:w},aO={URI:aa,fromIO:w},af={URI:aa,fromReader:g},a_={flatMap:Y},al=A({fromIO:aO.fromIO},a_),ac=j({fromReader:g},a_),ah=i(2,d(an)),ay=i(2,p(aO,an)),aF=i(2,n(af,an)),aW=o(aO),aA=al,aj=ay,aK=t(af),aM=m(af),av=R(af),ak=ac,au=ac,ax=aF,ab=aF,aS=X(W),aT=h(ae),aE=s(an),aN=aE,aU=e(ap),aC=aU,aP=X(F),aq=a=>O(N(a),T(x(I))),aD=a=>{let e=aq(a);return a=>K(a)?e(a):aP},ag=aD,aw=a=>aD((e,r)=>a(r)),az=aw(f),aB=Y,aG=Y,aH=ah,aJ=ah;export{aP as ApT,aR as Applicative,ap as Apply,an as Chain,aS as Do,aO as FromIO,af as FromReader,ae as Functor,aI as Monad,ai as MonadIO,ao as Pointed,aa as URI,Q as ap,at as apFirst,aU as apS,aC as apSW,am as apSecond,V as apW,ar as as,as as asUnit,aK as ask,aM as asks,G as asksReaderIO,B as asksReaderIOW,aE as bind,aT as bindTo,aN as bindW,aB as chain,aH as chainFirst,aj as chainFirstIOK,ax as chainFirstReaderK,ab as chainFirstReaderKW,aJ as chainFirstW,aA as chainIOK,ak as chainReaderK,au as chainReaderKW,aG as chainW,ad as flap,Y as flatMap,al as flatMapIO,ac as flatMapReader,$ as flatten,Z as flattenW,w as fromIO,aW as fromIOK,g as fromReader,av as fromReaderK,z as local,L as map,X as of,az as sequenceArray,ah as tap,ay as tapIO,aF as tapReader,aw as traverseArray,ag as traverseArrayWithIndex,aD as traverseReadonlyArrayWithIndex,aq as traverseReadonlyNonEmptyArrayWithIndex};