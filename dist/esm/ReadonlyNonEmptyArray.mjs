import{apFirst as e,apS as t,apSecond as r}from"./Apply.mjs";import{bind as n,chainFirst as a}from"./Chain.mjs";import{fromEquals as l}from"./Eq.mjs";import{SK as o,dual as i,flow as p,identity as d,pipe as u}from"./function.mjs";import{bindTo as c,flap as h,let as s}from"./Functor.mjs";import{emptyReadonlyArray as m,emptyRecord as f,fromReadonlyNonEmptyArray as y,has as g,head as x,isNonEmpty as A,none as W,singleton as R,some as I,tail as E}from"./internal.mjs";import{getMonoid as M}from"./Ord.mjs";import{max as N,min as v}from"./Semigroup.mjs";let _=m,b=A,j=(e,t)=>e<0||e>=t.length,F=e=>t=>[e,...t],S=F,q=e=>t=>[...t,e],T=q,B=(e,t,r)=>{if(b(r)){let n=y(r);return n.splice(e,0,t),n}return[t]},O=(e,t,r)=>{if(r[e]===t)return r;{let n=y(r);return n[e]=t,n}},w=e=>t=>{if(1===t.length)return t;let r=[to(t)];for(let n of ti(t))r.every(t=>!e.equals(t,n))&&r.push(n);return r},z=e=>{if(b(e)){let t=M();return Y(e.reduce(t.concat,t.empty))}return d},C=e=>{let t=w(e);return e=>r=>t(u(r,K(e)))},L=e=>t=>{let r=t.length,n=Math.round(e)%r;if(j(Math.abs(n),t)||0===n)return t;if(!(n<0))return L(n-r)(t);{let[e,r]=ep(-n)(t);return u(r,K(e))}},U=e=>b(e)?I(e):W,k=e=>t=>{let r=Math.max(0,Math.floor(t)),n=[e(0)];for(let t=1;t<r;t++)n.push(e(t));return n},H=e=>k(()=>e),D=(e,t)=>e<=t?k(t=>e+t)(t-e+1):[e],P=e=>[to(e),ti(e)],$=e=>[td(e),tp(e)],G=e=>U(e.slice());function J(e){return t=>t.concat(e)}function K(e,t){return t?e.concat(t):t=>t.concat(e)}let Q=e=>1===e.length?e:[tp(e),...e.slice(0,-1).reverse()];function V(e){return t=>{let r=t.length;if(0===r)return _;let n=[],a=t[0],l=[a];for(let o=1;o<r;o++){let r=t[o];e.equals(r,a)?l.push(r):(n.push(l),l=[a=r])}return n.push(l),n}}let X=e=>t=>{let r={};for(let n of t){let t=e(n);g.call(r,t)?r[t].push(n):r[t]=[n]}return r},Y=e=>t=>1===t.length?t:t.slice().sort(e.compare),Z=(e,t)=>ee(e,()=>t),ee=(e,t)=>r=>j(e,r)?W:I(O(e,t(r[e]),r)),et=(e,t,r)=>{let n=[r(e[0],t[0])],a=Math.min(e.length,t.length);for(let l=1;l<a;l++)n[l]=r(e[l],t[l]);return n};function er(e,t){return void 0===t?t=>er(t,e):et(e,t,(e,t)=>[e,t])}let en=e=>{let t=[e[0][0]],r=[e[0][1]];for(let n=1;n<e.length;n++)t[n]=e[n][0],r[n]=e[n][1];return[t,r]},ea=e=>t=>{let r=[e,t[0]];for(let n=1;n<t.length;n++)r.push(e,t[n]);return r},el=e=>t=>{let r=ti(t);return b(r)?u(r,ea(e),S(to(t))):t},eo=e=>t=>{let r=y(e(0,to(t)));for(let n=1;n<t.length;n++){let a=e(n,t[n]);for(let e=0;e<a.length;e++)r.push(a[e])}return r},ei=e=>t=>{let[r,n]=e(t),a=[r],l=n;for(;b(l);){let[t,r]=e(l);a.push(t),l=r}return a},ep=e=>t=>{let r=Math.max(1,e);return r>=t.length?[t,_]:[u(t.slice(1,r),S(to(t))),t.slice(r)]},ed=e=>ei(ep(e)),eu=(e,t)=>u(e,eS(t)),ec=(e,t)=>u(e,eq(t)),eh=(e,t)=>u(e,ev(t)),es=(e,t)=>u(e,eb(t)),em=(e,t,r)=>u(e,eT(t,r)),ef=e=>{let t=eB(e);return(e,r)=>u(e,t(r))},ey=(e,t,r)=>u(e,eO(t,r)),eg=e=>{let t=eL(e);return(e,r)=>u(e,t(r))},ex=(e,t)=>u(e,eN(t)),eA=(e,t,r)=>u(e,ew(t,r)),eW=e=>{let t=ez(e);return(e,r)=>u(e,t(r))},eR=(e,t,r)=>u(e,eC(t,r)),eI=e=>{let t=ek(e);return(e,r)=>u(e,t(r))},eE=R,eM=e=>t=>u(t,J(e())),eN=eM,ev=e=>e_(t=>u(e,eS(t))),e_=i(2,(e,t)=>u(e,eo((e,r)=>t(r,e)))),eb=e=>t=>{let r=ti(t),n=[e(t)];for(;b(r);)n.push(e(r)),r=ti(r);return n},ej=eb(d),eF=e_(d),eS=e=>eq((t,r)=>e(r)),eq=e=>t=>{let r=[e(0,to(t))];for(let n=1;n<t.length;n++)r.push(e(n,t[n]));return r},eT=(e,t)=>ew(e,(e,r,n)=>t(r,n)),eB=e=>t=>r=>r.slice(1).reduce((r,n)=>e.concat(r,t(n)),t(r[0])),eO=(e,t)=>eC(e,(e,r,n)=>t(r,n)),ew=(e,t)=>r=>r.reduce((e,r,n)=>t(n,e,r),e),ez=e=>t=>r=>r.slice(1).reduce((r,n,a)=>e.concat(r,t(a+1,n)),t(0,r[0])),eC=(e,t)=>r=>r.reduceRight((e,r,n)=>t(n,r,e),e),eL=e=>{let t=ek(e);return e=>t((t,r)=>e(r))},eU=e=>ek(e)(o),ek=e=>t=>r=>{let n=e.map(t(0,to(r)),eE);for(let a=1;a<r.length;a++)n=e.ap(e.map(n,e=>t=>u(e,T(t))),t(a,r[a]));return n},eH=x,eD="ReadonlyNonEmptyArray",eP=e=>({show:t=>`[${t.map(e.show).join(", ")}]`}),e$=()=>({concat:K}),eG=e=>l((t,r)=>t.length===r.length&&t.every((t,n)=>e.equals(t,r[n]))),eJ=e=>{let t=C(e);return{concat:(e,r)=>t(r)(e)}},eK={URI:eD,map:eu},eQ=h(eK),eV={URI:eD,of:eE},eX={URI:eD,map:eu,mapWithIndex:ec},eY={URI:eD,map:eu,ap:eh},eZ=e(eY),e0=r(eY),e1={URI:eD,map:eu,ap:eh,of:eE},e2={URI:eD,map:eu,ap:eh,chain:e_},e3=a(e2),e4={URI:eD,map:eu,ap:eh,of:eE,chain:e_},e5={URI:eD,reduce:em,foldMap:ef,reduceRight:ey},e6={URI:eD,reduce:em,foldMap:ef,reduceRight:ey,reduceWithIndex:eA,foldMapWithIndex:eW,reduceRightWithIndex:eR},e7={URI:eD,map:eu,reduce:em,foldMap:ef,reduceRight:ey,traverse:eg,sequence:eU},e8={URI:eD,map:eu,mapWithIndex:ec,reduce:em,foldMap:ef,reduceRight:ey,traverse:eg,sequence:eU,reduceWithIndex:eA,foldMapWithIndex:eW,reduceRightWithIndex:eR,traverseWithIndex:eI},e9={URI:eD,map:eu,alt:ex},te={URI:eD,map:eu,extend:es,extract:eH},tt=eE(f),tr=c(eK),tn=s(eK),ta=n(e2),tl=t(eY),to=eH,ti=E,tp=e=>e[e.length-1],td=e=>e.slice(0,-1),tu=e=>{let t=v(e);return e=>e.reduce(t.concat)},tc=e=>{let t=N(e);return e=>e.reduce(t.concat)},th=e=>t=>t.reduce(e.concat),ts=e=>t=>e(to(t),ti(t)),tm=e=>t=>e(td(t),tp(t)),tf=e=>t=>[e(to(t)),...ti(t)],ty=e=>tf(()=>e),tg=e=>t=>u(td(t),T(e(tp(t)))),tx=e=>tg(()=>e),tA=e=>{let t=th(e);return e=>p(el(e),t)},tW=e_;function tR(e){let t=Y(e),r=V(e);return e=>b(e)?r(t(e)):_}function tI(e){return tE((t,r)=>e(r))}let tE=e=>t=>U(t.filter((t,r)=>e(r,t))),tM=P,tN=$;function tv(e,t){return void 0===t?S(e):u(t,S(e))}let t_=(e,t)=>u(e,K([t])),tb=(e,t)=>r=>e<0||e>r.length?W:I(B(e,t,r)),tj=ea,tF=th,tS={URI:eD,of:eE,map:eu,mapWithIndex:ec,ap:eh,chain:e_,extend:es,extract:eH,reduce:em,foldMap:ef,reduceRight:ey,traverse:eg,sequence:eU,reduceWithIndex:eA,foldMapWithIndex:eW,reduceRightWithIndex:eR,traverseWithIndex:eI,alt:ex};export{e9 as Alt,e1 as Applicative,eY as Apply,e2 as Chain,te as Comonad,tt as Do,e5 as Foldable,e6 as FoldableWithIndex,eK as Functor,eX as FunctorWithIndex,e4 as Monad,eV as Pointed,e7 as Traversable,e8 as TraversableWithIndex,eD as URI,eN as alt,eM as altW,ev as ap,eZ as apFirst,tl as apS,e0 as apSecond,T as append,q as appendW,ta as bind,tr as bindTo,tW as chain,e3 as chainFirst,eo as chainWithIndex,ei as chop,ed as chunksOf,K as concat,th as concatAll,J as concatW,tv as cons,ej as duplicate,_ as empty,eb as extend,eH as extract,tI as filter,tE as filterWithIndex,eQ as flap,e_ as flatMap,eF as flatten,tF as fold,eB as foldMap,ez as foldMapWithIndex,G as fromArray,U as fromReadonlyArray,eG as getEq,e$ as getSemigroup,eP as getShow,eJ as getUnionSemigroup,V as group,X as groupBy,tR as groupSort,to as head,td as init,tb as insertAt,tA as intercalate,el as intersperse,b as isNonEmpty,j as isOutOfBound,tp as last,tn as let,k as makeBy,eS as map,eq as mapWithIndex,ts as matchLeft,tm as matchRight,tc as max,tu as min,ee as modifyAt,tf as modifyHead,tg as modifyLast,eE as of,S as prepend,ea as prependAll,tj as prependToAll,F as prependW,D as range,tS as readonlyNonEmptyArray,eT as reduce,eO as reduceRight,eC as reduceRightWithIndex,ew as reduceWithIndex,H as replicate,Q as reverse,L as rotate,eU as sequence,t_ as snoc,Y as sort,z as sortBy,ep as splitAt,ti as tail,eL as traverse,ek as traverseWithIndex,$ as unappend,tM as uncons,C as union,w as uniq,P as unprepend,B as unsafeInsertAt,O as unsafeUpdateAt,tN as unsnoc,en as unzip,Z as updateAt,ty as updateHead,tx as updateLast,er as zip,et as zipWith};