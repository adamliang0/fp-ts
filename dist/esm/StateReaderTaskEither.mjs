import{apFirst as a,apS as e,apSecond as t}from"./Apply.mjs";import{bind as r,tap as i}from"./Chain.mjs";import{map as s,match as h}from"./Either.mjs";import{chainOptionK as o,filterOrElse as d,fromEitherK as m,fromOption as p,fromOptionK as n,fromPredicate as f,tapEither as E}from"./FromEither.mjs";import{fromIOK as k,tapIO as T}from"./FromIO.mjs";import{ask as R,asks as S,fromReaderK as l,tapReader as _}from"./FromReader.mjs";import{chainStateK as c,fromStateK as K,get as O,gets as u,modify as I,put as F}from"./FromState.mjs";import{fromTaskK as W,tapTask as M}from"./FromTask.mjs";import{dual as g,flow as j,identity as y,pipe as b}from"./function.mjs";import{as as A,asUnit as v,bindTo as x,flap as L,let as P}from"./Functor.mjs";import{emptyReadonlyArray as C,flatMapEither as U,flatMapIO as q,flatMapOption as w,flatMapReader as B,flatMapTask as N,head as z,isLeft as D,isNonEmpty as G,tail as H}from"./internal.mjs";import{local as J}from"./Reader.mjs";import{Chain as Q,Functor as V,Monad as X,Pointed as Y,alt as Z,altW as $,bimap as aa,fromIOEither as ae,fromReaderEither as at,fromTaskEither as ar,left as ai,leftIO as as,leftReader as ah,leftTask as ao,map as ad,mapLeft as am,right as ap,rightIO as an,rightReader as af,rightTask as aE}from"./ReaderTaskEither.mjs";import{ap as ak,evaluate as aT,execute as aR,flatMap as aS,fromF as al,fromState as a_,map as ac,of as aK}from"./StateT.mjs";let aO=a=>()=>ai(a),au=aK(Y);function aI(a){return aw(aE(a))}function aF(a){return aw(ao(a))}function aW(a){return aw(af(a))}function aM(a){return aw(ah(a))}function ag(a){return aw(an(a))}function aj(a){return aw(as(a))}let ay=a=>j(a,ap),ab=a=>e=>ai(a(e)[0]),aA=h(a=>aO(a),au),av=aW,ax=ag,aL=aI,aP=a_(Y),aC=a=>aw(ar(a)),aU=a=>aw(ae(a)),aq=a=>aw(at(a)),aw=al(V),aB=a=>e=>j(e,J(a)),aN=a=>e=>t=>a(t)(e)(t),az=aN,aD=a=>(...e)=>aU(a(...e)),aG=a=>(...e)=>aC(a(...e)),aH=a=>(...e)=>aw(a(...e)),aJ=a=>e=>a7(e,aH(a)),aQ=aJ,aV=(a,e)=>b(a,a2(e)),aX=(a,e)=>b(a,a3(e)),aY=(a,e)=>t=>b(a(t),Z(()=>e()(t))),aZ=(a,e,t)=>r=>b(a(r),aa(e,([a,e])=>[t(a),e])),a$=(a,e)=>t=>b(a(t),am(e)),a2=ac(V),a0=(a,e)=>t=>aZ(t,a,e),a1=a=>e=>a$(e,a),a3=ak(Q),a4=a3,a5=au,a6={fromEither:aA},a7=g(2,aS(X)),a8={flatMap:a7},a9=g(2,(a,e)=>a7(a,a=>aG(e)(a))),ea=q({fromIO:ax},a8),ee=N({fromTask:aL},a8),et=B({fromReader:av},a8),er=g(2,(a,e)=>a7(a,a=>aD(e)(a))),ei=g(2,U(a6,a8)),es=w(a6,a8),eh=g(2,(a,e)=>a7(a,a=>aH(e)(a))),eo=g(2,(a,e)=>a7(a,eb(e))),ed=a7(y),em=ed,ep=a=>e=>t=>b(e(t),$(()=>a()(t))),en=ep,ef=aO,eE="StateReaderTaskEither",ek={URI:eE,map:aV},eT=g(2,A(ek)),eR=v(ek),eS=L(ek),el={URI:eE,of:a5},e_={URI:eE,map:aV,ap:aX},ec=a(e_),eK=ec,eO=t(e_),eu=eO,eI={URI:eE,map:aV,ap:aX,of:a5},eF={URI:eE,map:aV,ap:aX,chain:a7},eW={URI:eE,fromState:aP},eM=O(eW),eg=F(eW),ej=I(eW),ey=u(eW),eb=K(eW),eA=c(eW,eF),ev={URI:eE,map:aV,ap:aX,of:a5,chain:a7},ex={URI:eE,map:aV,ap:aX,of:a5,chain:a7,fromIO:ax},eL={URI:eE,map:aV,ap:aX,of:a5,chain:a7,fromIO:ax,fromTask:aL},eP={URI:eE,map:aV,ap:aX,of:a5,chain:a7,throwError:ef},eC={URI:eE,fromEither:aA},eU={URI:eE,fromIO:ax},eq={URI:eE,fromIO:ax,fromTask:aL},ew={URI:eE,fromReader:av},eB=g(2,i(eF)),eN=g(2,E(eC,eF)),ez=g(2,T(eU,eF)),eD=g(2,M(eq,eF)),eG=g(2,_(ew,eF)),eH={URI:eE,bimap:aZ,mapLeft:a$},eJ={URI:eE,map:aV,alt:aY},eQ=R(ew),eV=S(ew),eX=l(ew),eY=et,eZ=et,e$=eG,e2=eG,e0=p(eC),e1=n(eC),e3=o(eC,eF),e4=e3,e5=ei,e6=ei,e7=eN,e8=eN,e9=f(eC),ta=d(eC,eF),te=ta,tt=m(eC),tr=k(eU),ti=ea,ts=ez,th=a9,to=a9,td=er,tm=er,tp=W(eq),tn=ee,tf=eD,tE=aT(V),tk=aR(V),tT=x(ek),tR=P(ek),tS=r(eF),tl=tS,t_=e(e_),tc=t_,tK=a=>e=>t=>r=>()=>H(e).reduce((e,t,i)=>e.then(s=>D(s)?e:a(i+1,t)(s.right[1])(r)().then(a=>{if(D(a))return a;let[e,t]=a.right;return s.right[0].push(e),s.right[1]=t,s})),a(0,z(e))(t)(r)().then(s(([a,e])=>[[a],e]))),tO=a=>{let e=tK(a);return a=>G(a)?e(a):a5(C)},tu=tO,tI=a=>tO((e,t)=>a(t)),tF=tI(y),tW=a7,tM=a7,tg=eB,tj=eB,ty={URI:eE,map:aV,of:a5,ap:aX,chain:a7,bimap:aZ,mapLeft:a$,alt:aY,fromIO:ax,fromTask:aL,throwError:ef},tb={URI:eE,map:aV,of:a5,ap:aX,chain:a7,bimap:aZ,mapLeft:a$,alt:aY,fromIO:ax,fromTask:aL,throwError:ef},tA=(a,e)=>b(a(e),ad(([a])=>a)),tv=(a,e)=>b(a(e),ad(([a,e])=>e));function tx(a,e,t){return a(e)(t)()}export{eJ as Alt,eI as Applicative,e_ as Apply,eH as Bifunctor,eF as Chain,eC as FromEither,eU as FromIO,ew as FromReader,eW as FromState,eq as FromTask,ek as Functor,ev as Monad,ex as MonadIO,eL as MonadTask,eP as MonadThrow,el as Pointed,eE as URI,en as alt,ep as altW,a3 as ap,ec as apFirst,eK as apFirstW,t_ as apS,tc as apSW,eO as apSecond,eu as apSecondW,a4 as apW,eT as as,eR as asUnit,eQ as ask,eV as asks,az as asksStateReaderTaskEither,aN as asksStateReaderTaskEitherW,a0 as bimap,tS as bind,tT as bindTo,tl as bindW,tW as chain,e5 as chainEitherK,e6 as chainEitherKW,tg as chainFirst,e7 as chainFirstEitherK,e8 as chainFirstEitherKW,ts as chainFirstIOK,e$ as chainFirstReaderK,e2 as chainFirstReaderKW,tf as chainFirstTaskK,tj as chainFirstW,tm as chainIOEitherK,td as chainIOEitherKW,ti as chainIOK,e3 as chainOptionK,e4 as chainOptionKW,eY as chainReaderK,eZ as chainReaderKW,aQ as chainReaderTaskEitherK,aJ as chainReaderTaskEitherKW,eA as chainStateK,to as chainTaskEitherK,th as chainTaskEitherKW,tn as chainTaskK,tM as chainW,tA as evalState,tE as evaluate,tv as execState,tk as execute,ta as filterOrElse,te as filterOrElseW,eS as flap,a7 as flatMap,ei as flatMapEither,ea as flatMapIO,er as flatMapIOEither,es as flatMapOption,et as flatMapReader,eh as flatMapReaderTaskEither,eo as flatMapState,ee as flatMapTask,a9 as flatMapTaskEither,em as flatten,ed as flattenW,aA as fromEither,tt as fromEitherK,ax as fromIO,aU as fromIOEither,aD as fromIOEitherK,tr as fromIOK,e0 as fromOption,e1 as fromOptionK,e9 as fromPredicate,av as fromReader,aq as fromReaderEither,eX as fromReaderK,aw as fromReaderTaskEither,aH as fromReaderTaskEitherK,aP as fromState,eb as fromStateK,aL as fromTask,aC as fromTaskEither,aG as fromTaskEitherK,tp as fromTaskK,eM as get,ey as gets,aO as left,aj as leftIO,aM as leftReader,ab as leftState,aF as leftTask,tR as let,aB as local,a2 as map,a1 as mapLeft,ej as modify,a5 as of,eg as put,au as right,ag as rightIO,aW as rightReader,ay as rightState,aI as rightTask,tx as run,tF as sequenceArray,ty as stateReaderTaskEither,tb as stateReaderTaskEitherSeq,eB as tap,eN as tapEither,ez as tapIO,eG as tapReader,eD as tapTask,ef as throwError,tI as traverseArray,tu as traverseArrayWithIndex,tO as traverseReadonlyArrayWithIndex,tK as traverseReadonlyNonEmptyArrayWithIndex};