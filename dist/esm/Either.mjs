import{getApplicativeMonoid as t}from"./Applicative.mjs";import{apFirst as r,apS as e,apSecond as i,getApplySemigroup as a}from"./Apply.mjs";import{bind as l,tap as o}from"./Chain.mjs";import{tailRec as p}from"./ChainRec.mjs";import{chainOptionK as n,filterOrElse as h,fromOption as f,fromOptionK as s,fromPredicate as m}from"./FromEither.mjs";import{dual as g,flow as c,identity as u,pipe as d}from"./function.mjs";import{as as E,asUnit as _,bindTo as v,flap as y,let as b}from"./Functor.mjs";import{emptyReadonlyArray as M,emptyRecord as O,flatMapNullable as W,flatMapOption as S,head as A,isLeft as R,isNonEmpty as N,isRight as w,left as F,liftNullable as j,liftOption as x,right as C}from"./internal.mjs";import{separated as K}from"./Separated.mjs";import{wiltDefault as q,witherDefault as L}from"./Witherable.mjs";let J=F,T=C,V=g(2,(t,r)=>tV(t)?t:r(t.right)),I=(t,r)=>d(t,to(r)),U=(t,r)=>d(t,tg(r)),P=(t,r,e)=>d(t,t_(r,e)),$=t=>(r,e)=>d(r,tv(t)(e)),B=(t,r,e)=>d(t,ty(r,e)),D=t=>{let r=tM(t);return(t,e)=>d(t,r(e))},k=(t,r,e)=>d(t,tS(r,e)),z=(t,r)=>d(t,tA(r)),G=(t,r)=>d(t,tw(r)),H=(t,r)=>d(t,tj(r)),Q=(t,r)=>p(r(t),t=>tV(t)?T(J(t.left)):tV(t.right)?J(r(t.right.left)):T(T(t.right.right))),X="Either",Y=(t,r)=>({show:e=>tV(e)?`left(${t.show(e.left)})`:`right(${r.show(e.right)})`}),Z=(t,r)=>({equals:(e,i)=>e===i||(tV(e)?tV(i)&&t.equals(e.left,i.left):tI(i)&&r.equals(e.right,i.right))}),tt=t=>({concat:(r,e)=>tV(e)?r:tV(r)?e:T(t.concat(r.right,e.right))}),tr=t=>{let r=J(t.empty);return{URI:X,_E:void 0,compact:t=>tV(t)?t:"None"===t.right._tag?r:T(t.right.value),separate:t=>tV(t)?K(t,t):tV(t.right)?K(T(t.right.left),r):K(r,T(t.right.right))}},te=t=>{let r=J(t.empty),{compact:e,separate:i}=tr(t);return{URI:X,_E:void 0,map:I,compact:e,separate:i,filter:(t,e)=>tV(t)||e(t.right)?t:r,filterMap:(t,e)=>{if(tV(t))return t;let i=e(t.right);return"None"===i._tag?r:T(i.value)},partition:(t,e)=>tV(t)?K(t,t):e(t.right)?K(r,T(t.right)):K(T(t.right),r),partitionMap:(t,e)=>{if(tV(t))return K(t,t);let i=e(t.right);return tV(i)?K(T(i.left),r):K(r,T(i.right))}}},ti=t=>{let r=te(t),e=tr(t);return{URI:X,_E:void 0,map:I,compact:r.compact,separate:r.separate,filter:r.filter,filterMap:r.filterMap,partition:r.partition,partitionMap:r.partitionMap,traverse:D,sequence:tO,reduce:P,foldMap:$,reduceRight:B,wither:L(tW,e),wilt:q(tW,e)}},ta=t=>({URI:X,_E:void 0,map:I,ap:(r,e)=>tV(r)?tV(e)?J(t.concat(r.left,e.left)):r:tV(e)?e:T(r.right(e.right)),of:tf}),tl=t=>({URI:X,_E:void 0,map:I,alt:(r,e)=>{if(tI(r))return r;let i=e();return tV(i)?J(t.concat(r.left,i.left)):i}}),to=t=>r=>tV(r)?r:T(t(r.right)),tp={URI:X,map:I},tn=g(2,E(tp)),th=_(tp),tf=T,ts={URI:X,of:tf},tm=t=>r=>tV(r)?r:tV(t)?t:T(r.right(t.right)),tg=tm,tc={URI:X,map:I,ap:U},tu={URI:X,map:I,ap:U,of:tf},td={URI:X,map:I,ap:U,chain:V},tE={URI:X,map:I,ap:U,of:tf,chain:V},t_=(t,r)=>e=>tV(e)?t:r(t,e.right),tv=t=>r=>e=>tV(e)?t.empty:r(e.right),ty=(t,r)=>e=>tV(e)?t:r(e.right,t),tb={URI:X,reduce:P,foldMap:$,reduceRight:B},tM=t=>r=>e=>tV(e)?t.of(J(e.left)):t.map(r(e.right),T),tO=t=>r=>tV(r)?t.of(J(r.left)):t.map(r.right,T),tW={URI:X,map:I,reduce:P,foldMap:$,reduceRight:B,traverse:D,sequence:tO},tS=(t,r)=>e=>tV(e)?J(t(e.left)):T(r(e.right)),tA=t=>r=>tV(r)?J(t(r.left)):r,tR={URI:X,bimap:k,mapLeft:z},tN=t=>r=>tV(r)?t():r,tw=tN,tF={URI:X,map:I,alt:G},tj=t=>r=>tV(r)?r:T(t(r)),tx={URI:X,map:I,extend:H},tC={URI:X,map:I,ap:U,chain:V,chainRec:Q},tK=J,tq={URI:X,map:I,ap:U,of:tf,chain:V,throwError:tK},tL={URI:X,fromEither:u},tJ=m(tL),tT=f(tL),tV=R,tI=w,tU=(t,r)=>e=>tV(e)?t(e.left):r(e.right),tP=tU,t$=tU,tB=t$,tD=t=>r=>tV(r)?t(r.left):r.right,tk=tD,tz=y(tp),tG=r(tc),tH=tG,tQ=i(tc),tX=tQ,tY=g(2,o(td)),tZ=V(u),t0=tZ,t2=tj(u),t1=s(tL),t3=n(tL,td),t4=t3,t5={fromEither:tL.fromEither},t6=j(t5),t7=x(t5),t8={flatMap:V},t9=W(t5,t8),rt=S(t5,t8),rr=h(tL,td),re=rr,ri=t=>tV(t)?T(t.left):J(t.right),ra=t=>r=>tV(r)?t(r.left):r,rl=ra,ro=t=>r=>null==r?J(t):T(r),rp=(t,r)=>{try{return T(t())}catch(t){return J(r(t))}},rn=(t,r)=>(...e)=>rp(()=>t(...e),r),rh=t=>{let r=ro(t);return t=>c(t,r)},rf=t=>{let r=rh(t);return t=>V(r(t))},rs=tP(u,u);function rm(t){try{return t instanceof Error?t:Error(String(t))}catch(t){return Error()}}function rg(t){return(r,e)=>{if(void 0===e){let e=rg(t);return t=>e(r,t)}return!tV(e)&&t.equals(r,e.right)}}let rc=t=>r=>!tV(r)&&t(r.right),ru=tf(O),rd=v(tp),rE=b(tp),r_=l(td),rv=r_,ry=e(tc),rb=ry,rM=tf(M),rO=t=>r=>{let e=t(0,A(r));if(tV(e))return e;let i=[e.right];for(let e=1;e<r.length;e++){let a=t(e,r[e]);if(tV(a))return a;i.push(a.right)}return T(i)},rW=t=>{let r=rO(t);return t=>N(t)?r(t):rM},rS=rW,rA=t=>rW((r,e)=>t(e)),rR=rA(u),rN=V,rw=V,rF=tY,rj=tY;function rx(t,r){return rp(()=>JSON.parse(t),r)}let rC=(t,r)=>rp(()=>{let r=JSON.stringify(t);if("string"!=typeof r)throw Error("Converting unsupported structure to JSON");return r},r),rK={URI:X,map:I,of:tf,ap:U,chain:V,reduce:P,foldMap:$,reduceRight:B,traverse:D,sequence:tO,bimap:k,mapLeft:z,alt:G,extend:H,chainRec:Q,throwError:tK},rq=a(tc),rL=t(tu),rJ=(t,r)=>a(ta(t))(r),rT=(r,e)=>t(ta(r))(e);function rV(t){return{URI:X,_E:void 0,map:I,of:tf,chain:V,bimap:k,mapLeft:z,reduce:P,foldMap:$,reduceRight:B,extend:H,traverse:D,sequence:tO,chainRec:Q,throwError:tK,ap:ta(t).ap,alt:tl(t).alt}}export{tF as Alt,rM as ApT,tu as Applicative,tc as Apply,tR as Bifunctor,td as Chain,tC as ChainRec,ru as Do,tx as Extend,tb as Foldable,tL as FromEither,tp as Functor,tE as Monad,tq as MonadThrow,ts as Pointed,tW as Traversable,X as URI,tw as alt,tN as altW,tg as ap,tG as apFirst,tH as apFirstW,ry as apS,rb as apSW,tQ as apSecond,tX as apSecondW,tm as apW,tn as as,th as asUnit,tS as bimap,r_ as bind,rd as bindTo,rv as bindW,rw as chain,rF as chainFirst,rj as chainFirstW,rf as chainNullableK,t3 as chainOptionK,t4 as chainOptionKW,rN as chainW,t2 as duplicate,rK as either,rg as elem,rc as exists,tj as extend,rr as filterOrElse,re as filterOrElseW,tz as flap,V as flatMap,t9 as flatMapNullable,rt as flatMapOption,t0 as flatten,tZ as flattenW,tB as fold,tv as foldMap,tP as foldW,ro as fromNullable,rh as fromNullableK,tT as fromOption,t1 as fromOptionK,tJ as fromPredicate,tl as getAltValidation,ta as getApplicativeValidation,rL as getApplyMonoid,rq as getApplySemigroup,tr as getCompactable,Z as getEq,te as getFilterable,tk as getOrElse,tD as getOrElseW,tt as getSemigroup,Y as getShow,rV as getValidation,rT as getValidationMonoid,rJ as getValidationSemigroup,ti as getWitherable,tV as isLeft,tI as isRight,J as left,rE as let,t6 as liftNullable,t7 as liftOption,to as map,tA as mapLeft,t$ as match,tU as matchW,tf as of,rl as orElse,ra as orElseW,rx as parseJSON,t_ as reduce,ty as reduceRight,T as right,tO as sequence,rR as sequenceArray,rC as stringifyJSON,ri as swap,tY as tap,tK as throwError,rm as toError,rs as toUnion,tM as traverse,rA as traverseArray,rS as traverseArrayWithIndex,rW as traverseReadonlyArrayWithIndex,rO as traverseReadonlyNonEmptyArrayWithIndex,rp as tryCatch,rn as tryCatchK};