import{getApplicativeMonoid as a}from"./Applicative.mjs";import{apFirst as e,apS as r,apSecond as s,getApplySemigroup as o}from"./Apply.mjs";import{bind as t,tap as d}from"./Chain.mjs";import{fromIOK as p,tapIO as m}from"./FromIO.mjs";import{ask as n,asks as i,fromReaderK as R,tapReader as f}from"./FromReader.mjs";import{fromTaskK as k,tapTask as T}from"./FromTask.mjs";import{SK as l,dual as I,flow as c,identity as _,pipe as h}from"./function.mjs";import{as as y,asUnit as O,bindTo as W,flap as A,let as F}from"./Functor.mjs";import{emptyReadonlyArray as K,emptyRecord as S,flatMapIO as M,flatMapReader as v,flatMapTask as j,isNonEmpty as u}from"./internal.mjs";import{asksReaderW as q,local as x,map as b,of as E,traverseReadonlyNonEmptyArrayWithIndex as N}from"./Reader.mjs";import{ap as P,flatMap as g,fromReader as U,map as C,of as D}from"./ReaderT.mjs";import{ApplyPar as w,Functor as z,Monad as B,Pointed as G,fromIO as H,traverseReadonlyNonEmptyArrayWithIndex as J,traverseReadonlyNonEmptyArrayWithIndexSeq as L}from"./Task.mjs";let Q=U(G),V=E,X=c(H,V),Y=b(H),Z=x,$=q,aa=$,ae=(a,e)=>h(a,ao(e)),ar=(a,e)=>h(a,at(e)),as=(a,e)=>am(a,a=>h(e,ao(a))),ao=C(z),at=P(w),ad=at,ap=D(G),am=I(2,g(B)),an=am(_),ai=an,aR="ReaderTask",af={URI:aR,map:ae},ak=I(2,y(af)),aT=O(af),al=A(af),aI={URI:aR,of:ap},ac={URI:aR,map:ae,ap:ar},a_=e(ac),ah=a_,ay=s(ac),aO=ay,aW={URI:aR,map:ae,ap:ar,of:ap},aA={URI:aR,map:ae,ap:as},aF={URI:aR,map:ae,ap:as,of:ap},aK={URI:aR,map:ae,ap:ar,chain:am},aS={URI:aR,map:ae,of:ap,ap:ar,chain:am},aM={URI:aR,map:ae,of:ap,ap:ar,chain:am,fromIO:X},av={URI:aR,map:ae,of:ap,ap:ar,chain:am,fromIO:X,fromTask:V},aj={URI:aR,fromIO:X},au={URI:aR,fromIO:X,fromTask:V},aq={URI:aR,fromReader:Q},ax={flatMap:am},ab=M({fromIO:aj.fromIO},ax),aE=j({fromTask:V},ax),aN=v({fromReader:Q},ax),aP=I(2,(a,e)=>am(a,aZ(e))),ag=I(2,d(aK)),aU=I(2,m(aj,aK)),aC=I(2,f(aq,aK)),aD=I(2,T(au,aK)),aw=I(2,(a,e)=>ag(a,aZ(e))),az=p(aj),aB=ab,aG=aU,aH=n(aq),aJ=i(aq),aL=R(aq),aQ=aN,aV=aN,aX=aC,aY=aC,aZ=a=>(...e)=>Y(a(...e)),a$=aP,a2=aP,a0=aw,a1=aw,a3=k(au),a4=aE,a5=aD,a6=ap(S),a7=W(af),a8=F(af),a9=t(aK),ea=a9,ee=r(ac),er=ee,es=ap(K),eo=a=>c(N(a),b(J(l))),et=a=>{let e=eo(a);return a=>u(a)?e(a):es},ed=a=>c(N(a),b(L(l))),ep=a=>{let e=ed(a);return a=>u(a)?e(a):es},em=et,en=a=>et((e,r)=>a(r)),ei=en(_),eR=ep,ef=a=>ep((e,r)=>a(r)),ek=am,eT=am,el=ag,eI=ag,ec=ef(_),e_={URI:aR,map:ae,of:ap,ap:ar,chain:am,fromIO:X,fromTask:V},eh={URI:aR,map:ae,of:ap,ap:as,chain:am,fromIO:X,fromTask:V},ey=o(aA),eO=a(aF);function eW(a,e){return a(e)()}export{es as ApT,aW as ApplicativePar,aF as ApplicativeSeq,ac as ApplyPar,aA as ApplySeq,aK as Chain,a6 as Do,aj as FromIO,aq as FromReader,au as FromTask,af as Functor,aS as Monad,aM as MonadIO,av as MonadTask,aI as Pointed,aR as URI,at as ap,a_ as apFirst,ah as apFirstW,ee as apS,er as apSW,ay as apSecond,aO as apSecondW,ad as apW,ak as as,aT as asUnit,aH as ask,aJ as asks,aa as asksReaderTask,$ as asksReaderTaskW,a9 as bind,a7 as bindTo,ea as bindW,ek as chain,el as chainFirst,aG as chainFirstIOK,a1 as chainFirstReaderIOK,a0 as chainFirstReaderIOKW,aX as chainFirstReaderK,aY as chainFirstReaderKW,a5 as chainFirstTaskK,eI as chainFirstW,aB as chainIOK,a2 as chainReaderIOK,a$ as chainReaderIOKW,aQ as chainReaderK,aV as chainReaderKW,a4 as chainTaskK,eT as chainW,al as flap,am as flatMap,ab as flatMapIO,aN as flatMapReader,aP as flatMapReaderIO,aE as flatMapTask,ai as flatten,an as flattenW,X as fromIO,az as fromIOK,Q as fromReader,Y as fromReaderIO,aZ as fromReaderIOK,aL as fromReaderK,V as fromTask,a3 as fromTaskK,eO as getMonoid,ey as getSemigroup,a8 as let,Z as local,ao as map,ap as of,e_ as readerTask,eh as readerTaskSeq,eW as run,ei as sequenceArray,ec as sequenceSeqArray,ag as tap,aU as tapIO,aC as tapReader,aw as tapReaderIO,aD as tapTask,en as traverseArray,em as traverseArrayWithIndex,et as traverseReadonlyArrayWithIndex,ep as traverseReadonlyArrayWithIndexSeq,eo as traverseReadonlyNonEmptyArrayWithIndex,ed as traverseReadonlyNonEmptyArrayWithIndexSeq,ef as traverseSeqArray,eR as traverseSeqArrayWithIndex};