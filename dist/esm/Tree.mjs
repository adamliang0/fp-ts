import{apFirst as e,apS as r,apSecond as t}from"./Apply.mjs";import{getEq as a,getMonoid as o,isEmpty as n,traverse as l}from"./Array.mjs";import{bind as u,chainFirst as s}from"./Chain.mjs";import{fromEquals as f}from"./Eq.mjs";import{dual as p,identity as i,pipe as m}from"./function.mjs";import{bindTo as c,flap as d,let as v}from"./Functor.mjs";import{emptyRecord as h}from"./internal.mjs";function T(e,r=[]){return{value:e,forest:r}}function _(e){let r=t=>n(t.forest)?`make(${e.show(t.value)})`:`make(${e.show(t.value)}, [${t.forest.map(r).join(", ")}])`;return{show:r}}function g(e){let r,t=f((t,a)=>e.equals(t.value,a.value)&&r.equals(t.forest,a.forest));return r=a(t),t}let F=(e,r)=>{let t,a="",o=r.length;for(let n=0;n<o;n++){t=r[n];let l=n===o-1;a+=e+(l?"└":"├")+"─ "+t.value,a+=F(e+(o>1&&!l?"│  ":"   "),t.forest)}return a};function j(e){return F("\n",e)}function M(e){return e.value+j(e.forest)}function q(e,r){let[t,a]=r(e);return{value:t,forest:b(a,r)}}function b(e,r){return e.map(e=>q(e,r))}function x(e){let r=w(e);return(t,a)=>e.chain(a(t),([t,o])=>e.map(r(o,a),e=>({value:t,forest:e})))}function w(e){let r=l(e);return(t,a)=>m(t,r(r=>x(e)(r,a)))}function R(e){let r=t=>e(t.value,t.forest.map(r));return r}let S=(e,r)=>m(e,B(r)),y=(e,r)=>I(e,e=>m(r,B(e))),A=(e,r,t)=>m(e,G(r,t)),k=e=>{let r=H(e);return(e,t)=>m(e,r(t))},C=(e,r,t)=>m(e,J(r,t)),E=(e,r)=>m(e,P(r)),$=e=>{let r=L(e);return(e,t)=>m(e,r(t))},D=e=>r=>y(r,e),I=p(2,(e,r)=>{let{value:t,forest:a}=r(e.value);return{value:t,forest:(0,o().concat)(a,e.forest.map(I(r)))}}),P=e=>r=>({value:e(r),forest:r.forest.map(P(e))}),U=P(i),z=I(i),B=e=>r=>({value:e(r.value),forest:r.forest.map(B(e))}),G=(e,r)=>t=>{let a=r(e,t.value),o=t.forest.length;for(let e=0;e<o;e++)a=m(t.forest[e],G(a,r));return a},H=e=>r=>G(e.empty,(t,a)=>e.concat(t,r(a))),J=(e,r)=>t=>{let a=e,o=t.forest.length;for(let e=o-1;e>=0;e--)a=m(t.forest[e],J(a,r));return r(t.value,a)},K=e=>e.value,L=e=>{let r=l(e),t=a=>o=>e.ap(e.map(a(o.value),e=>r=>({value:e,forest:r})),m(o.forest,r(t(a))));return t},N=e=>L(e)(i),O=e=>T(e),Q="Tree",V={URI:Q,map:S},W=d(V),X={URI:Q,of:O},Y={URI:Q,map:S,ap:y},Z=e(Y),ee=t(Y),er={URI:Q,map:S,ap:y,of:O},et={URI:Q,map:S,ap:y,chain:I},ea={URI:Q,map:S,ap:y,of:O,chain:I},eo=s(et),en={URI:Q,reduce:A,foldMap:k,reduceRight:C},el={URI:Q,map:S,reduce:A,foldMap:k,reduceRight:C,traverse:$,sequence:N},eu={URI:Q,map:S,extend:E,extract:K},es=O(h),ef=c(V),ep=v(V),ei=u(et),em=r(Y);function ec(e){let r=(t,a)=>e.equals(t,a.value)||a.forest.some(e=>r(t,e));return r}let ed=e=>r=>e(r.value)||r.forest.some(ed(e)),ev=I,eh={URI:Q,map:S,of:O,ap:y,chain:I,reduce:A,foldMap:k,reduceRight:C,traverse:$,sequence:N,extract:K,extend:E};export{er as Applicative,Y as Apply,et as Chain,eu as Comonad,es as Do,en as Foldable,V as Functor,ea as Monad,X as Pointed,el as Traversable,Q as URI,D as ap,Z as apFirst,em as apS,ee as apSecond,ei as bind,ef as bindTo,ev as chain,eo as chainFirst,j as drawForest,M as drawTree,U as duplicate,ec as elem,ed as exists,P as extend,K as extract,W as flap,I as flatMap,z as flatten,R as fold,H as foldMap,g as getEq,_ as getShow,ep as let,T as make,B as map,O as of,G as reduce,J as reduceRight,N as sequence,L as traverse,eh as tree,b as unfoldForest,w as unfoldForestM,q as unfoldTree,x as unfoldTreeM};