import{getApplicativeMonoid as t}from"./Applicative.mjs";import{ap as a,apFirst as r,apS as e,apSecond as i,getApplySemigroup as p}from"./Apply.mjs";import{bind as o,tap as s}from"./Chain.mjs";import{compact as h,separate as l}from"./Compactable.mjs";import{Functor as n,getApplicativeValidation as m,getCompactable as E,getFilterable as O,getSemigroup as f,traverseReadonlyNonEmptyArrayWithIndex as I,tryCatch as c}from"./Either.mjs";import{alt as _,altValidation as d,ap as u,flatMap as y,getOrElse as W,left as g,leftF as A,map as F,mapBoth as b,mapError as M,match as v,matchE as K,orElse as S,orLeft as j,right as x,rightF as q,swap as C,tapError as N,toUnion as R}from"./EitherT.mjs";import{filter as L,filterMap as P,partition as T,partitionMap as U}from"./Filterable.mjs";import{chainOptionK as w,filterOrElse as B,fromEitherK as V,fromOption as k,fromOptionK as D,fromPredicate as z,tapEither as G}from"./FromEither.mjs";import{fromIOK as H,tapIO as J}from"./FromIO.mjs";import{SK as Q,dual as X,flow as Y,identity as Z,pipe as $}from"./function.mjs";import{as as tt,asUnit as ta,bindTo as tr,flap as te,let as ti}from"./Functor.mjs";import{emptyReadonlyArray as tp,emptyRecord as to,flatMapEither as ts,flatMapIO as th,flatMapNullable as tl,flatMapOption as tn,head as tm,isLeft as tE,isNonEmpty as tO,liftNullable as tf,liftOption as tI,right as tc}from"./internal.mjs";import{Apply as t_,Functor as td,Monad as tu,Pointed as ty,flatMap as tW,map as tg,of as tA,traverseReadonlyNonEmptyArrayWithIndex as tF}from"./IO.mjs";let tb=g(ty),tM=x(ty),tv=q(td),tK=A(td),tS=tA,tj=tv,tx=v(td),tq=tx,tC=K(tu),tN=tC,tR=tC,tL=tR,tP=W(tu),tT=tP,tU=(t,a)=>()=>c(t,a),tw=(t,a)=>(...r)=>tU(()=>t(...r),a),tB=R(td),tV=S(tu),tk=tV,tD=X(2,N(tu)),tz=t=>tD(aS(t)),tG=j(tu),tH=C(td),tJ=(t,a)=>$(t,tY(a)),tQ=(t,a)=>$(t,t1(a)),tX=(t,a)=>$(t,t8(a)),tY=F(td),tZ=X(3,b(td)),t$=tZ,t2=X(2,M(td)),t0=t2,t1=u(t_),t3=t1,t4=tM,t5=X(2,y(tu)),t6=t5(Z),t7=t6,t8=_(tu),t9=t8,at=tb,aa="IOEither";function ar(t){let r=a(t_,m(t));return{URI:aa,_E:void 0,map:tJ,ap:(t,a)=>$(t,r(a)),of:t4}}function ae(t){let a=d(tu,t);return{URI:aa,_E:void 0,map:tJ,alt:(t,r)=>$(t,a(r))}}let ai=t=>{let a=E(t);return{URI:aa,_E:void 0,compact:h(td,a),separate:l(td,a,n)}};function ap(t){let a=O(t),r=ai(t),e=L(td,a),i=P(td,a),p=T(td,a),o=U(td,a);return{URI:aa,_E:void 0,map:tJ,compact:r.compact,separate:r.separate,filter:(t,a)=>$(t,e(a)),filterMap:(t,a)=>$(t,i(a)),partition:(t,a)=>$(t,p(a)),partitionMap:(t,a)=>$(t,o(a))}}let ao={URI:aa,map:tJ},as=X(2,tt(ao)),ah=ta(ao),al=te(ao),an={URI:aa,of:t4},am={URI:aa,bimap:tZ,mapLeft:t2},aE={URI:aa,map:tJ,ap:tQ},aO=r(aE),af=aO,aI=i(aE),ac=aI,a_={URI:aa,map:tJ,ap:tQ,of:t4},ad={URI:aa,map:tJ,ap:(t,a)=>t5(t,t=>$(a,tY(t))),of:t4},au={URI:aa,map:tJ,ap:tQ,chain:t5},ay={URI:aa,map:tJ,ap:tQ,of:t4,chain:t5},aW={URI:aa,fromEither:tS},ag={URI:aa,fromIO:tj},aA=X(2,s(au)),aF=X(2,G(aW,au)),ab=X(2,J(ag,au)),aM={URI:aa,map:tJ,alt:tX},av={URI:aa,map:tJ,ap:tQ,of:t4,chain:t5,fromIO:tj},aK={URI:aa,map:tJ,ap:tQ,of:t4,chain:t5,throwError:at},aS=H(ag),aj=ab,ax=k(aW),aq=D(aW),aC=w(aW,au),aN=aC,aR={fromEither:aW.fromEither},aL=tf(aR),aP=tI(aR),aT={flatMap:t5},aU=tl(aR,aT),aw=tn(aR,aT),aB=ts(aR,aT),aV=th({fromIO:tj},aT),ak=aV,aD=aB,az=aB,aG=aF,aH=aF,aJ=z(aW),aQ=B(aW,au),aX=aQ,aY=V(aW),aZ=(t,a,r)=>a$(t,a,r),a$=(t,a,r)=>t5(t,t=>tW(a(t),a=>t5(r(t,a),()=>tA(a)))),a2=t4(to),a0=tr(ao),a1=ti(ao),a3=o(au),a4=a3,a5=e(aE),a6=a5,a7=t4(tp),a8=t=>Y(tF(t),tg(I(Q))),a9=t=>{let a=a8(t);return t=>tO(t)?a(t):a7},rt=t=>a=>()=>{let r=t(0,tm(a))();if(tE(r))return r;let e=[r.right];for(let r=1;r<a.length;r++){let i=t(r,a[r])();if(tE(i))return i;e.push(i.right)}return tc(e)},ra=t=>{let a=rt(t);return t=>tO(t)?a(t):a7},rr=a9,re=t=>a9((a,r)=>t(r)),ri=re(Z),rp=ra,ro=t=>ra((a,r)=>t(r)),rs=ro(Z),rh=a_,rl=t5,rn=t5,rm=aA,rE=aA,rO=tD,rf=tD,rI={URI:aa,bimap:tZ,mapLeft:t2,map:tJ,of:t4,ap:tQ,chain:t5,alt:tX,fromIO:tj,throwError:at},rc=p(aE),r_=t(a_),rd=t=>p(t_)(f(t));function ru(t){let a=ar(t),r=ae(t);return{URI:aa,_E:void 0,map:tJ,ap:a.ap,of:t4,chain:t5,bimap:tZ,mapLeft:t2,alt:r.alt,fromIO:tj,throwError:at}}export{aM as Alt,a7 as ApT,rh as Applicative,a_ as ApplicativePar,ad as ApplicativeSeq,aE as ApplyPar,am as Bifunctor,au as Chain,a2 as Do,aW as FromEither,ag as FromIO,ao as Functor,ay as Monad,av as MonadIO,aK as MonadThrow,an as Pointed,aa as URI,t8 as alt,t9 as altW,t1 as ap,aO as apFirst,af as apFirstW,a5 as apS,a6 as apSW,aI as apSecond,ac as apSecondW,t3 as apW,as as as,ah as asUnit,t$ as bimap,a3 as bind,a0 as bindTo,a4 as bindW,aZ as bracket,a$ as bracketW,rl as chain,aD as chainEitherK,az as chainEitherKW,rm as chainFirst,aG as chainFirstEitherK,aH as chainFirstEitherKW,aj as chainFirstIOK,rE as chainFirstW,ak as chainIOK,aC as chainOptionK,aN as chainOptionKW,rn as chainW,aQ as filterOrElse,aX as filterOrElseW,al as flap,t5 as flatMap,aB as flatMapEither,aV as flatMapIO,aU as flatMapNullable,aw as flatMapOption,t7 as flatten,t6 as flattenW,tN as fold,tL as foldW,tS as fromEither,aY as fromEitherK,tj as fromIO,aS as fromIOK,ax as fromOption,aq as fromOptionK,aJ as fromPredicate,ae as getAltIOValidation,ar as getApplicativeIOValidation,r_ as getApplyMonoid,rc as getApplySemigroup,ai as getCompactable,ap as getFilterable,ru as getIOValidation,tP as getOrElse,tT as getOrElseW,rd as getSemigroup,rI as ioEither,tb as left,tK as leftIO,a1 as let,aL as liftNullable,aP as liftOption,tY as map,tZ as mapBoth,t2 as mapError,t0 as mapLeft,tx as match,tC as matchE,tR as matchEW,tq as matchW,t4 as of,tV as orElse,rO as orElseFirst,tz as orElseFirstIOK,rf as orElseFirstW,tk as orElseW,tG as orLeft,tM as right,tv as rightIO,ri as sequenceArray,rs as sequenceSeqArray,tH as swap,aA as tap,aF as tapEither,tD as tapError,ab as tapIO,at as throwError,tB as toUnion,re as traverseArray,rr as traverseArrayWithIndex,a9 as traverseReadonlyArrayWithIndex,ra as traverseReadonlyArrayWithIndexSeq,a8 as traverseReadonlyNonEmptyArrayWithIndex,rt as traverseReadonlyNonEmptyArrayWithIndexSeq,ro as traverseSeqArray,rp as traverseSeqArrayWithIndex,tU as tryCatch,tw as tryCatchK};