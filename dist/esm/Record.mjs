import{Foldable as e}from"./Array.mjs";import{pipe as t}from"./function.mjs";import{flap as r}from"./Functor.mjs";import{has as n,isNone as a,none as i,some as o}from"./internal.mjs";import{_filter as c,_filterMap as d,_filterMapWithIndex as p,_filterWithIndex as l,_foldMap as s,_foldMapWithIndex as u,_map as f,_mapWithIndex as h,_partition as m,_partitionMap as R,_partitionMapWithIndex as W,_partitionWithIndex as I,_reduce as x,_reduceRight as g,_reduceRightWithIndex as _,_reduceWithIndex as M,_sequence as b,_traverse as v,compact as y,difference as w,elem as j,every as F,filter as O,filterMap as q,filterMapWithIndex as S,filterWithIndex as A,foldMap as E,foldMapWithIndex as P,fromFoldable as k,fromFoldableMap as T,getEq as U,getMonoid as z,getShow as D,has as C,hasOwnProperty as B,intersection as G,isEmpty as H,isSubrecord as J,lookup as K,map as L,mapWithIndex as N,partition as Q,partitionMap as V,partitionMapWithIndex as X,partitionWithIndex as Y,reduce as Z,reduceRight as $,reduceRightWithIndex as ee,reduceWithIndex as et,separate as er,sequence as en,singleton as ea,size as ei,some as eo,traverse as ec,traverseWithIndex as ed,union as ep,upsertAt as el}from"./ReadonlyRecord.mjs";import{last as es}from"./Semigroup.mjs";import{Ord as eu}from"./string.mjs";import{wiltDefault as ef,witherDefault as eh}from"./Witherable.mjs";function em(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),n.forEach(function(t){var n;n=r[t],t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n})}return e}let eR=ei,eW=H,eI=e=>t=>Object.keys(t).sort(e.compare),ex=eI(eu);function eg(e){if("function"==typeof e)return eg(eu)(e);let t=eI(e);return e=>r=>{let n=[];for(let a of t(r))n.push(e(a,r[a]));return n}}let e_=eg(eu)((e,t)=>[e,t]);function eM(e){return t=>{let r=e_(t),n=r.length;return e.unfold(0,e=>e<n?o([r[e],e+1]):i)}}let eb=el,ev=C;function ey(e){return t=>{if(!n.call(t,e))return t;let r=Object.assign({},t);return delete r[e],r}}let ew=(e,t)=>ej(e,()=>t),ej=(e,t)=>r=>{if(!ev(e,r))return i;let n=Object.assign({},r);return n[e]=t(r[e]),o(n)};function eF(e){let t=ey(e);return r=>{let n=eq(e,r);return a(n)?i:o([n.value,t(r)])}}let eO=J,eq=K,eS=N,eA=L;function eE(...e){return 1===e.length?et(e[0]):et(eu)(...e)}function eP(e){return"compare"in e?P(e):P(eu)(e)}function ek(...e){return 1===e.length?ee(e[0]):ee(eu)(...e)}let eT=ea;function eU(e){return ed(e)}function ez(e){return ec(e)}function eD(e){return en(e)}let eC=e=>{let r=ez(e);return n=>a=>e.map(t(a,r(n)),te)},eB=e=>{let r=ez(e);return n=>a=>e.map(t(a,r(n)),tt)},eG=X;function eH(e){return Y(e)}let eJ=S;function eK(e){return A(e)}function eL(e,t){return k(e,t)}let eN=e_,eQ=t=>eL(es(),e)(t);function eV(e,t){return T(e,t)}let eX=F,eY=eo,eZ=j,e$=e=>{let t=ep(e);return e=>r=>eW(r)?em({},e):eW(e)?em({},r):t(e)(r)},e0=e=>t=>r=>eW(r)||eW(t)?{}:G(e)(t)(r),e1=e=>t=>eW(t)?em({},e):eW(e)?em({},t):w(e)(t),e2=e=>t=>{let r=eI(e);return(e,n)=>{let a=r(e);if(0===a.length)return t.of({});let i=t.of({});for(let r of a)i=t.ap(t.map(i,e=>t=>(e[r]=t,e)),n(r,e[r]));return i}},e3=O,e4=q,e5=Q,e6=V;function e7(...e){return 1===e.length?Z(e[0]):Z(eu)(...e)}function e8(e){return"compare"in e?E(e):E(eu)(e)}function e9(...e){return 1===e.length?$(e[0]):$(eu)(...e)}let te=y,tt=er,tr="Record";function tn(e){return"compare"in e?D(e):D(eu)(e)}let ta=U,ti=z,to={URI:tr,map:f},tc=r(to),td={URI:tr,map:f,mapWithIndex:h},tp=e=>({URI:tr,reduce:x(e),foldMap:s(e),reduceRight:g(e)}),tl=e=>({URI:tr,reduce:x(e),foldMap:s(e),reduceRight:g(e),reduceWithIndex:M(e),foldMapWithIndex:u(e),reduceRightWithIndex:_(e)}),ts={URI:tr,compact:te,separate:tt},tu={URI:tr,map:f,compact:te,separate:tt,filter:c,filterMap:d,partition:m,partitionMap:R},tf={URI:tr,map:f,mapWithIndex:h,compact:te,separate:tt,filter:c,filterMap:d,partition:m,partitionMap:R,filterMapWithIndex:p,filterWithIndex:l,partitionMapWithIndex:W,partitionWithIndex:I},th=e=>({URI:tr,map:f,reduce:x(e),foldMap:s(e),reduceRight:g(e),traverse:v(e),sequence:b(e)}),tm=e=>({URI:tr,map:f,mapWithIndex:h,reduce:x(e),foldMap:s(e),reduceRight:g(e),reduceWithIndex:M(e),foldMapWithIndex:u(e),reduceRightWithIndex:_(e),traverse:v(e),sequence:b(e),traverseWithIndex:e2(e)}),tR=e=>{let t=th(e);return{URI:tr,map:f,reduce:x(e),foldMap:s(e),reduceRight:g(e),traverse:t.traverse,sequence:t.sequence,compact:te,separate:tt,filter:c,filterMap:d,partition:m,partitionMap:R,wither:eh(t,ts),wilt:ef(t,ts)}},tW=e=>{let t=e$(e);return{concat:(e,r)=>t(r)(e)}},tI=e=>({concat:tW(e).concat,empty:{}}),tx=e=>{let t=e0(e);return{concat:(e,r)=>t(r)(e)}},tg=()=>({concat:(e,t)=>e1(t)(e)}),t_={URI:tr,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu)},tM={URI:tr,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu),reduceWithIndex:M(eu),foldMapWithIndex:u(eu),reduceRightWithIndex:_(eu)},tb={URI:tr,map:f,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu),traverse:v(eu),sequence:eD},tv={URI:tr,map:f,mapWithIndex:h,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu),reduceWithIndex:M(eu),foldMapWithIndex:u(eu),reduceRightWithIndex:_(eu),traverse:v(eu),sequence:eD,traverseWithIndex:e2(eu)},ty=eh(tb,ts),tw=ef(tb,ts),tj={URI:tr,map:f,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu),traverse:v(eu),sequence:eD,compact:te,separate:tt,filter:c,filterMap:d,partition:m,partitionMap:R,wither:ty,wilt:tw},tF={},tO=eb,tq=B,tS={URI:tr,map:f,reduce:x(eu),foldMap:s(eu),reduceRight:g(eu),traverse:v(eu),sequence:eD,compact:te,separate:tt,filter:c,filterMap:d,partition:m,partitionMap:R,mapWithIndex:h,reduceWithIndex:M(eu),foldMapWithIndex:u(eu),reduceRightWithIndex:_(eu),filterMapWithIndex:p,filterWithIndex:l,partitionMapWithIndex:W,partitionWithIndex:I,traverseWithIndex:e2(eu),wither:ty,wilt:tw};export{ts as Compactable,tu as Filterable,tf as FilterableWithIndex,t_ as Foldable,tM as FoldableWithIndex,to as Functor,td as FunctorWithIndex,tb as Traversable,tv as TraversableWithIndex,tr as URI,tj as Witherable,eg as collect,te as compact,ey as deleteAt,e1 as difference,eZ as elem,tF as empty,eX as every,e3 as filter,e4 as filterMap,eJ as filterMapWithIndex,eK as filterWithIndex,tc as flap,e8 as foldMap,eP as foldMapWithIndex,eQ as fromEntries,eL as fromFoldable,eV as fromFoldableMap,tg as getDifferenceMagma,ta as getEq,tp as getFoldable,tl as getFoldableWithIndex,tx as getIntersectionSemigroup,ti as getMonoid,tn as getShow,th as getTraversable,tm as getTraversableWithIndex,tI as getUnionMonoid,tW as getUnionSemigroup,tR as getWitherable,ev as has,tq as hasOwnProperty,tO as insertAt,e0 as intersection,eW as isEmpty,eO as isSubrecord,ex as keys,eq as lookup,eA as map,eS as mapWithIndex,ej as modifyAt,e5 as partition,e6 as partitionMap,eG as partitionMapWithIndex,eH as partitionWithIndex,eF as pop,tS as record,e7 as reduce,e9 as reduceRight,ek as reduceRightWithIndex,eE as reduceWithIndex,tt as separate,eD as sequence,eT as singleton,eR as size,eY as some,e_ as toArray,eN as toEntries,eM as toUnfoldable,ez as traverse,eU as traverseWithIndex,e$ as union,ew as updateAt,eb as upsertAt,eB as wilt,eC as wither};