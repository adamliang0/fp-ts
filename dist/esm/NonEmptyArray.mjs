import{apFirst as e,apS as t,apSecond as r}from"./Apply.mjs";import{bind as n,chainFirst as a}from"./Chain.mjs";import{dual as o,identity as p,pipe as l}from"./function.mjs";import{bindTo as i,flap as u,let as d}from"./Functor.mjs";import{emptyRecord as c,fromReadonlyNonEmptyArray as s,has as h,none as m,some as y}from"./internal.mjs";import{getMonoid as f}from"./Ord.mjs";import{concatAll as A,foldMap as g,foldMapWithIndex as x,getEq as E,getShow as W,head as I,intercalate as N,last as _,max as M,min as R,reduce as v,reduceRight as b,reduceRightWithIndex as F,reduceWithIndex as S}from"./ReadonlyNonEmptyArray.mjs";let j=e=>e.length>0,q=(e,t)=>e<0||e>=t.length,T=e=>t=>[e,...t],B=T,O=e=>t=>[...t,e],z=O,C=(e,t,r)=>{if(j(r)){let n=D(r);return n.splice(e,0,t),n}return[t]},L=(e,t,r)=>{let n=D(r);return n[e]=t,n},U=e=>t=>{if(1===t.length)return eo(t);let r=[tc(t)];for(let n of ts(t))r.every(t=>!e.equals(t,n))&&r.push(n);return r},k=e=>{if(j(e)){let t=f();return et(e.reduce(t.concat,t.empty))}return eo},w=e=>{let t=U(e);return e=>r=>t(l(r,Y(e)))},H=e=>t=>{let r=t.length,n=Math.round(e)%r;if(q(Math.abs(n),t)||0===n)return eo(t);if(!(n<0))return H(n-r)(t);{let[e,r]=ef(-n)(t);return l(r,Y(e))}},D=s,P=e=>j(e)?y(e):m,G=e=>t=>{let r=Math.max(0,Math.floor(t)),n=[e(0)];for(let t=1;t<r;t++)n.push(e(t));return n},J=e=>G(()=>e),K=(e,t)=>e<=t?G(t=>e+t)(t-e+1):[e],Q=e=>[tc(e),ts(e)],V=e=>[tm(e),th(e)];function X(e){return t=>t.concat(e)}function Y(e,t){return t?e.concat(t):t=>t.concat(e)}let Z=e=>[th(e),...e.slice(0,-1).reverse()];function $(e){return t=>{let r=t.length;if(0===r)return[];let n=[],a=t[0],o=[a];for(let p=1;p<r;p++){let r=t[p];e.equals(r,a)?o.push(r):(n.push(o),o=[a=r])}return n.push(o),n}}let ee=e=>t=>{let r={};for(let n of t){let t=e(n);h.call(r,t)?r[t].push(n):r[t]=[n]}return r},et=e=>t=>t.slice().sort(e.compare),er=(e,t)=>r=>e<0||e>r.length?m:y(C(e,t,r)),en=(e,t)=>ea(e,()=>t),ea=(e,t)=>r=>q(e,r)?m:y(L(e,t(r[e]),r)),eo=D,ep=e=>[e],el=(e,t,r)=>{let n=[r(e[0],t[0])],a=Math.min(e.length,t.length);for(let o=1;o<a;o++)n[o]=r(e[o],t[o]);return n};function ei(e,t){return void 0===t?t=>ei(t,e):el(e,t,(e,t)=>[e,t])}let eu=e=>{let t=[e[0][0]],r=[e[0][1]];for(let n=1;n<e.length;n++)t[n]=e[n][0],r[n]=e[n][1];return[t,r]},ed=e=>t=>{let r=[e,t[0]];for(let n=1;n<t.length;n++)r.push(e,t[n]);return r},ec=e=>t=>{let r=ts(t);return j(r)?l(r,ed(e),B(tc(t))):eo(t)},es=x,eh=g,em=e=>t=>{let r=D(e(0,tc(t)));for(let n=1;n<t.length;n++){let a=e(n,t[n]);for(let e=0;e<a.length;e++)r.push(a[e])}return r},ey=e=>t=>{let[r,n]=e(t),a=[r],o=n;for(;j(o);){let[t,r]=e(o);a.push(t),o=r}return a},ef=e=>t=>{let r=Math.max(1,e);return r>=t.length?[eo(t),[]]:[l(t.slice(1,r),B(tc(t))),t.slice(r)]},eA=e=>ey(ef(e)),eg=(e,t)=>l(e,eL(t)),ex=(e,t)=>l(e,eU(t)),eE=(e,t)=>l(e,eT(t)),eW=(e,t)=>l(e,eO(t)),eI=(e,t,r)=>l(e,ek(t,r)),eN=e=>{let t=eh(e);return(e,r)=>l(e,t(r))},e_=(e,t,r)=>l(e,eH(t,r)),eM=e=>{let t=eP(e);return(e,r)=>l(e,t(r))},eR=(e,t)=>l(e,eq(t)),ev=(e,t,r)=>l(e,ew(t,r)),eb=e=>{let t=es(e);return(e,r)=>l(e,t(r))},eF=(e,t,r)=>l(e,eD(t,r)),eS=e=>{let t=eJ(e);return(e,r)=>l(e,t(r))},ej=e=>t=>l(t,X(e())),eq=ej,eT=e=>eB(t=>l(e,eL(t))),eB=o(2,(e,t)=>l(e,em((e,r)=>t(r,e)))),eO=e=>t=>{let r=ts(t),n=[e(t)];for(;j(r);)n.push(e(r)),r=ts(r);return n},ez=eO(p),eC=eB(p),eL=e=>eU((t,r)=>e(r)),eU=e=>t=>{let r=[e(0,tc(t))];for(let n=1;n<t.length;n++)r.push(e(n,t[n]));return r},ek=v,ew=S,eH=b,eD=F,eP=e=>{let t=eJ(e);return e=>t((t,r)=>e(r))},eG=e=>eJ(e)((e,t)=>t),eJ=e=>t=>r=>{let n=e.map(t(0,tc(r)),ep);for(let a=1;a<r.length;a++)n=e.ap(e.map(n,e=>t=>l(e,z(t))),t(a,r[a]));return n},eK=I,eQ="NonEmptyArray",eV=W,eX=()=>({concat:Y}),eY=E,eZ=e=>{let t=w(e);return{concat:(e,r)=>t(r)(e)}},e$={URI:eQ,map:eg},e0=u(e$),e1={URI:eQ,of:ep},e2={URI:eQ,map:eg,mapWithIndex:ex},e3={URI:eQ,map:eg,ap:eE},e4=e(e3),e5=r(e3),e6={URI:eQ,map:eg,ap:eE,of:ep},e7={URI:eQ,map:eg,ap:eE,chain:eB},e8=a(e7),e9={URI:eQ,map:eg,ap:eE,of:ep,chain:eB},te={URI:eQ,reduce:eI,foldMap:eN,reduceRight:e_},tt={URI:eQ,reduce:eI,foldMap:eN,reduceRight:e_,reduceWithIndex:ev,foldMapWithIndex:eb,reduceRightWithIndex:eF},tr={URI:eQ,map:eg,reduce:eI,foldMap:eN,reduceRight:e_,traverse:eM,sequence:eG},tn={URI:eQ,map:eg,mapWithIndex:ex,reduce:eI,foldMap:eN,reduceRight:e_,traverse:eM,sequence:eG,reduceWithIndex:ev,foldMapWithIndex:eb,reduceRightWithIndex:eF,traverseWithIndex:eS},ta={URI:eQ,map:eg,alt:eR},to={URI:eQ,map:eg,extend:eW,extract:eK},tp=ep(c),tl=i(e$),ti=d(e$),tu=n(e7),td=t(e3),tc=I,ts=e=>e.slice(1),th=_,tm=e=>e.slice(0,-1),ty=R,tf=M,tA=e=>t=>t.reduce(e.concat),tg=e=>t=>e(tc(t),ts(t)),tx=e=>t=>e(tm(t),th(t)),tE=e=>t=>[e(tc(t)),...ts(t)],tW=e=>tE(()=>e),tI=e=>t=>l(tm(t),z(e(th(t)))),tN=e=>tI(()=>e),t_=N,tM=eB;function tR(e){let t=et(e),r=$(e);return e=>j(e)?r(t(e)):[]}function tv(e){return tb((t,r)=>e(r))}let tb=e=>t=>P(t.filter((t,r)=>e(r,t))),tF=Q,tS=V;function tj(e,t){return void 0===t?B(e):l(t,B(e))}let tq=(e,t)=>l(e,z(t)),tT=ed,tB=A,tO={URI:eQ,of:ep,map:eg,mapWithIndex:ex,ap:eE,chain:eB,extend:eW,extract:eK,reduce:eI,foldMap:eN,reduceRight:e_,traverse:eM,sequence:eG,reduceWithIndex:ev,foldMapWithIndex:eb,reduceRightWithIndex:eF,traverseWithIndex:eS,alt:eR};export{ta as Alt,e6 as Applicative,e3 as Apply,e7 as Chain,to as Comonad,tp as Do,te as Foldable,tt as FoldableWithIndex,e$ as Functor,e2 as FunctorWithIndex,e9 as Monad,e1 as Pointed,tr as Traversable,tn as TraversableWithIndex,eQ as URI,eq as alt,ej as altW,eT as ap,e4 as apFirst,td as apS,e5 as apSecond,z as append,O as appendW,tu as bind,tl as bindTo,tM as chain,e8 as chainFirst,em as chainWithIndex,ey as chop,eA as chunksOf,Y as concat,tA as concatAll,X as concatW,tj as cons,eo as copy,ez as duplicate,eO as extend,eK as extract,tv as filter,tb as filterWithIndex,e0 as flap,eB as flatMap,eC as flatten,tB as fold,eh as foldMap,es as foldMapWithIndex,P as fromArray,D as fromReadonlyNonEmptyArray,eY as getEq,eX as getSemigroup,eV as getShow,eZ as getUnionSemigroup,$ as group,ee as groupBy,tR as groupSort,tc as head,tm as init,er as insertAt,t_ as intercalate,ec as intersperse,j as isNonEmpty,q as isOutOfBound,th as last,ti as let,G as makeBy,eL as map,eU as mapWithIndex,tg as matchLeft,tx as matchRight,tf as max,ty as min,ea as modifyAt,tE as modifyHead,tI as modifyLast,tO as nonEmptyArray,ep as of,B as prepend,ed as prependAll,tT as prependToAll,T as prependW,K as range,ek as reduce,eH as reduceRight,eD as reduceRightWithIndex,ew as reduceWithIndex,J as replicate,Z as reverse,H as rotate,eG as sequence,tq as snoc,et as sort,k as sortBy,ef as splitAt,ts as tail,eP as traverse,eJ as traverseWithIndex,V as unappend,tF as uncons,w as union,U as uniq,Q as unprepend,C as unsafeInsertAt,L as unsafeUpdateAt,tS as unsnoc,eu as unzip,en as updateAt,tW as updateHead,tN as updateLast,ei as zip,el as zipWith};