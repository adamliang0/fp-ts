import{identity as t,pipe as a,unsafeCoerce as e}from"./function.mjs";import{flap as o}from"./Functor.mjs";let n=e;function p(t){return{show:a=>`make(${t.show(a)})`}}let m=t,r=t,i=t,g=t,c=t,f=t,u=t,l=t,s=t;function d(t){return{URI:E,_E:void 0,map:A,ap:(a,e)=>n(t.concat(a,e))}}function b(t){let a=d(t);return{URI:E,_E:void 0,map:a.map,ap:a.ap,of:()=>n(t.empty)}}let v=(t,e)=>a(t,w(e)),A=(t,e)=>a(t,y(e)),_=(t,e,o)=>a(t,B(e,o)),h=(t,e)=>a(t,C(e)),w=()=>e,y=()=>e,B=t=>a=>n(t(a)),C=t=>a=>n(t(a)),E="Const",L={URI:E,map:A},S=o(L),j={URI:E,contramap:v},k={URI:E,bimap:_,mapLeft:h},F={URI:E,map:A,contramap:v,bimap:_,mapLeft:h};export{k as Bifunctor,j as Contravariant,L as Functor,E as URI,B as bimap,F as const_,w as contramap,S as flap,b as getApplicative,d as getApply,s as getBooleanAlgebra,i as getBounded,m as getEq,l as getHeytingAlgebra,c as getMonoid,r as getOrd,u as getRing,g as getSemigroup,f as getSemiring,p as getShow,n as make,y as map,C as mapLeft};