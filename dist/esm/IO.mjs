import{getApplicativeMonoid as a}from"./Applicative.mjs";import{apFirst as r,apS as t,apSecond as p,getApplySemigroup as e}from"./Apply.mjs";import{bind as n,tap as i}from"./Chain.mjs";import{constant as o,dual as m,identity as s}from"./function.mjs";import{as as l,asUnit as c,bindTo as f,flap as h,let as I}from"./Functor.mjs";import{emptyReadonlyArray as d,emptyRecord as O,head as _,isNonEmpty as y}from"./internal.mjs";let A=(a,r)=>()=>r(a()),u=(a,r)=>()=>a()(r()),g=(a,r)=>()=>{let t=r(a)();for(;"Left"===t._tag;)t=r(t.left)();return t.right},j=a=>r=>A(r,a),v=a=>r=>u(r,a),F=o,R=m(2,(a,r)=>()=>r(a())()),S=R(s),b="IO",x={URI:b,map:A},M=m(2,l(x)),C=c(x),T=h(x),U={URI:b,of:F},W={URI:b,map:A,ap:u},q=r(W),D=p(W),E={URI:b,map:A,ap:u,of:F},L={URI:b,map:A,ap:u,chain:R},N={URI:b,map:A,ap:u,of:F,chain:R},P=m(2,i(L)),k=s,w={URI:b,map:A,ap:u,of:F,chain:R,fromIO:k},z={URI:b,map:A,ap:u,chain:R,chainRec:g},B={URI:b,fromIO:s},G=F(O),H=f(x),J=I(x),K=n(L),Q=t(W),V=F(d),X=a=>r=>()=>{let t=[a(0,_(r))()];for(let p=1;p<r.length;p++)t.push(a(p,r[p])());return t},Y=a=>{let r=X(a);return a=>y(a)?r(a):V},Z=Y,$=a=>Y((r,t)=>a(t)),aa=$(s),ar=R,at=P,ap={URI:b,map:A,of:F,ap:u,chain:R,fromIO:k,chainRec:g},ae=e(W),an=a(E);export{V as ApT,E as Applicative,W as Apply,L as Chain,z as ChainRec,G as Do,B as FromIO,x as Functor,N as Monad,w as MonadIO,U as Pointed,b as URI,v as ap,q as apFirst,Q as apS,D as apSecond,M as as,C as asUnit,K as bind,H as bindTo,ar as chain,at as chainFirst,T as flap,R as flatMap,S as flatten,k as fromIO,an as getMonoid,ae as getSemigroup,ap as io,J as let,j as map,F as of,aa as sequenceArray,P as tap,$ as traverseArray,Z as traverseArrayWithIndex,Y as traverseReadonlyArrayWithIndex,X as traverseReadonlyNonEmptyArrayWithIndex};