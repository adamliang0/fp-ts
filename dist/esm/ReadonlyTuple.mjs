import{identity as e,pipe as t}from"./function.mjs";import{flap as a}from"./Functor.mjs";function n(e){return e[0]}function p(e){return e[1]}let r=e=>[p(e),n(e)];function o(e){return{URI:w,_E:void 0,map:f,ap:(t,a)=>[n(t)(n(a)),e.concat(p(t),p(a))]}}let c=e=>t=>[t,e.empty];function i(e){return{URI:w,_E:void 0,map:f,ap:o(e).ap,of:c(e)}}function u(e){return{URI:w,_E:void 0,map:f,ap:o(e).ap,chain:(t,a)=>{let[r,o]=a(n(t));return[r,e.concat(p(t),o)]}}}function m(e){let t=u(e);return{URI:w,_E:void 0,map:f,ap:t.ap,chain:t.chain,of:c(e)}}function d(e){let t=u(e);return{URI:w,_E:void 0,map:f,ap:t.ap,chain:t.chain,chainRec:(t,a)=>{let r=a(t),o=e.empty,c=n(r);for(;"Left"===c._tag;)o=e.concat(o,p(r)),c=n(r=a(c.left));return[c.right,e.concat(o,p(r))]}}}let l=(e,a)=>t(e,M(a)),f=(e,a)=>t(e,x(a)),s=(e,a,n)=>t(e,b(a,n)),h=(e,a)=>t(e,E(a)),g=(e,a)=>t(e,F(a)),v=(e,a,n)=>t(e,C(a,n)),R=e=>{let a=j(e);return(e,n)=>t(e,a(n))},_=(e,a,n)=>t(e,A(a,n)),y=e=>{let a=S(e);return(e,n)=>t(e,a(n))},b=(e,t)=>a=>[t(n(a)),e(p(a))],x=e=>t=>[e(n(t)),p(t)],E=e=>t=>[n(t),e(p(t))],M=e=>t=>[n(t),p(e)],F=e=>t=>[e(t),p(t)],L=n,T=F(e),C=(e,t)=>a=>t(e,n(a)),j=()=>e=>t=>e(n(t)),A=(e,t)=>a=>t(n(a),e),S=e=>t=>a=>e.map(t(n(a)),e=>[e,p(a)]),q=e=>t=>e.map(n(t),e=>[e,p(t)]),w="ReadonlyTuple",B={URI:w,map:f},I=a(B),U=x,k=E,z={URI:w,bimap:s,mapLeft:h},D={URI:w,compose:l},G={URI:w,map:f,extend:g,extract:L},H={URI:w,reduce:v,foldMap:R,reduceRight:_},J={URI:w,map:f,reduce:v,foldMap:R,reduceRight:_,traverse:y,sequence:q},K={URI:w,compose:l,map:f,bimap:s,mapLeft:h,extract:L,extend:g,reduce:v,foldMap:R,reduceRight:_,traverse:y,sequence:q};export{z as Bifunctor,G as Comonad,H as Foldable,B as Functor,D as Semigroupoid,J as Traversable,w as URI,b as bimap,M as compose,T as duplicate,F as extend,L as extract,I as flap,j as foldMap,n as fst,i as getApplicative,o as getApply,u as getChain,d as getChainRec,m as getMonad,U as map,x as mapFst,k as mapLeft,E as mapSnd,K as readonlyTuple,C as reduce,A as reduceRight,q as sequence,p as snd,r as swap,S as traverse};