import{getApplicativeMonoid as e}from"./Applicative.mjs";import{apFirst as a,apS as r,apSecond as s,getApplySemigroup as t}from"./Apply.mjs";import{bind as o,tap as n}from"./Chain.mjs";import{fromIOK as i,tapIO as m}from"./FromIO.mjs";import{dual as p,identity as l,pipe as h}from"./function.mjs";import{as as c,asUnit as d,bindTo as v,flap as f,let as y}from"./Functor.mjs";import{emptyReadonlyArray as I,emptyRecord as P,flatMapIO as T,head as k,isNonEmpty as A,singleton as u,tail as O}from"./internal.mjs";let S=e=>()=>Promise.resolve().then(e);function _(e){return a=>()=>new Promise(r=>{setTimeout(()=>{Promise.resolve().then(a).then(r)},e)})}let q=(e,a)=>h(e,j(a)),F=(e,a)=>h(e,x(a)),M=(e,a)=>W(e,e=>h(a,j(e))),j=e=>a=>()=>Promise.resolve().then(a).then(e),x=e=>a=>()=>Promise.all([Promise.resolve().then(a),Promise.resolve().then(e)]).then(([e,a])=>e(a)),R=e=>()=>Promise.resolve(e),W=p(2,(e,a)=>()=>Promise.resolve().then(e).then(e=>a(e)())),b=W(l),g="Task";function K(){return{concat:(e,a)=>()=>Promise.race([Promise.resolve().then(e),Promise.resolve().then(a)]),empty:en}}let U={URI:g,map:q},w=p(2,c(U)),C=d(U),E=f(U),N={URI:g,of:R},D={URI:g,map:q,ap:F},z=a(D),B=s(D),G={URI:g,map:q,ap:F,of:R},H={URI:g,map:q,ap:M},J={URI:g,map:q,ap:M,of:R},L={URI:g,map:q,ap:F,chain:W},Q={URI:g,map:q,of:R,ap:F,chain:W},V={URI:g,map:q,of:R,ap:F,chain:W,fromIO:S},X=l,Y={URI:g,map:q,of:R,ap:F,chain:W,fromIO:S,fromTask:X},Z={URI:g,fromIO:S},$=T({fromIO:Z.fromIO},{flatMap:W}),ee=p(2,n(L)),ea=p(2,m(Z,L)),er=i(Z),es=$,et=ea,eo={URI:g,fromIO:S,fromTask:X},en=()=>new Promise(e=>void 0),ei=R(P),em=v(U),ep=y(U),el=o(L),eh=r(D),ec=R(I),ed=e=>a=>()=>Promise.all(a.map((a,r)=>Promise.resolve().then(()=>e(r,a)()))),ev=e=>{let a=ed(e);return e=>A(e)?a(e):ec},ef=e=>a=>()=>O(a).reduce((a,r,s)=>a.then(a=>Promise.resolve().then(e(s+1,r)).then(e=>(a.push(e),a))),Promise.resolve().then(e(0,k(a))).then(u)),ey=e=>{let a=ef(e);return e=>A(e)?a(e):ec},eI=ev,eP=e=>ev((a,r)=>e(r)),eT=eP(l),ek=ey,eA=e=>ey((a,r)=>e(r)),eu=eA(l),eO=W,eS=ee,e_={URI:g,map:q,of:R,ap:F,chain:W,fromIO:S,fromTask:X},eq={URI:g,map:q,of:R,ap:M,chain:W,fromIO:S,fromTask:X},eF=t(H),eM=e(J);export{ec as ApT,G as ApplicativePar,J as ApplicativeSeq,D as ApplyPar,H as ApplySeq,L as Chain,ei as Do,Z as FromIO,eo as FromTask,U as Functor,Q as Monad,V as MonadIO,Y as MonadTask,N as Pointed,g as URI,x as ap,z as apFirst,eh as apS,B as apSecond,w as as,C as asUnit,el as bind,em as bindTo,eO as chain,eS as chainFirst,et as chainFirstIOK,es as chainIOK,_ as delay,E as flap,W as flatMap,$ as flatMapIO,b as flatten,S as fromIO,er as fromIOK,X as fromTask,eM as getMonoid,K as getRaceMonoid,eF as getSemigroup,ep as let,j as map,en as never,R as of,eT as sequenceArray,eu as sequenceSeqArray,ee as tap,ea as tapIO,e_ as task,eq as taskSeq,eP as traverseArray,eI as traverseArrayWithIndex,ev as traverseReadonlyArrayWithIndex,ey as traverseReadonlyArrayWithIndexSeq,ed as traverseReadonlyNonEmptyArrayWithIndex,ef as traverseReadonlyNonEmptyArrayWithIndexSeq,eA as traverseSeqArray,ek as traverseSeqArrayWithIndex};