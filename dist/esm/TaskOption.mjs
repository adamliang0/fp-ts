import{apFirst as a,apS as t,apSecond as r}from"./Apply.mjs";import{bind as o,tap as s}from"./Chain.mjs";import{compact as i,separate as p}from"./Compactable.mjs";import{filter as n,filterMap as e,partition as m,partitionMap as O}from"./Filterable.mjs";import{chainEitherK as l,fromEitherK as f,tapEither as T}from"./FromEither.mjs";import{fromIOK as k,tapIO as c}from"./FromIO.mjs";import{fromTaskK as h,tapTask as _}from"./FromTask.mjs";import{SK as d,dual as u,flow as y,identity as I,pipe as E}from"./function.mjs";import{as as v,asUnit as K,bindTo as A,flap as F,let as M}from"./Functor.mjs";import{emptyReadonlyArray as b,emptyRecord as j,flatMapIO as W,flatMapTask as S,head as x,isNonEmpty as N,isNone as q,none as P,singleton as C,some as R,tail as g}from"./internal.mjs";import{Compactable as z,Filterable as U,Functor as w,fromEither as Z,map as D,traverseReadonlyNonEmptyArrayWithIndex as B}from"./Option.mjs";import{alt as G,ap as H,chainNullableK as J,chainOptionK as L,flatMap as Q,fromEither as V,fromF as X,fromNullable as Y,fromNullableK as $,fromOptionK as aa,fromPredicate as at,getOrElse as ar,map as ao,match as as,matchE as ai,some as ap,zero as an}from"./OptionT.mjs";import{ApplyPar as ae,Chain as am,Functor as aO,Monad as al,Pointed as af,fromIO as aT,map as ak,of as ac,traverseReadonlyNonEmptyArrayWithIndex as ah}from"./Task.mjs";import{guard as a_}from"./Zero.mjs";function ad(a,t,r,o,s,i,p){try{var n=a[i](p),e=n.value}catch(a){r(a);return}n.done?t(e):Promise.resolve(e).then(o,s)}let au=ap(af),ay=at(af),aI=ac,aE=V(af),av=a=>aK(aT(a)),aK=X(aO),aA=ak(Z),aF=as(aO),aM=aF,ab=ai(am),aj=ab,aW=ab,aS=aW,ax=ar(al),aN=ax,aq=Y(af),aP=a=>()=>{var t;return(t=function*(){try{return yield a().then(R)}catch(a){return P}},function(){var a=this,r=arguments;return new Promise(function(o,s){var i=t.apply(a,r);function p(a){ad(i,o,s,p,n,"next",a)}function n(a){ad(i,o,s,p,n,"throw",a)}p(void 0)})})()},aC=a=>(...t)=>aP(()=>a(...t)),aR=$(af),ag=J(al),az=aa(af),aU=L(al),aw=ao(aO),aZ=H(ae),aD=au,aB=u(2,Q(al)),aG={flatMap:aB},aH=W({fromIO:av},aG),aJ=S({fromTask:aK},aG),aL=aB(I),aQ=G(al),aV=aQ,aX=an(af),aY=aX(),a$=i(aO,z),a2=p(aO,z,w),a0=n(aO,U),a1=e(aO,U),a3=m(aO,U),a4=O(aO,U),a5=(a,t)=>E(a,aw(t)),a6=(a,t)=>E(a,aZ(t)),a7=(a,t)=>E(a,aQ(t)),a8="TaskOption",a9={URI:a8,map:a5},ta=u(2,v(a9)),tt=K(a9),tr=F(a9),to={URI:a8,of:aD},ts={URI:a8,map:a5,ap:a6},ti=a(ts),tp=r(ts),tn={URI:a8,map:a5,ap:a6,of:aD},te=(a,t)=>aB(a,a=>E(t,aw(a))),tm={URI:a8,map:a5,ap:te},tO={URI:a8,map:a5,ap:te,of:aD},tl={URI:a8,map:a5,ap:a6,chain:aB},tf={URI:a8,fromEither:aE},tT={URI:a8,fromIO:av},tk={URI:a8,fromIO:av,fromTask:aK},tc=u(2,s(tl)),th=u(2,T(tf,tl)),t_=u(2,c(tT,tl)),td=u(2,_(tk,tl)),tu={URI:a8,map:a5,alt:a7},ty={URI:a8,zero:aX},tI=a_(ty,to),tE={URI:a8,map:a5,ap:a6,of:aD,alt:a7,zero:aX},tv={URI:a8,map:a5,ap:a6,of:aD,chain:aB},tK={URI:a8,map:a5,ap:a6,of:aD,chain:aB,fromIO:av},tA={URI:a8,map:a5,ap:a6,of:aD,chain:aB,fromIO:av,fromTask:aK},tF={URI:a8,compact:a$,separate:a2},tM={URI:a8,map:a5,compact:a$,separate:a2,filter:(a,t)=>E(a,a0(t)),filterMap:(a,t)=>E(a,a1(t)),partition:(a,t)=>E(a,a3(t)),partitionMap:(a,t)=>E(a,a4(t))},tb=k(tT),tj=aH,tW=t_,tS=f(tf),tx=l(tf,tl),tN=th,tq=h(tk),tP=aJ,tC=td,tR=aD(j),tg=A(a9),tz=M(a9),tU=o(tl),tw=t(ts),tZ=aD(b),tD=a=>y(ah(a),ak(B(d))),tB=a=>{let t=tD(a);return a=>N(a)?t(a):tZ},tG=a=>t=>()=>g(t).reduce((t,r,o)=>t.then(s=>q(s)?t:a(o+1,r)().then(a=>q(a)?a:(s.value.push(a.value),s))),a(0,x(t))().then(D(C))),tH=a=>{let t=tG(a);return a=>N(a)?t(a):tZ},tJ=tB,tL=a=>tB((t,r)=>a(r)),tQ=tL(I),tV=tH,tX=a=>tH((t,r)=>a(r)),tY=tX(I),t$=aB,t2=tc;export{tu as Alt,tE as Alternative,tZ as ApT,tn as ApplicativePar,tO as ApplicativeSeq,ts as ApplyPar,tm as ApplySeq,tl as Chain,tF as Compactable,tR as Do,tM as Filterable,tf as FromEither,tT as FromIO,tk as FromTask,a9 as Functor,tv as Monad,tK as MonadIO,tA as MonadTask,to as Pointed,a8 as URI,ty as Zero,aQ as alt,aV as altW,aZ as ap,ti as apFirst,tw as apS,tp as apSecond,ta as as,tt as asUnit,tU as bind,tg as bindTo,t$ as chain,tx as chainEitherK,t2 as chainFirst,tN as chainFirstEitherK,tW as chainFirstIOK,tC as chainFirstTaskK,tj as chainIOK,ag as chainNullableK,aU as chainOptionK,tP as chainTaskK,a$ as compact,a0 as filter,a1 as filterMap,tr as flap,aB as flatMap,aH as flatMapIO,aJ as flatMapTask,aL as flatten,aj as fold,aS as foldW,aE as fromEither,tS as fromEitherK,av as fromIO,tb as fromIOK,aq as fromNullable,aR as fromNullableK,aI as fromOption,az as fromOptionK,ay as fromPredicate,aK as fromTask,aA as fromTaskEither,tq as fromTaskK,ax as getOrElse,aN as getOrElseW,tI as guard,tz as let,aw as map,aF as match,ab as matchE,aW as matchEW,aM as matchW,aY as none,aD as of,a3 as partition,a4 as partitionMap,a2 as separate,tQ as sequenceArray,tY as sequenceSeqArray,au as some,tc as tap,th as tapEither,t_ as tapIO,td as tapTask,tL as traverseArray,tJ as traverseArrayWithIndex,tB as traverseReadonlyArrayWithIndex,tH as traverseReadonlyArrayWithIndexSeq,tD as traverseReadonlyNonEmptyArrayWithIndex,tG as traverseReadonlyNonEmptyArrayWithIndexSeq,tX as traverseSeqArray,tV as traverseSeqArrayWithIndex,aP as tryCatch,aC as tryCatchK,aX as zero};