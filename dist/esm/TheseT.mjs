import{ap as t}from"./Apply.mjs";import{flow as e,pipe as n}from"./function.mjs";import{map as r}from"./Functor.mjs";import{Functor as a,bimap as o,both as u,getApply as p,left as i,mapLeft as m,match as f,right as s,swap as c,toTuple2 as h}from"./These.mjs";function T(t){return e(s,t.of)}function l(t){return e(i,t.of)}function _(t){return e(u,t.of)}function g(t){return e=>t.map(e,s)}function b(t){return e=>t.map(e,i)}function j(t){return r(t,a)}function M(e,n){return t(e,p(n))}function d(t,e){let n=l(t);return r=>a=>t.chain(a,f(n,r,(n,a)=>t.map(r(a),f(t=>i(e.concat(n,t)),t=>u(n,t),(t,r)=>u(e.concat(n,t),r)))))}function w(t){return(e,n)=>r=>t.map(r,o(e,n))}function F(t){return e=>n=>t.map(n,m(e))}function L(t){return(e,n,r)=>a=>t.map(a,f(e,n,r))}function E(t){return(e,n,r)=>a=>t.chain(a,f(e,n,r))}function v(t){return e=>t.map(e,c)}function x(t){return(e,n)=>r=>t.map(r,h(e,n))}function y(t){let e=j(t),r=w(t),a=F(t),o=E(t),u=x(t),p=T(t),i=(t,r)=>n(t,e(r));return{map:i,bimap:(t,e,a)=>n(t,r(e,a)),mapLeft:(t,e)=>n(t,a(e)),fold:(t,e,r,a)=>n(t,o(e,r,a)),swap:v(t),rightM:g(t),leftM:b(t),left:l(t),right:T(t),both:_(t),toTuple:(t,e,r)=>n(t,u(()=>e,()=>r)),getMonad:e=>{let r=M(t,e),a=d(t,e);return{_E:void 0,map:i,of:p,ap:(t,e)=>n(t,r(e)),chain:(t,e)=>n(t,a(e))}}}}export{M as ap,w as bimap,_ as both,d as chain,y as getTheseM,l as left,b as leftF,j as map,F as mapLeft,L as match,E as matchE,T as right,g as rightF,v as swap,x as toTuple2};