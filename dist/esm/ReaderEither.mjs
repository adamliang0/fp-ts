import{getApplicativeMonoid as e}from"./Applicative.mjs";import{ap as a,apFirst as r,apS as t,apSecond as i,getApplySemigroup as o}from"./Apply.mjs";import{bind as p,tap as s}from"./Chain.mjs";import{compact as h,separate as d}from"./Compactable.mjs";import{Functor as l,getApplicativeValidation as m,getCompactable as E,getFilterable as n,getSemigroup as f,traverseReadonlyNonEmptyArrayWithIndex as R}from"./Either.mjs";import{alt as _,altValidation as c,ap as W,flatMap as u,getOrElse as g,left as F,leftF as y,map as b,mapBoth as A,mapError as M,match as K,matchE as O,orElse as v,orLeft as j,right as S,rightF as L,swap as N,tapError as k,toUnion as x}from"./EitherT.mjs";import{filter as I,filterMap as w,partition as C,partitionMap as T}from"./Filterable.mjs";import{chainOptionK as U,filterOrElse as P,fromEitherK as B,fromOption as V,fromOptionK as q,fromPredicate as D,tapEither as z}from"./FromEither.mjs";import{ask as G,asks as H,fromReaderK as J,tapReader as Q}from"./FromReader.mjs";import{SK as X,dual as Y,flow as Z,identity as $,pipe as ee}from"./function.mjs";import{as as ea,asUnit as er,bindTo as et,flap as ei,let as eo}from"./Functor.mjs";import{emptyReadonlyArray as ep,emptyRecord as es,flatMapEither as eh,flatMapNullable as ed,flatMapOption as el,flatMapReader as em,isNonEmpty as eE,liftNullable as en,liftOption as ef}from"./internal.mjs";import{Apply as eR,Functor as e_,Monad as ec,Pointed as eW,asksReaderW as eu,local as eg,map as eF,of as ey,traverseReadonlyNonEmptyArrayWithIndex as eb}from"./Reader.mjs";let eA=F(eW),eM=S(eW),eK=L(e_),eO=y(e_),ev=ey,ej=eK,eS=K(e_),eL=eS,eN=O(ec),ek=eN,ex=eN,eI=ex,ew=g(ec),eC=ew,eT=x(e_),eU=eg,eP=eu,eB=eP,eV=v(ec),eq=eV,eD=Y(2,k(ec)),ez=j(ec),eG=ez,eH=N(e_),eJ=(e,a)=>ee(e,eY(a)),eQ=(e,a)=>ee(e,e3(a)),eX=(e,a)=>ee(e,e8(a)),eY=b(e_),eZ=Y(3,A(e_)),e$=eZ,e2=Y(2,M(e_)),e0=e2,e3=W(eR),e1=e3,e4=eM,e5=Y(2,u(ec)),e6=e5($),e7=e6,e8=_(ec),e9=e8,ae=eA,aa="ReaderEither",ar=e=>{let a=E(e);return{URI:aa,_E:void 0,compact:h(e_,a),separate:d(e_,a,l)}};function at(e){let a=n(e),r=ar(e),t=I(e_,a),i=w(e_,a),o=C(e_,a),p=T(e_,a);return{URI:aa,_E:void 0,map:eJ,compact:r.compact,separate:r.separate,filter:(e,a)=>ee(e,t(a)),filterMap:(e,a)=>ee(e,i(a)),partition:(e,a)=>ee(e,o(a)),partitionMap:(e,a)=>ee(e,p(a))}}function ai(e){let r=a(eR,m(e));return{URI:aa,_E:void 0,map:eJ,ap:(e,a)=>ee(e,r(a)),of:e4}}function ao(e){let a=c(ec,e);return{URI:aa,_E:void 0,map:eJ,alt:(e,r)=>ee(e,a(r))}}let ap={URI:aa,map:eJ},as=Y(2,ea(ap)),ah=er(ap),ad=ei(ap),al={URI:aa,of:e4},am={URI:aa,map:eJ,ap:eQ},aE=r(am),an=aE,af=i(am),aR=af,a_={URI:aa,map:eJ,ap:eQ,of:e4},ac={URI:aa,map:eJ,ap:eQ,chain:e5},aW={URI:aa,map:eJ,ap:eQ,of:e4,chain:e5},au={URI:aa,fromEither:ev},ag={URI:aa,fromReader:ej},aF=Y(2,s(ac)),ay=Y(2,z(au,ac)),ab=Y(2,Q(ag,ac)),aA={URI:aa,bimap:eZ,mapLeft:e2},aM={URI:aa,map:eJ,alt:eX},aK=G(ag),aO=H(ag),av=J(ag),aj=ab,aS=ab,aL={URI:aa,map:eJ,ap:eQ,of:e4,chain:e5,throwError:ae},aN=V(au),ak=q(au),ax=U(au,ac),aI=ax,aw={fromEither:au.fromEither},aC={fromReader:ag.fromReader},aT=en(aw),aU=ef(aw),aP={flatMap:e5},aB=ed(aw,aP),aV=el(aw,aP),aq=eh(aw,aP),aD=em(aC,aP),az=aq,aG=aq,aH=ay,aJ=ay,aQ=aD,aX=aD,aY=D(au),aZ=P(au,ac),a$=aZ,a2=B(au),a0=e4(es),a3=et(ap),a1=eo(ap),a4=p(ac),a5=a4,a6=t(am),a7=a6,a8=e4(ep),a9=e=>Z(eb(e),eF(R(X))),re=e=>{let a=a9(e);return e=>eE(e)?a(e):a8},ra=re,rr=e=>re((a,r)=>e(r)),rt=rr($),ri=e5,ro=e5,rp=aF,rs=aF,rh=eD,rd=eD,rl={URI:aa,bimap:eZ,mapLeft:e2,map:eJ,of:e4,ap:eQ,chain:e5,alt:eX,throwError:eA},rm=o(am),rE=e(a_),rn=e=>o(eR)(f(e));function rf(e){let a=ai(e),r=ao(e);return{URI:aa,_E:void 0,map:eJ,ap:a.ap,of:e4,chain:e5,bimap:eZ,mapLeft:e2,alt:r.alt,throwError:ae}}export{aM as Alt,a8 as ApT,a_ as Applicative,am as Apply,aA as Bifunctor,ac as Chain,a0 as Do,au as FromEither,ag as FromReader,ap as Functor,aW as Monad,aL as MonadThrow,al as Pointed,aa as URI,e8 as alt,e9 as altW,e3 as ap,aE as apFirst,an as apFirstW,a6 as apS,a7 as apSW,af as apSecond,aR as apSecondW,e1 as apW,as as as,ah as asUnit,aK as ask,aO as asks,eB as asksReaderEither,eP as asksReaderEitherW,e$ as bimap,a4 as bind,a3 as bindTo,a5 as bindW,ri as chain,az as chainEitherK,aG as chainEitherKW,rp as chainFirst,aH as chainFirstEitherK,aJ as chainFirstEitherKW,aj as chainFirstReaderK,aS as chainFirstReaderKW,rs as chainFirstW,ax as chainOptionK,aI as chainOptionKW,aQ as chainReaderK,aX as chainReaderKW,ro as chainW,aZ as filterOrElse,a$ as filterOrElseW,ad as flap,e5 as flatMap,aq as flatMapEither,aB as flatMapNullable,aV as flatMapOption,aD as flatMapReader,e7 as flatten,e6 as flattenW,ek as fold,eI as foldW,ev as fromEither,a2 as fromEitherK,aN as fromOption,ak as fromOptionK,aY as fromPredicate,ej as fromReader,av as fromReaderK,ao as getAltReaderValidation,ai as getApplicativeReaderValidation,rE as getApplyMonoid,rm as getApplySemigroup,ar as getCompactable,at as getFilterable,ew as getOrElse,eC as getOrElseW,rf as getReaderValidation,rn as getSemigroup,eA as left,eO as leftReader,a1 as let,aT as liftNullable,aU as liftOption,eU as local,eY as map,eZ as mapBoth,e2 as mapError,e0 as mapLeft,eS as match,eN as matchE,ex as matchEW,eL as matchW,e4 as of,eV as orElse,rh as orElseFirst,rd as orElseFirstW,eq as orElseW,ez as orLeft,eG as orLeftW,rl as readerEither,eM as right,eK as rightReader,rt as sequenceArray,eH as swap,aF as tap,ay as tapEither,eD as tapError,ab as tapReader,ae as throwError,eT as toUnion,rr as traverseArray,ra as traverseArrayWithIndex,re as traverseReadonlyArrayWithIndex,a9 as traverseReadonlyNonEmptyArrayWithIndex};