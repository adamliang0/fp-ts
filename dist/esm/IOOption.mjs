import{apFirst as a,apS as t,apSecond as o}from"./Apply.mjs";import{bind as p,tap as i}from"./Chain.mjs";import{compact as r,separate as O}from"./Compactable.mjs";import{filter as n,filterMap as e,partition as m,partitionMap as s}from"./Filterable.mjs";import{fromEitherK as l,tapEither as I}from"./FromEither.mjs";import{fromIOK as f,tapIO as _}from"./FromIO.mjs";import{SK as h,dual as c,flow as d,identity as E,pipe as b}from"./function.mjs";import{as as M,asUnit as u,bindTo as F,flap as K,let as y}from"./Functor.mjs";import{emptyReadonlyArray as j,emptyRecord as N,flatMapEither as A,flatMapIO as W,isNonEmpty as v}from"./internal.mjs";import{Apply as C,Chain as g,Functor as x,Monad as R,Pointed as U,map as z,of as P,traverseReadonlyNonEmptyArrayWithIndex as S}from"./IO.mjs";import{Compactable as T,Filterable as Z,Functor as D,fromEither as k,toNullable as q,toUndefined as w,traverseReadonlyNonEmptyArrayWithIndex as B}from"./Option.mjs";import{alt as G,ap as H,chainNullableK as J,flatMap as L,fromEither as Q,fromF as V,fromNullable as X,fromNullableK as Y,fromOptionK as $,fromPredicate as aa,getOrElse as at,map as ao,match as ap,matchE as ai,some as ar,zero as aO}from"./OptionT.mjs";import{guard as an}from"./Zero.mjs";let ae=ar(U),am=aa(U),as=P,al=Q(U),aI=V(x),af=z(k),a_=ap(x),ah=a_,ac=ai(g),ad=ac,aE=ac,ab=at(R),aM=ab,au=z(w),aF=z(q),aK=X(U),ay=Y(U),aj=J(R),aN=$(U),aA=ao(x),aW=H(C),av=ae,aC=c(2,L(R)),ag=aC(E),ax=G(R),aR=ax,aU=aO(U),az=aU(),aP=r(x,T),aS=O(x,T,D),aT=n(x,Z),aZ=e(x,Z),aD=m(x,Z),ak=s(x,Z),aq=(a,t)=>b(a,aA(t)),aw=(a,t)=>b(a,aW(t)),aB=(a,t)=>b(a,ax(t)),aG="IOOption",aH={URI:aG,map:aq},aJ=c(2,M(aH)),aL=u(aH),aQ=K(aH),aV={URI:aG,of:av},aX={URI:aG,map:aq,ap:aw},aY=a(aX),a$=o(aX),a2={URI:aG,map:aq,ap:aw,of:av},a0={URI:aG,map:aq,ap:aw,chain:aC},a1={URI:aG,fromEither:al},a3={URI:aG,fromIO:aI},a4=c(2,i(a0)),a5=c(2,I(a1,a0)),a6=c(2,_(a3,a0)),a7={URI:aG,map:aq,alt:aB},a8={URI:aG,zero:aU},a9=an(a8,aV),ta={URI:aG,map:aq,ap:aw,of:av,alt:aB,zero:aU},tt={URI:aG,map:aq,ap:aw,of:av,chain:aC},to={URI:aG,map:aq,ap:aw,of:av,chain:aC,fromIO:aI},tp={URI:aG,compact:aP,separate:aS},ti={URI:aG,map:aq,compact:aP,separate:aS,filter:(a,t)=>b(a,aT(t)),filterMap:(a,t)=>b(a,aZ(t)),partition:(a,t)=>b(a,aD(t)),partitionMap:(a,t)=>b(a,ak(t))},tr={flatMap:aC},tO=W({fromIO:a3.fromIO},tr),tn=c(2,(a,t)=>aC(a,aN(t))),te=A({fromEither:al},tr),tm=c(2,(a,t)=>aC(a,ay(t))),ts=f(a3),tl=tO,tI=a6,tf=l(a1),t_=te,th=a5,tc=tn,td=av(N),tE=F(aH),tb=y(aH),tM=p(a0),tu=t(aX),tF=av(j),tK=a=>d(S(a),z(B(h))),ty=a=>{let t=tK(a);return a=>v(a)?t(a):tF},tj=aC,tN=a4;export{a7 as Alt,ta as Alternative,tF as ApT,a2 as Applicative,aX as Apply,a0 as Chain,tp as Compactable,td as Do,ti as Filterable,a1 as FromEither,a3 as FromIO,aH as Functor,tt as Monad,to as MonadIO,aV as Pointed,aG as URI,a8 as Zero,ax as alt,aR as altW,aW as ap,aY as apFirst,tu as apS,a$ as apSecond,aJ as as,aL as asUnit,tM as bind,tE as bindTo,tj as chain,t_ as chainEitherK,tN as chainFirst,th as chainFirstEitherK,tI as chainFirstIOK,tl as chainIOK,aj as chainNullableK,tc as chainOptionK,aP as compact,aT as filter,aZ as filterMap,aQ as flap,aC as flatMap,te as flatMapEither,tO as flatMapIO,tm as flatMapNullable,tn as flatMapOption,ag as flatten,ad as fold,al as fromEither,tf as fromEitherK,aI as fromIO,af as fromIOEither,ts as fromIOK,aK as fromNullable,ay as fromNullableK,as as fromOption,aN as fromOptionK,am as fromPredicate,ab as getOrElse,aM as getOrElseW,a9 as guard,tb as let,aA as map,a_ as match,ac as matchE,aE as matchEW,ah as matchW,az as none,av as of,aD as partition,ak as partitionMap,aS as separate,ae as some,a4 as tap,a5 as tapEither,a6 as tapIO,aF as toNullable,au as toUndefined,ty as traverseReadonlyArrayWithIndex,tK as traverseReadonlyNonEmptyArrayWithIndex,aU as zero};