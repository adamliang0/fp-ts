import{getApplySemigroup as e}from"./Apply.mjs";import{fromOption as a,fromOptionK as r,fromPredicate as s}from"./FromEither.mjs";import{fromIOK as t}from"./FromIO.mjs";import{fromTaskK as o}from"./FromTask.mjs";import{fromTheseK as m}from"./FromThese.mjs";import{SK as T,flow as h,pipe as i}from"./function.mjs";import{flap as p}from"./Functor.mjs";import{emptyReadonlyArray as f,head as n,isNonEmpty as k,singleton as l,tail as u}from"./internal.mjs";import{ApplicativePar as _,ApplySeq as c,Functor as d,Monad as I,Pointed as y,fromIO as g,map as O,of as E,traverseReadonlyNonEmptyArrayWithIndex as j}from"./Task.mjs";import{both as v,getSemigroup as F,isBoth as A,isLeft as b,map as W,traverseReadonlyNonEmptyArrayWithIndex as K}from"./These.mjs";import{ap as x,bimap as R,both as L,chain as N,left as P,leftF as S,map as q,mapLeft as w,match as B,matchE as C,right as M,rightF as U,swap as z,toTuple2 as D}from"./TheseT.mjs";let G=P(y),H=M(y),J=L(y),Q=U(d),V=S(d),X=h(g,Q),Y=h(g,V),Z=E,$=E,ee=X,ea=g,er=Q,es=B(d),et=es,eo=C(I),em=eo,eT=em,eh=eT,ei=z(d),ep=(e,a)=>i(e,ek(a)),ef=(e,a,r)=>i(e,el(a,r)),en=(e,a)=>i(e,eu(a)),ek=q(d),el=R(d),eu=w(d),e_=H,ec="TaskThese",ed=(e,a)=>{let r=x(e,a);return{URI:ec,_E:void 0,map:ep,ap:(e,a)=>i(e,r(a))}};function eI(e,a){let{ap:r}=ed(e,a);return{URI:ec,_E:void 0,map:ep,ap:r,of:e_}}function ey(e){let a=ed(_,e),r=N(I,e);return{URI:ec,_E:void 0,map:ep,ap:a.ap,chain:(e,a)=>i(e,r(a))}}function eg(e){let a=eI(_,e),r=ey(e);return{URI:ec,_E:void 0,map:ep,ap:a.ap,of:e_,chain:r.chain,fromIO:ee,fromTask:er}}let eO={URI:ec,map:ep},eE=p(eO),ej={URI:ec,of:e_},ev={URI:ec,bimap:ef,mapLeft:en},eF={URI:ec,fromEither:Z},eA=a(eF),eb=r(eF),eW=s(eF),eK={URI:ec,fromThese:$},ex=m(eK),eR={URI:ec,fromIO:ee},eL=t(eR),eN={URI:ec,fromIO:ee,fromTask:er},eP=o(eN),eS=D(d),eq=e_(f),ew=e=>{let a=K(e);return e=>h(j(e),O(a(T)))},eB=e=>a=>{let r=ew(e)(a);return e=>k(e)?r(e):eq},eC=e=>a=>r=>()=>u(r).reduce((r,s,t)=>r.then(o=>b(o)?r:a(t+1,s)().then(a=>{if(b(a))return a;if(A(a)){let r=o.right;return r.push(a.right),A(o)?v(e.concat(o.left,a.left),r):v(a.left,r)}return o.right.push(a.right),o})),a(0,n(r))().then(W(l))),eM=e=>a=>{let r=eC(e)(a);return e=>k(e)?r(e):eq},eU={URI:ec,map:ep},ez={URI:ec,bimap:ef,mapLeft:en},eD=(e,a)=>eS(()=>e,()=>a),eG={URI:ec,map:ep,bimap:ef,mapLeft:en},eH=(a,r)=>e(c)(F(a,r));export{eq as ApT,ev as Bifunctor,eF as FromEither,eR as FromIO,eN as FromTask,eK as FromThese,eO as Functor,ej as Pointed,ec as URI,ez as bifunctorTaskThese,el as bimap,J as both,eE as flap,em as fold,eh as foldW,Z as fromEither,ee as fromIO,ea as fromIOEither,eL as fromIOK,eA as fromOption,eb as fromOptionK,eW as fromPredicate,er as fromTask,eP as fromTaskK,$ as fromThese,ex as fromTheseK,eU as functorTaskThese,eI as getApplicative,ed as getApply,ey as getChain,eg as getMonad,eH as getSemigroup,G as left,Y as leftIO,V as leftTask,ek as map,eu as mapLeft,es as match,eo as matchE,eT as matchEW,et as matchW,e_ as of,H as right,X as rightIO,Q as rightTask,ei as swap,eG as taskThese,eD as toTuple,eS as toTuple2,eB as traverseReadonlyArrayWithIndex,eM as traverseReadonlyArrayWithIndexSeq,ew as traverseReadonlyNonEmptyArrayWithIndex,eC as traverseReadonlyNonEmptyArrayWithIndexSeq};