import{__webpack_require__ as e}from"./rslib-runtime.mjs";// NAMESPACE OBJECT: ./src/Alt.ts
var t={};e.r(t),e.d(t,{altAll:()=>tn});// NAMESPACE OBJECT: ./src/Alternative.ts
var r={};e.r(r),e.d(r,{altAll:()=>rr,getAlternativeMonoid:()=>ra});// NAMESPACE OBJECT: ./src/Applicative.ts
var a={};e.r(a),e.d(a,{getApplicativeComposition:()=>rd,getApplicativeMonoid:()=>rf});// NAMESPACE OBJECT: ./src/Apply.ts
var n={};e.r(n),e.d(n,{ap:()=>t3,apFirst:()=>t4,apS:()=>t7,apSecond:()=>t5,getApplySemigroup:()=>t6,sequenceS:()=>rt,sequenceT:()=>re});// NAMESPACE OBJECT: ./src/Array.ts
var i={};e.r(i),e.d(i,{Alt:()=>ho,Alternative:()=>hc,Applicative:()=>ht,Apply:()=>d8,Chain:()=>hr,ChainRecBreadthFirst:()=>hU,ChainRecDepthFirst:()=>hy,Compactable:()=>hf,Do:()=>h_,Extend:()=>hu,Filterable:()=>hd,FilterableWithIndex:()=>hh,Foldable:()=>hs,FoldableWithIndex:()=>hm,FromEither:()=>hx,Functor:()=>d4,FunctorWithIndex:()=>d6,Monad:()=>hn,Pointed:()=>d7,Traversable:()=>hI,TraversableWithIndex:()=>hg,URI:()=>dH,Unfoldable:()=>hi,Witherable:()=>hW,Zero:()=>hl,alt:()=>dw,altW:()=>dT,ap:()=>dR,apFirst:()=>d9,apS:()=>hN,apSecond:()=>he,append:()=>u1,appendW:()=>u2,array:()=>h$,bind:()=>hL,bindTo:()=>hK,chain:()=>hC,chainFirst:()=>ha,chainRecBreadthFirst:()=>hO,chainRecDepthFirst:()=>hM,chainWithIndex:()=>fo,chop:()=>fJ,chunksOf:()=>fZ,compact:()=>dU,comprehension:()=>fG,concat:()=>fX,concatW:()=>fQ,cons:()=>hB,copy:()=>fF,deleteAt:()=>fk,difference:()=>f2,dropLeft:()=>fM,dropLeftWhile:()=>fO,dropRight:()=>fy,duplicate:()=>d_,elem:()=>fD,empty:()=>hz,every:()=>hT,exists:()=>hk,extend:()=>dq,filter:()=>dx,filterE:()=>hb,filterMap:()=>dO,filterMapWithIndex:()=>dy,filterWithIndex:()=>dk,findFirst:()=>fb,findFirstMap:()=>fx,findIndex:()=>fU,findLast:()=>fE,findLastIndex:()=>fS,findLastMap:()=>fA,flap:()=>d5,flatMap:()=>dv,flatten:()=>dW,foldLeft:()=>fr,foldMap:()=>dK,foldMapWithIndex:()=>dj,foldRight:()=>fi,fromEither:()=>u6,fromEitherK:()=>hE,fromOption:()=>u7,fromOptionK:()=>fY,fromPredicate:()=>u5,getDifferenceMagma:()=>d3,getEq:()=>dQ,getIntersectionSemigroup:()=>d2,getMonoid:()=>dG,getOrd:()=>dX,getSemigroup:()=>dY,getShow:()=>dZ,getUnionMonoid:()=>d1,getUnionSemigroup:()=>d0,guard:()=>hp,head:()=>fd,init:()=>fm,insertAt:()=>fT,intercalate:()=>hq,intersection:()=>f1,intersperse:()=>fz,isEmpty:()=>uG,isNonEmpty:()=>uQ,isOutOfBound:()=>fu,last:()=>fh,lefts:()=>fj,let:()=>hj,lookup:()=>ff,makeBy:()=>u3,map:()=>dg,mapWithIndex:()=>dM,match:()=>u9,matchLeft:()=>ft,matchLeftW:()=>fe,matchRight:()=>fn,matchRightW:()=>fa,matchW:()=>u8,modifyAt:()=>fq,of:()=>dm,partition:()=>dE,partitionMap:()=>dS,partitionMapWithIndex:()=>dF,partitionWithIndex:()=>dA,prepend:()=>uX,prependAll:()=>fP,prependToAll:()=>hV,prependW:()=>u0,range:()=>hP,reduce:()=>dL,reduceRight:()=>dC,reduceRightWithIndex:()=>dP,reduceWithIndex:()=>dN,replicate:()=>u4,reverse:()=>f_,rights:()=>fK,rotate:()=>fB,scanLeft:()=>fl,scanRight:()=>fp,separate:()=>db,sequence:()=>dB,size:()=>fc,snoc:()=>hD,some:()=>hw,sort:()=>fL,sortBy:()=>f$,spanLeft:()=>fW,splitAt:()=>fH,tail:()=>fs,takeLeft:()=>fI,takeLeftWhile:()=>fR,takeRight:()=>fg,traverse:()=>dz,traverseWithIndex:()=>dD,unfold:()=>dJ,union:()=>f0,uniq:()=>fV,unsafeDeleteAt:()=>hF,unsafeInsertAt:()=>hA,unsafeUpdateAt:()=>hS,unzip:()=>fC,updateAt:()=>fw,wilt:()=>d$,wither:()=>dV,zero:()=>dI,zip:()=>function e(t,r){return void 0===r?r=>e(r,t):fN(t,r,(e,t)=>[e,t])},zipWith:()=>fN});// NAMESPACE OBJECT: ./src/Bifunctor.ts
var o={};e.r(o);// NAMESPACE OBJECT: ./src/BooleanAlgebra.ts
var l={};e.r(l),e.d(l,{booleanAlgebraBoolean:()=>h9,booleanAlgebraVoid:()=>h6,getDualBooleanAlgebra:()=>h8,getFunctionBooleanAlgebra:()=>se,reverse:()=>h7});// NAMESPACE OBJECT: ./src/Bounded.ts
var p={};e.r(p),e.d(p,{boundedNumber:()=>sa,clamp:()=>st,reverse:()=>sr});// NAMESPACE OBJECT: ./src/BoundedDistributiveLattice.ts
var c={};e.r(c),e.d(c,{getMinMaxBoundedDistributiveLattice:()=>si});// NAMESPACE OBJECT: ./src/BoundedJoinSemilattice.ts
var u={};e.r(u);// NAMESPACE OBJECT: ./src/BoundedLattice.ts
var f={};e.r(f);// NAMESPACE OBJECT: ./src/BoundedMeetSemilattice.ts
var d={};e.r(d);// NAMESPACE OBJECT: ./src/Category.ts
var h={};e.r(h);// NAMESPACE OBJECT: ./src/Chain.ts
var s={};e.r(s),e.d(s,{bind:()=>rm,chainFirst:()=>rh,tap:()=>rs});// NAMESPACE OBJECT: ./src/ChainRec.ts
var m={};e.r(m),e.d(m,{tailRec:()=>so});// NAMESPACE OBJECT: ./src/Choice.ts
var I={};e.r(I),e.d(I,{fanIn:()=>sp,fanin:()=>su,split:()=>sl,splitChoice:()=>sc});// NAMESPACE OBJECT: ./src/Comonad.ts
var g={};e.r(g);// NAMESPACE OBJECT: ./src/Compactable.ts
var R={};e.r(R),e.d(R,{compact:()=>Ip,getCompactableComposition:()=>Iu,separate:()=>Ic});// NAMESPACE OBJECT: ./src/Console.ts
var v={};e.r(v),e.d(v,{error:()=>Ih,info:()=>Is,log:()=>If,warn:()=>Id});// NAMESPACE OBJECT: ./src/Const.ts
var W={};e.r(W),e.d(W,{Bifunctor:()=>IC,Contravariant:()=>IN,Functor:()=>Ij,URI:()=>IK,bimap:()=>Iq,const_:()=>IP,contramap:()=>Iw,flap:()=>IL,getApplicative:()=>IE,getApply:()=>Ix,getBooleanAlgebra:()=>Ib,getBounded:()=>Iv,getEq:()=>Ig,getHeytingAlgebra:()=>IU,getMonoid:()=>IM,getOrd:()=>IR,getRing:()=>IO,getSemigroup:()=>IW,getSemiring:()=>Iy,getShow:()=>II,make:()=>Im,map:()=>Ik,mapLeft:()=>I_});// NAMESPACE OBJECT: ./src/Contravariant.ts
var M={};e.r(M);// NAMESPACE OBJECT: ./src/Date.ts
var y={};e.r(y),e.d(y,{Eq:()=>Iz,Ord:()=>I$,create:()=>IJ,eqDate:()=>IB,eqMonth:()=>ID,eqYear:()=>IV,now:()=>IH});// NAMESPACE OBJECT: ./src/DistributiveLattice.ts
var O={};e.r(O),e.d(O,{getMinMaxDistributiveLattice:()=>sn});// NAMESPACE OBJECT: ./src/Either.ts
var U={};e.r(U),e.d(U,{Alt:()=>gw,ApT:()=>RO,Applicative:()=>gg,Apply:()=>gI,Bifunctor:()=>gS,Chain:()=>gR,ChainRec:()=>g_,Do:()=>RI,Extend:()=>gq,Foldable:()=>gO,FromEither:()=>gL,Functor:()=>gc,Monad:()=>gv,MonadThrow:()=>gj,Pointed:()=>gh,Traversable:()=>gx,URI:()=>I9,alt:()=>gT,altW:()=>gF,ap:()=>gm,apFirst:()=>gY,apFirstW:()=>gG,apS:()=>RM,apSW:()=>Ry,apSecond:()=>gQ,apSecondW:()=>gX,apW:()=>gs,as:()=>gu,asUnit:()=>gf,bimap:()=>gE,bind:()=>Rv,bindTo:()=>Rg,bindW:()=>RW,chain:()=>RF,chainFirst:()=>RT,chainFirstW:()=>Rw,chainNullableK:()=>Rd,chainOptionK:()=>g5,chainOptionKW:()=>g7,chainW:()=>RS,duplicate:()=>g3,either:()=>R_,elem:()=>function e(t){return(r,a)=>{if(void 0===a){let a=e(t);return e=>a(r,e)}return!gP(a)&&t.equals(r,a.right)}},exists:()=>Rm,extend:()=>gk,filterOrElse:()=>Ra,filterOrElseW:()=>Rn,flap:()=>gZ,flatMap:()=>IG,flatMapNullable:()=>Rt,flatMapOption:()=>Rr,flatten:()=>g2,flattenW:()=>g1,fold:()=>g$,foldMap:()=>gM,foldW:()=>gD,fromNullable:()=>Rp,fromNullableK:()=>Rf,fromOption:()=>gC,fromOptionK:()=>g4,fromPredicate:()=>gN,getAltValidation:()=>gl,getApplicativeValidation:()=>go,getApplyMonoid:()=>Rj,getApplySemigroup:()=>RK,getCompactable:()=>ga,getEq:()=>gt,getFilterable:()=>gn,getOrElse:()=>gH,getOrElseW:()=>gJ,getSemigroup:()=>gr,getShow:()=>ge,getValidation:()=>RC,getValidationMonoid:()=>RN,getValidationSemigroup:()=>RL,getWitherable:()=>gi,isLeft:()=>gP,isRight:()=>gz,left:()=>IZ,let:()=>RR,liftNullable:()=>g8,liftOption:()=>g9,map:()=>gp,mapLeft:()=>gA,match:()=>gV,matchW:()=>gB,of:()=>gd,orElse:()=>Rl,orElseW:()=>Ro,parseJSON:()=>Rk,reduce:()=>gW,reduceRight:()=>gy,right:()=>IY,sequence:()=>gb,sequenceArray:()=>RA,stringifyJSON:()=>Rq,swap:()=>Ri,tap:()=>g0,throwError:()=>gK,toError:()=>Rs,toUnion:()=>Rh,traverse:()=>gU,traverseArray:()=>RE,traverseArrayWithIndex:()=>Rx,traverseReadonlyArrayWithIndex:()=>Rb,traverseReadonlyNonEmptyArrayWithIndex:()=>RU,tryCatch:()=>Rc,tryCatchK:()=>Ru});// NAMESPACE OBJECT: ./src/EitherT.ts
var b={};e.r(b),e.d(b,{alt:()=>RQ,altValidation:()=>R3,ap:()=>RZ,bimap:()=>RX,chain:()=>RY,chainNullableK:()=>RJ,flatMap:()=>RG,fromNullable:()=>RV,fromNullableK:()=>R$,getEitherM:()=>vn,getOrElse:()=>R7,getOrElseW:()=>R6,left:()=>Rz,leftF:()=>RD,map:()=>RH,mapBoth:()=>R0,mapError:()=>R2,mapLeft:()=>R1,match:()=>R4,matchE:()=>R5,orElse:()=>R8,orElseFirst:()=>R9,orLeft:()=>vt,right:()=>RP,rightF:()=>RB,swap:()=>vr,tapError:()=>ve,toUnion:()=>va});// NAMESPACE OBJECT: ./src/Endomorphism.ts
var x={};e.r(x),e.d(x,{URI:()=>vi,getMonoid:()=>vl,getSemigroup:()=>vo});// NAMESPACE OBJECT: ./src/Eq.ts
var E={};e.r(E),e.d(E,{Contravariant:()=>rq,URI:()=>rS,contramap:()=>rA,eq:()=>rL,eqBoolean:()=>rN,eqDate:()=>rz,eqNumber:()=>rP,eqStrict:()=>rF,eqString:()=>rC,fromEquals:()=>rb,getMonoid:()=>rk,getSemigroup:()=>rw,getStructEq:()=>rK,getTupleEq:()=>r_,strictEqual:()=>rj,struct:()=>rx,tuple:()=>rE});// NAMESPACE OBJECT: ./src/Extend.ts
var A={};e.r(A);// NAMESPACE OBJECT: ./src/Field.ts
var S={};e.r(S),e.d(S,{fieldNumber:()=>vu,gcd:()=>vp,lcm:()=>vc});// NAMESPACE OBJECT: ./src/Filterable.ts
var F={};e.r(F),e.d(F,{filter:()=>vf,filterMap:()=>vd,getFilterableComposition:()=>vm,partition:()=>vh,partitionMap:()=>vs});// NAMESPACE OBJECT: ./src/FilterableWithIndex.ts
var T={};e.r(T);// NAMESPACE OBJECT: ./src/Foldable.ts
var w={};e.r(w),e.d(w,{foldM:()=>vO,foldMap:()=>vg,getFoldableComposition:()=>vb,intercalate:()=>vW,reduce:()=>vI,reduceM:()=>vv,reduceRight:()=>vR,toArray:()=>vU,toReadonlyArray:()=>vM,traverse_:()=>vy});// NAMESPACE OBJECT: ./src/FoldableWithIndex.ts
var k={};e.r(k),e.d(k,{foldMapWithIndex:()=>vE,getFoldableWithIndexComposition:()=>vS,reduceRightWithIndex:()=>vA,reduceWithIndex:()=>vx});// NAMESPACE OBJECT: ./src/FromEither.ts
var q={};e.r(q),e.d(q,{chainEitherK:()=>rM,chainFirstEitherK:()=>ry,chainOptionK:()=>rv,filterOrElse:()=>rO,fromEitherK:()=>rW,fromOption:()=>rI,fromOptionK:()=>rR,fromPredicate:()=>rg,tapEither:()=>rU});// NAMESPACE OBJECT: ./src/FromIO.ts
var _={};e.r(_),e.d(_,{chainFirstIOK:()=>vw,chainIOK:()=>vT,fromIOK:()=>vF,tapIO:()=>vk});// NAMESPACE OBJECT: ./src/FromReader.ts
var K={};e.r(K),e.d(K,{ask:()=>WF,asks:()=>WT,chainFirstReaderK:()=>Wq,chainReaderK:()=>Wk,fromReaderK:()=>Ww,tapReader:()=>W_});// NAMESPACE OBJECT: ./src/FromState.ts
var j={};e.r(j),e.d(j,{chainStateK:()=>MI,fromStateK:()=>Mm,get:()=>Mf,gets:()=>Ms,modify:()=>Mh,put:()=>Md});// NAMESPACE OBJECT: ./src/FromTask.ts
var L={};e.r(L),e.d(L,{chainFirstTaskK:()=>Mv,chainTaskK:()=>MR,fromTaskK:()=>Mg,tapTask:()=>MW});// NAMESPACE OBJECT: ./src/FromThese.ts
var N={};e.r(N),e.d(N,{fromTheseK:()=>MM});// NAMESPACE OBJECT: ./src/Functor.ts
var C={};e.r(C),e.d(C,{as:()=>rc,asUnit:()=>ru,bindTo:()=>ro,flap:()=>ri,getFunctorComposition:()=>rp,let:()=>rl,map:()=>rn});// NAMESPACE OBJECT: ./src/FunctorWithIndex.ts
var P={};e.r(P),e.d(P,{getFunctorWithIndexComposition:()=>MO,mapWithIndex:()=>My});// NAMESPACE OBJECT: ./src/Group.ts
var z={};e.r(z);// NAMESPACE OBJECT: ./src/HKT.ts
var B={};e.r(B);// NAMESPACE OBJECT: ./src/HeytingAlgebra.ts
var D={};e.r(D);// NAMESPACE OBJECT: ./src/IO.ts
var V={};e.r(V),e.d(V,{ApT:()=>yN,Applicative:()=>yx,Apply:()=>yO,Chain:()=>yE,ChainRec:()=>yw,Do:()=>yq,FromIO:()=>yk,Functor:()=>yR,Monad:()=>yA,MonadIO:()=>yT,Pointed:()=>yy,URI:()=>yg,ap:()=>yh,apFirst:()=>yU,apS:()=>yL,apSecond:()=>yb,as:()=>yv,asUnit:()=>yW,bind:()=>yj,bindTo:()=>y_,chain:()=>yV,chainFirst:()=>y$,flap:()=>yM,flatMap:()=>ym,flatten:()=>yI,fromIO:()=>yF,getMonoid:()=>yZ,getSemigroup:()=>yH,io:()=>yJ,let:()=>yK,map:()=>yd,of:()=>ys,sequenceArray:()=>yD,tap:()=>yS,traverseArray:()=>yB,traverseArrayWithIndex:()=>yz,traverseReadonlyArrayWithIndex:()=>yP,traverseReadonlyNonEmptyArrayWithIndex:()=>yC});// NAMESPACE OBJECT: ./src/IOEither.ts
var $={};e.r($),e.d($,{Alt:()=>OG,ApT:()=>Uy,Applicative:()=>Uk,ApplicativePar:()=>Oz,ApplicativeSeq:()=>OB,ApplyPar:()=>Oj,Bifunctor:()=>OK,Chain:()=>OD,Do:()=>Um,FromEither:()=>O$,FromIO:()=>OJ,Functor:()=>OT,Monad:()=>OV,MonadIO:()=>OQ,MonadThrow:()=>OX,Pointed:()=>O_,URI:()=>Ox,alt:()=>OO,altW:()=>OU,ap:()=>Og,apFirst:()=>OL,apFirstW:()=>ON,apS:()=>UW,apSW:()=>UM,apSecond:()=>OC,apSecondW:()=>OP,apW:()=>OR,as:()=>Ow,asUnit:()=>Ok,bimap:()=>Os,bind:()=>UR,bindTo:()=>UI,bindW:()=>Uv,bracket:()=>Uh,bracketW:()=>Us,chain:()=>Uq,chainEitherK:()=>Ui,chainEitherKW:()=>Uo,chainFirst:()=>UK,chainFirstEitherK:()=>Ul,chainFirstEitherKW:()=>Up,chainFirstIOK:()=>O1,chainFirstW:()=>Uj,chainIOK:()=>Un,chainOptionK:()=>O4,chainOptionKW:()=>O5,chainW:()=>U_,filterOrElse:()=>Uu,filterOrElseW:()=>Uf,flap:()=>Oq,flatMap:()=>OW,flatMapEither:()=>Ur,flatMapIO:()=>Ua,flatMapNullable:()=>Ue,flatMapOption:()=>Ut,flatten:()=>Oy,flattenW:()=>OM,fold:()=>y5,foldW:()=>y6,fromEither:()=>y0,fromEitherK:()=>Ud,fromIO:()=>y1,fromIOK:()=>O0,fromOption:()=>O2,fromOptionK:()=>O3,fromPredicate:()=>Uc,getAltIOValidation:()=>OA,getApplicativeIOValidation:()=>OE,getApplyMonoid:()=>Uz,getApplySemigroup:()=>UP,getCompactable:()=>OS,getFilterable:()=>OF,getIOValidation:()=>UD,getOrElse:()=>y8,getOrElseW:()=>y9,getSemigroup:()=>UB,ioEither:()=>UC,left:()=>yY,leftIO:()=>yX,let:()=>Ug,liftNullable:()=>O6,liftOption:()=>O8,map:()=>Od,mapBoth:()=>Oh,mapError:()=>Om,mapLeft:()=>OI,match:()=>y2,matchE:()=>y4,matchEW:()=>y7,matchW:()=>y3,of:()=>Ov,orElse:()=>Oa,orElseFirst:()=>UL,orElseFirstIOK:()=>Oo,orElseFirstW:()=>UN,orElseW:()=>On,orLeft:()=>Ol,right:()=>yG,rightIO:()=>yQ,sequenceArray:()=>US,sequenceSeqArray:()=>Uw,swap:()=>Op,tap:()=>OH,tapEither:()=>OZ,tapError:()=>Oi,tapIO:()=>OY,throwError:()=>Ob,toUnion:()=>Or,traverseArray:()=>UA,traverseArrayWithIndex:()=>UE,traverseReadonlyArrayWithIndex:()=>UU,traverseReadonlyArrayWithIndexSeq:()=>Ux,traverseReadonlyNonEmptyArrayWithIndex:()=>UO,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>Ub,traverseSeqArray:()=>UT,traverseSeqArrayWithIndex:()=>UF,tryCatch:()=>Oe,tryCatchK:()=>Ot});// NAMESPACE OBJECT: ./src/IOOption.ts
var J={};e.r(J),e.d(J,{Alt:()=>bX,Alternative:()=>b2,ApT:()=>xs,Applicative:()=>b$,Apply:()=>bB,Chain:()=>bJ,Compactable:()=>b5,Do:()=>xc,Filterable:()=>b7,FromEither:()=>bH,FromIO:()=>bZ,Functor:()=>bL,Monad:()=>b3,MonadIO:()=>b4,Pointed:()=>bz,URI:()=>bj,Zero:()=>b0,alt:()=>bU,altW:()=>bb,ap:()=>bW,apFirst:()=>bD,apS:()=>xh,apSecond:()=>bV,as:()=>bN,asUnit:()=>bC,bind:()=>xd,bindTo:()=>xu,chain:()=>xg,chainEitherK:()=>xo,chainFirst:()=>xR,chainFirstEitherK:()=>xl,chainFirstIOK:()=>xn,chainIOK:()=>xa,chainNullableK:()=>bg,chainOptionK:()=>xp,compact:()=>bA,filter:()=>bF,filterMap:()=>bT,flap:()=>bP,flatMap:()=>by,flatMapEither:()=>xe,flatMapIO:()=>b8,flatMapNullable:()=>xt,flatMapOption:()=>b9,flatten:()=>bO,fold:()=>bc,fromEither:()=>ba,fromEitherK:()=>xi,fromIO:()=>bn,fromIOEither:()=>bi,fromIOK:()=>xr,fromNullable:()=>bm,fromNullableK:()=>bI,fromOption:()=>br,fromOptionK:()=>bR,fromPredicate:()=>bt,getOrElse:()=>bf,getOrElseW:()=>bd,guard:()=>b1,let:()=>xf,map:()=>bv,match:()=>bo,matchE:()=>bp,matchEW:()=>bu,matchW:()=>bl,none:()=>bE,of:()=>bM,partition:()=>bw,partitionMap:()=>bk,separate:()=>bS,some:()=>be,tap:()=>bY,tapEither:()=>bG,tapIO:()=>bQ,toNullable:()=>bs,toUndefined:()=>bh,traverseReadonlyArrayWithIndex:()=>xI,traverseReadonlyNonEmptyArrayWithIndex:()=>xm,zero:()=>bx});// NAMESPACE OBJECT: ./src/IORef.ts
var H={};e.r(H),e.d(H,{IORef:()=>xW,newIORef:()=>xM});// NAMESPACE OBJECT: ./src/Identity.ts
var Z={};e.r(Z),e.d(Z,{Alt:()=>M9,Applicative:()=>M2,Apply:()=>MX,Chain:()=>M3,ChainRec:()=>yt,Comonad:()=>ye,Do:()=>yr,Foldable:()=>M6,Functor:()=>MY,Monad:()=>M4,Pointed:()=>MQ,Traversable:()=>M8,URI:()=>MJ,alt:()=>M$,altW:()=>MV,ap:()=>Mk,apFirst:()=>M0,apS:()=>yo,apSecond:()=>M1,bind:()=>yi,bindTo:()=>ya,chain:()=>yl,chainFirst:()=>M7,duplicate:()=>ML,extend:()=>MK,extract:()=>Mj,flap:()=>MG,flatMap:()=>M_,flatten:()=>MN,foldMap:()=>MP,getEq:()=>MZ,getShow:()=>MH,identity:()=>yp,let:()=>yn,map:()=>Mw,of:()=>Mq,reduce:()=>MC,reduceRight:()=>Mz,sequence:()=>MD,tap:()=>M5,traverse:()=>MB});// NAMESPACE OBJECT: ./src/Invariant.ts
var Y={};e.r(Y);// NAMESPACE OBJECT: ./src/JoinSemilattice.ts
var G={};e.r(G);// NAMESPACE OBJECT: ./src/Json.ts
var Q={};e.r(Q),e.d(Q,{parse:()=>xy,stringify:()=>xO});// NAMESPACE OBJECT: ./src/Lattice.ts
var X={};e.r(X);// NAMESPACE OBJECT: ./src/Magma.ts
var ee={};e.r(ee),e.d(ee,{concatAll:()=>au,endo:()=>ac,filterFirst:()=>al,filterSecond:()=>ap,reverse:()=>ao});// NAMESPACE OBJECT: ./src/Map.ts
var et={};e.r(et),e.d(et,{Compactable:()=>Aq,Filterable:()=>A_,Functor:()=>Aw,URI:()=>AI,collect:()=>EB,compact:()=>Ap,deleteAt:()=>EJ,difference:()=>AN,elem:()=>EC,empty:()=>AC,filter:()=>Ac,filterMap:()=>Au,filterMapWithIndex:()=>E6,filterWithIndex:()=>E8,flap:()=>Ak,foldMap:()=>AU,foldMapWithIndex:()=>AA,fromFoldable:()=>E3,getDifferenceMagma:()=>AW,getEq:()=>E0,getFilterableWithIndex:()=>AM,getFoldable:()=>Ax,getFoldableWithIndex:()=>AF,getIntersectionSemigroup:()=>Av,getMonoid:()=>E1,getShow:()=>EK,getTraversableWithIndex:()=>AT,getUnionMonoid:()=>AR,getUnionSemigroup:()=>Ag,getWitherable:()=>Ay,insertAt:()=>AP,intersection:()=>AL,isEmpty:()=>EL,isSubmap:()=>EX,keys:()=>EP,lookup:()=>EQ,lookupWithKey:()=>EG,map:()=>Af,mapWithIndex:()=>Ad,map_:()=>Az,member:()=>EN,modifyAt:()=>EZ,partition:()=>Ah,partitionMap:()=>As,partitionMapWithIndex:()=>E5,partitionWithIndex:()=>E7,pop:()=>EY,reduce:()=>AO,reduceRight:()=>Ab,reduceRightWithIndex:()=>AS,reduceWithIndex:()=>AE,separate:()=>Am,singleton:()=>E2,size:()=>Ej,toArray:()=>ED,toUnfoldable:()=>EV,union:()=>Aj,updateAt:()=>EH,upsertAt:()=>E$,values:()=>Ez});// NAMESPACE OBJECT: ./src/MeetSemilattice.ts
var er={};e.r(er);// NAMESPACE OBJECT: ./src/Monad.ts
var ea={};e.r(ea);// NAMESPACE OBJECT: ./src/MonadIO.ts
var en={};e.r(en);// NAMESPACE OBJECT: ./src/MonadTask.ts
var ei={};e.r(ei);// NAMESPACE OBJECT: ./src/MonadThrow.ts
var eo={};e.r(eo);// NAMESPACE OBJECT: ./src/Monoid.ts
var el={};e.r(el),e.d(el,{concatAll:()=>AH,fold:()=>A1,getDualMonoid:()=>AQ,getEndomorphismMonoid:()=>A5,getFunctionMonoid:()=>A4,getJoinMonoid:()=>AX,getMeetMonoid:()=>A0,getStructMonoid:()=>AG,getTupleMonoid:()=>AY,max:()=>AD,min:()=>AB,monoidAll:()=>A2,monoidAny:()=>A3,monoidProduct:()=>A8,monoidString:()=>A7,monoidSum:()=>A6,monoidVoid:()=>AZ,reverse:()=>AV,struct:()=>A$,tuple:()=>AJ});// NAMESPACE OBJECT: ./src/NaturalTransformation.ts
var ep={};e.r(ep);// NAMESPACE OBJECT: ./src/NonEmptyArray.ts
var ec={};e.r(ec),e.d(ec,{Alt:()=>o7,Applicative:()=>oQ,Apply:()=>oZ,Chain:()=>oX,Comonad:()=>o6,Do:()=>o8,Foldable:()=>o2,FoldableWithIndex:()=>o3,Functor:()=>oV,FunctorWithIndex:()=>oH,Monad:()=>o1,Pointed:()=>oJ,Traversable:()=>o4,TraversableWithIndex:()=>o5,URI:()=>oC,alt:()=>oU,altW:()=>oO,ap:()=>ob,apFirst:()=>oY,apS:()=>lr,apSecond:()=>oG,append:()=>iN,appendW:()=>iL,bind:()=>lt,bindTo:()=>o9,chain:()=>lg,chainFirst:()=>o0,chainWithIndex:()=>oo,chop:()=>ol,chunksOf:()=>oc,concat:()=>i0,concatAll:()=>lc,concatW:()=>iX,cons:()=>lO,copy:()=>i8,duplicate:()=>oA,extend:()=>oE,extract:()=>oN,filter:()=>lv,filterWithIndex:()=>lW,flap:()=>o$,flatMap:()=>ox,flatten:()=>oS,fold:()=>lx,foldMap:()=>oi,foldMapWithIndex:()=>on,fromArray:()=>iJ,fromReadonlyNonEmptyArray:()=>i$,getEq:()=>oB,getSemigroup:()=>oz,getShow:()=>oP,getUnionSemigroup:()=>oD,group:()=>i2,groupBy:()=>i3,groupSort:()=>lR,head:()=>la,init:()=>lo,insertAt:()=>i5,intercalate:()=>lI,intersperse:()=>oa,isNonEmpty:()=>iq,isOutOfBound:()=>i_,last:()=>li,let:()=>le,makeBy:()=>iH,map:()=>oF,mapWithIndex:()=>oT,matchLeft:()=>lu,matchRight:()=>lf,max:()=>lp,min:()=>ll,modifyAt:()=>i6,modifyHead:()=>ld,modifyLast:()=>ls,nonEmptyArray:()=>lE,of:()=>i9,prepend:()=>ij,prependAll:()=>or,prependToAll:()=>lb,prependW:()=>iK,range:()=>iY,reduce:()=>ow,reduceRight:()=>oq,reduceRightWithIndex:()=>o_,reduceWithIndex:()=>ok,replicate:()=>iZ,reverse:()=>i1,rotate:()=>iV,sequence:()=>oj,snoc:()=>lU,sort:()=>i4,sortBy:()=>iB,splitAt:()=>op,tail:()=>ln,traverse:()=>oK,traverseWithIndex:()=>oL,unappend:()=>iQ,uncons:()=>lM,union:()=>iD,uniq:()=>iz,unprepend:()=>iG,unsafeInsertAt:()=>iC,unsafeUpdateAt:()=>iP,unsnoc:()=>ly,unzip:()=>ot,updateAt:()=>i7,updateHead:()=>lh,updateLast:()=>lm,zip:()=>function e(t,r){return void 0===r?r=>e(r,t):oe(t,r,(e,t)=>[e,t])},zipWith:()=>oe});// NAMESPACE OBJECT: ./src/Option.ts
var eu={};e.r(eu),e.d(eu,{Alt:()=>s8,Alternative:()=>mr,ApT:()=>m3,Applicative:()=>sG,Apply:()=>sY,Chain:()=>sX,Compactable:()=>mp,Do:()=>mQ,Extend:()=>mn,Filterable:()=>mh,Foldable:()=>s4,FromEither:()=>mb,Functor:()=>sD,Monad:()=>s0,MonadThrow:()=>mO,Pointed:()=>sH,Traversable:()=>mI,URI:()=>sL,Witherable:()=>mM,Zero:()=>me,alt:()=>s6,altW:()=>s7,ap:()=>sZ,apFirst:()=>m_,apS:()=>m2,apSecond:()=>mK,as:()=>sV,asUnit:()=>s$,bind:()=>m1,bindTo:()=>mX,chain:()=>m9,chainEitherK:()=>mz,chainFirst:()=>Ie,chainFirstEitherK:()=>mB,chainNullableK:()=>mH,compact:()=>mi,duplicate:()=>mC,elem:()=>function e(t){return(r,a)=>{if(void 0===a){let a=e(t);return e=>a(r,e)}return!mE(a)&&t.equals(r,a.value)}},exists:()=>mG,extend:()=>ma,filter:()=>mc,filterMap:()=>mu,flap:()=>mq,flatMap:()=>sQ,flatten:()=>mj,fold:()=>mT,foldMap:()=>s2,foldW:()=>mS,fromEither:()=>mU,fromEitherK:()=>mP,fromNullable:()=>mD,fromNullableK:()=>mJ,fromPredicate:()=>sO,getApplyMonoid:()=>Ii,getApplySemigroup:()=>In,getEq:()=>sC,getFirstMonoid:()=>Io,getLastMonoid:()=>Il,getLeft:()=>sU,getMonoid:()=>sz,getOrElse:()=>mk,getOrElseW:()=>mw,getOrd:()=>sP,getRefinement:()=>It,getRight:()=>sb,getShow:()=>sN,guard:()=>mt,isNone:()=>mE,isSome:()=>mx,let:()=>m0,map:()=>sB,mapNullable:()=>Ir,match:()=>mF,matchW:()=>mA,none:()=>sM,of:()=>sJ,option:()=>Ia,orElse:()=>s5,partition:()=>mf,partitionMap:()=>md,reduce:()=>s1,reduceRight:()=>s3,separate:()=>ml,sequence:()=>mm,sequenceArray:()=>m8,some:()=>sy,tap:()=>mL,tapEither:()=>mN,throwError:()=>my,toNullable:()=>mZ,toUndefined:()=>mY,traverse:()=>ms,traverseArray:()=>m6,traverseArrayWithIndex:()=>m7,traverseReadonlyArrayWithIndex:()=>m5,traverseReadonlyNonEmptyArrayWithIndex:()=>m4,tryCatch:()=>mV,tryCatchK:()=>m$,wilt:()=>mW,wither:()=>mv,zero:()=>s9});// NAMESPACE OBJECT: ./src/OptionT.ts
var ef={};e.r(ef),e.d(ef,{alt:()=>U8,ap:()=>U5,chain:()=>U7,chainNullableK:()=>UY,chainOptionK:()=>UQ,flatMap:()=>U6,fromEither:()=>U0,fromF:()=>UJ,fromNullable:()=>UH,fromNullableK:()=>UZ,fromOptionK:()=>UG,fromPredicate:()=>UX,getOptionM:()=>U9,getOrElse:()=>U3,map:()=>U4,match:()=>U1,matchE:()=>U2,some:()=>UV,zero:()=>U$});// NAMESPACE OBJECT: ./src/Ord.ts
var ed={};e.r(ed),e.d(ed,{Contravariant:()=>rG,URI:()=>rH,between:()=>r6,clamp:()=>r7,contramap:()=>rJ,equals:()=>rX,equalsDefault:()=>rB,fromCompare:()=>rD,geq:()=>r3,getDualOrd:()=>r9,getMonoid:()=>rY,getSemigroup:()=>rZ,getTupleOrd:()=>r8,gt:()=>r1,leq:()=>r2,lt:()=>r0,max:()=>r5,min:()=>r4,ord:()=>ae,ordBoolean:()=>ar,ordDate:()=>ai,ordNumber:()=>an,ordString:()=>aa,reverse:()=>r$,trivial:()=>rQ,tuple:()=>rV});// NAMESPACE OBJECT: ./src/Ordering.ts
var eh={};e.r(eh),e.d(eh,{Eq:()=>Sr,Monoid:()=>Sn,Semigroup:()=>Sa,eqOrdering:()=>Sp,invert:()=>So,match:()=>Se,matchW:()=>A9,monoidOrdering:()=>Sc,reverse:()=>St,semigroupOrdering:()=>Sl,sign:()=>Si});// NAMESPACE OBJECT: ./src/Pointed.ts
var es={};e.r(es);// NAMESPACE OBJECT: ./src/Predicate.ts
var em={};e.r(em),e.d(em,{Contravariant:()=>sg,URI:()=>sd,and:()=>sW,contramap:()=>sf,getMonoidAll:()=>sI,getMonoidAny:()=>ss,getSemigroupAll:()=>sm,getSemigroupAny:()=>sh,not:()=>sR,or:()=>sv});// NAMESPACE OBJECT: ./src/Profunctor.ts
var eI={};e.r(eI);// NAMESPACE OBJECT: ./src/Random.ts
var eg={};e.r(eg),e.d(eg,{random:()=>Sj,randomBool:()=>SC,randomElem:()=>SP,randomInt:()=>SL,randomRange:()=>SN});// NAMESPACE OBJECT: ./src/Reader.ts
var eR={};e.r(eR),e.d(eR,{ApT:()=>Wg,Applicative:()=>Wr,Apply:()=>v6,Category:()=>Wl,Chain:()=>Wa,Choice:()=>Wc,Do:()=>Ws,Functor:()=>v4,Monad:()=>Wn,Pointed:()=>v7,Profunctor:()=>Wo,Strong:()=>Wp,URI:()=>v3,ap:()=>vV,apFirst:()=>v8,apFirstW:()=>v9,apS:()=>Wm,apSW:()=>WI,apSecond:()=>We,apSecondW:()=>Wt,apW:()=>vD,ask:()=>vq,asks:()=>v_,asksReader:()=>vL,asksReaderW:()=>vj,bind:()=>Wd,bindTo:()=>Wu,bindW:()=>Wh,chain:()=>WU,chainFirst:()=>Wb,chainFirstW:()=>Wx,chainW:()=>WO,compose:()=>vY,first:()=>vX,flap:()=>v5,flatMap:()=>vJ,flatten:()=>vZ,flattenW:()=>vH,getMonoid:()=>WS,getSemigroup:()=>WA,id:()=>vQ,left:()=>v1,let:()=>Wf,local:()=>vK,map:()=>vB,of:()=>v$,promap:()=>vG,reader:()=>WE,right:()=>v2,second:()=>v0,sequenceArray:()=>Wy,tap:()=>Wi,traverseArray:()=>WM,traverseArrayWithIndex:()=>WW,traverseReadonlyArrayWithIndex:()=>Wv,traverseReadonlyNonEmptyArrayWithIndex:()=>WR});// NAMESPACE OBJECT: ./src/ReaderEither.ts
var ev={};e.r(ev),e.d(ev,{Alt:()=>FB,ApT:()=>TI,Applicative:()=>Fq,Apply:()=>FS,Bifunctor:()=>Fz,Chain:()=>F_,Do:()=>Tc,FromEither:()=>Fj,FromReader:()=>FL,Functor:()=>FU,Monad:()=>FK,MonadThrow:()=>FZ,Pointed:()=>FA,URI:()=>Fv,alt:()=>FI,altW:()=>Fg,ap:()=>Fu,apFirst:()=>FF,apFirstW:()=>FT,apS:()=>Ts,apSW:()=>Tm,apSecond:()=>Fw,apSecondW:()=>Fk,apW:()=>Ff,as:()=>Fb,asUnit:()=>Fx,ask:()=>FD,asks:()=>FV,asksReaderEither:()=>S5,asksReaderEitherW:()=>S4,bimap:()=>Fl,bind:()=>Td,bindTo:()=>Tu,bindW:()=>Th,chain:()=>Ty,chainEitherK:()=>F9,chainEitherKW:()=>Te,chainFirst:()=>TU,chainFirstEitherK:()=>Tt,chainFirstEitherKW:()=>Tr,chainFirstReaderK:()=>FJ,chainFirstReaderKW:()=>FH,chainFirstW:()=>Tb,chainOptionK:()=>FQ,chainOptionKW:()=>FX,chainReaderK:()=>Ta,chainReaderKW:()=>Tn,chainW:()=>TO,filterOrElse:()=>To,filterOrElseW:()=>Tl,flap:()=>FE,flatMap:()=>Fh,flatMapEither:()=>F6,flatMapNullable:()=>F5,flatMapOption:()=>F7,flatMapReader:()=>F8,flatten:()=>Fm,flattenW:()=>Fs,fold:()=>SG,foldW:()=>SX,fromEither:()=>S$,fromEitherK:()=>Tp,fromOption:()=>FY,fromOptionK:()=>FG,fromPredicate:()=>Ti,fromReader:()=>SJ,fromReaderK:()=>F$,getAltReaderValidation:()=>FO,getApplicativeReaderValidation:()=>Fy,getApplyMonoid:()=>TF,getApplySemigroup:()=>TS,getCompactable:()=>FW,getFilterable:()=>FM,getOrElse:()=>S0,getOrElseW:()=>S1,getReaderValidation:()=>Tw,getSemigroup:()=>TT,left:()=>Sz,leftReader:()=>SV,let:()=>Tf,liftNullable:()=>F2,liftOption:()=>F3,local:()=>S3,map:()=>Fi,mapBoth:()=>Fo,mapError:()=>Fp,mapLeft:()=>Fc,match:()=>SH,matchE:()=>SY,matchEW:()=>SQ,matchW:()=>SZ,of:()=>Fd,orElse:()=>S7,orElseFirst:()=>Tx,orElseFirstW:()=>TE,orElseW:()=>S6,orLeft:()=>S9,orLeftW:()=>Fe,readerEither:()=>TA,right:()=>SB,rightReader:()=>SD,sequenceArray:()=>TM,swap:()=>Ft,tap:()=>FN,tapEither:()=>FC,tapError:()=>S8,tapReader:()=>FP,throwError:()=>FR,toUnion:()=>S2,traverseArray:()=>TW,traverseArrayWithIndex:()=>Tv,traverseReadonlyArrayWithIndex:()=>TR,traverseReadonlyNonEmptyArrayWithIndex:()=>Tg});// NAMESPACE OBJECT: ./src/ReaderIO.ts
var eW={};e.r(eW),e.d(eW,{ApT:()=>wA,Applicative:()=>we,Apply:()=>T6,Chain:()=>wt,Do:()=>wy,FromIO:()=>wn,FromReader:()=>wi,Functor:()=>T2,Monad:()=>wr,MonadIO:()=>wa,Pointed:()=>T7,URI:()=>T1,ap:()=>TZ,apFirst:()=>T8,apS:()=>wx,apSW:()=>wE,apSecond:()=>T9,apW:()=>TY,as:()=>T3,asUnit:()=>T4,ask:()=>wm,asks:()=>wI,asksReaderIO:()=>TV,asksReaderIOW:()=>TD,bind:()=>wU,bindTo:()=>wO,bindW:()=>wb,chain:()=>wq,chainFirst:()=>wK,chainFirstIOK:()=>ws,chainFirstReaderK:()=>wW,chainFirstReaderKW:()=>wM,chainFirstW:()=>wj,chainIOK:()=>wh,chainReaderK:()=>wR,chainReaderKW:()=>wv,chainW:()=>w_,flap:()=>T5,flatMap:()=>TQ,flatMapIO:()=>wl,flatMapReader:()=>wp,flatten:()=>T0,flattenW:()=>TX,fromIO:()=>Tz,fromIOK:()=>wd,fromReader:()=>TP,fromReaderK:()=>wg,local:()=>TB,map:()=>TH,of:()=>TG,sequenceArray:()=>wk,tap:()=>wc,tapIO:()=>wu,tapReader:()=>wf,traverseArray:()=>ww,traverseArrayWithIndex:()=>wT,traverseReadonlyArrayWithIndex:()=>wF,traverseReadonlyNonEmptyArrayWithIndex:()=>wS});// NAMESPACE OBJECT: ./src/ReaderT.ts
var eM={};e.r(eM),e.d(eM,{ap:()=>T_,chain:()=>TK,flatMap:()=>Tj,fromNaturalTransformation:()=>TN,fromReader:()=>TL,getReaderM:()=>TC,map:()=>Tq,of:()=>Tk});// NAMESPACE OBJECT: ./src/ReaderTask.ts
var ey={};e.r(ey),e.d(ey,{ApT:()=>qz,ApplicativePar:()=>k6,ApplicativeSeq:()=>k9,ApplyPar:()=>k2,ApplySeq:()=>k8,Chain:()=>qe,Do:()=>q_,FromIO:()=>qn,FromReader:()=>qo,FromTask:()=>qi,Functor:()=>kG,Monad:()=>qt,MonadIO:()=>qr,MonadTask:()=>qa,Pointed:()=>k1,URI:()=>kY,ap:()=>kD,apFirst:()=>k3,apFirstW:()=>k4,apS:()=>qC,apSW:()=>qP,apSecond:()=>k5,apSecondW:()=>k7,apW:()=>kV,as:()=>kQ,asUnit:()=>kX,ask:()=>qW,asks:()=>qM,asksReaderTask:()=>kN,asksReaderTaskW:()=>kL,bind:()=>qL,bindTo:()=>qK,bindW:()=>qN,chain:()=>qQ,chainFirst:()=>q0,chainFirstIOK:()=>qv,chainFirstReaderIOK:()=>qT,chainFirstReaderIOKW:()=>qF,chainFirstReaderK:()=>qb,chainFirstReaderKW:()=>qx,chainFirstTaskK:()=>qq,chainFirstW:()=>q1,chainIOK:()=>qR,chainReaderIOK:()=>qS,chainReaderIOKW:()=>qA,chainReaderK:()=>qO,chainReaderKW:()=>qU,chainTaskK:()=>qk,chainW:()=>qX,flap:()=>k0,flatMap:()=>kJ,flatMapIO:()=>qp,flatMapReader:()=>qu,flatMapReaderIO:()=>qf,flatMapTask:()=>qc,flatten:()=>kZ,flattenW:()=>kH,fromIO:()=>k_,fromIOK:()=>qg,fromReader:()=>kk,fromReaderIO:()=>kK,fromReaderIOK:()=>qE,fromReaderK:()=>qy,fromTask:()=>kq,fromTaskK:()=>qw,getMonoid:()=>q7,getSemigroup:()=>q5,let:()=>qj,local:()=>kj,map:()=>kB,of:()=>k$,readerTask:()=>q3,readerTaskSeq:()=>q4,run:()=>q6,sequenceArray:()=>qZ,sequenceSeqArray:()=>q2,tap:()=>qd,tapIO:()=>qh,tapReader:()=>qs,tapReaderIO:()=>qI,tapTask:()=>qm,traverseArray:()=>qH,traverseArrayWithIndex:()=>qJ,traverseReadonlyArrayWithIndex:()=>qD,traverseReadonlyArrayWithIndexSeq:()=>q$,traverseReadonlyNonEmptyArrayWithIndex:()=>qB,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>qV,traverseSeqArray:()=>qG,traverseSeqArrayWithIndex:()=>qY});// NAMESPACE OBJECT: ./src/ReaderTaskEither.ts
var eO={};e.r(eO),e.d(eO,{Alt:()=>L2,ApT:()=>N8,ApplicativePar:()=>Lq,ApplicativeSeq:()=>LK,ApplyPar:()=>LS,ApplySeq:()=>L_,Bifunctor:()=>L1,Chain:()=>Lj,Do:()=>N1,FromEither:()=>Lz,FromIO:()=>LB,FromReader:()=>LV,FromTask:()=>LD,Functor:()=>LU,Monad:()=>LL,MonadIO:()=>LN,MonadTask:()=>LC,MonadThrow:()=>LP,Pointed:()=>LA,URI:()=>Lv,alt:()=>LI,altW:()=>Lg,ap:()=>Lu,apFirst:()=>LF,apFirstW:()=>LT,apS:()=>N7,apSW:()=>N6,apSecond:()=>Lw,apSecondW:()=>Lk,apW:()=>Lf,as:()=>Lb,asUnit:()=>Lx,ask:()=>L3,asks:()=>L4,asksReaderTaskEither:()=>j1,asksReaderTaskEitherW:()=>j0,bimap:()=>Ll,bind:()=>N4,bindTo:()=>N2,bindW:()=>N5,bracket:()=>NX,bracketW:()=>N0,chain:()=>Cc,chainEitherK:()=>NE,chainEitherKW:()=>NA,chainFirst:()=>Cf,chainFirstEitherK:()=>NS,chainFirstEitherKW:()=>NF,chainFirstIOK:()=>NP,chainFirstReaderEitherK:()=>L9,chainFirstReaderEitherKW:()=>L8,chainFirstReaderIOK:()=>Nl,chainFirstReaderIOKW:()=>No,chainFirstReaderK:()=>L7,chainFirstReaderKW:()=>L6,chainFirstReaderTaskK:()=>Nn,chainFirstReaderTaskKW:()=>Na,chainFirstTaskEitherK:()=>Nt,chainFirstTaskEitherKW:()=>Ne,chainFirstTaskK:()=>ND,chainFirstW:()=>Cd,chainIOEitherK:()=>NY,chainIOEitherKW:()=>NZ,chainIOK:()=>NC,chainNullableK:()=>jQ,chainOptionK:()=>Nu,chainOptionKW:()=>Nf,chainReaderEitherK:()=>NQ,chainReaderEitherKW:()=>NG,chainReaderIOK:()=>NH,chainReaderIOKW:()=>NJ,chainReaderK:()=>NV,chainReaderKW:()=>N$,chainReaderTaskK:()=>Nq,chainReaderTaskKW:()=>Nk,chainTaskEitherK:()=>Nw,chainTaskEitherKW:()=>NT,chainTaskK:()=>NB,chainW:()=>Cu,filterOrElse:()=>NK,filterOrElseW:()=>Nj,flap:()=>LE,flatMap:()=>Lh,flatMapEither:()=>NR,flatMapIO:()=>NM,flatMapIOEither:()=>Nb,flatMapNullable:()=>NI,flatMapOption:()=>Ng,flatMapReader:()=>NO,flatMapReaderEither:()=>Nx,flatMapReaderIO:()=>NU,flatMapReaderTask:()=>NW,flatMapTask:()=>Ny,flatMapTaskEither:()=>Nv,flatten:()=>Lm,flattenW:()=>Ls,fold:()=>jD,foldW:()=>j$,fromEither:()=>j_,fromEitherK:()=>NL,fromIO:()=>jj,fromIOEither:()=>jN,fromIOEitherK:()=>j8,fromIOK:()=>NN,fromNullable:()=>jY,fromNullableK:()=>jG,fromOption:()=>Np,fromOptionK:()=>Nc,fromPredicate:()=>N_,fromReader:()=>jK,fromReaderEither:()=>jC,fromReaderEitherK:()=>Le,fromReaderIOK:()=>Ni,fromReaderK:()=>L5,fromReaderTaskK:()=>Nr,fromTask:()=>jL,fromTaskEither:()=>jy,fromTaskEitherK:()=>j9,fromTaskK:()=>Nz,getAltReaderTaskValidation:()=>LO,getApplicativeReaderTaskValidation:()=>Ly,getApplyMonoid:()=>CR,getApplySemigroup:()=>Cg,getCompactable:()=>LW,getFilterable:()=>LM,getOrElse:()=>jJ,getOrElseW:()=>jH,getReaderTaskValidation:()=>CW,getSemigroup:()=>Cv,left:()=>jO,leftIO:()=>jw,leftReader:()=>jA,leftReaderIO:()=>jq,leftReaderTask:()=>jF,leftTask:()=>jx,let:()=>N3,liftNullable:()=>Nh,liftOption:()=>Ns,local:()=>jX,map:()=>Li,mapBoth:()=>Lo,mapError:()=>Lp,mapLeft:()=>Lc,match:()=>jP,matchE:()=>jB,matchEW:()=>jV,matchW:()=>jz,of:()=>Ld,orElse:()=>j2,orElseFirst:()=>Ch,orElseFirstW:()=>Cs,orElseW:()=>j3,orLeft:()=>j5,orLeftW:()=>j7,readerTaskEither:()=>Cm,readerTaskEitherSeq:()=>CI,right:()=>jU,rightIO:()=>jT,rightReader:()=>jE,rightReaderIO:()=>jk,rightReaderTask:()=>jS,rightTask:()=>jb,run:()=>CM,sequenceArray:()=>Ci,sequenceSeqArray:()=>Cp,swap:()=>j6,tap:()=>L$,tapEither:()=>LJ,tapError:()=>j4,tapIO:()=>LH,tapReader:()=>LY,tapReaderEither:()=>LG,tapReaderIO:()=>L0,tapReaderTask:()=>LX,tapTask:()=>LZ,tapTaskEither:()=>LQ,throwError:()=>LR,toUnion:()=>jZ,traverseArray:()=>Cn,traverseArrayWithIndex:()=>Ca,traverseReadonlyArrayWithIndex:()=>Ce,traverseReadonlyArrayWithIndexSeq:()=>Cr,traverseReadonlyNonEmptyArrayWithIndex:()=>N9,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>Ct,traverseSeqArray:()=>Cl,traverseSeqArrayWithIndex:()=>Co});// NAMESPACE OBJECT: ./src/ReadonlyArray.ts
var eU={};e.r(eU),e.d(eU,{Alt:()=>up,Alternative:()=>uf,Applicative:()=>ua,Apply:()=>ue,Chain:()=>un,ChainRecBreadthFirst:()=>uO,ChainRecDepthFirst:()=>uM,Compactable:()=>uh,Do:()=>uC,Extend:()=>ud,Filterable:()=>us,FilterableWithIndex:()=>um,Foldable:()=>uI,FoldableWithIndex:()=>ug,FromEither:()=>uA,Functor:()=>c7,FunctorWithIndex:()=>c9,Monad:()=>ui,Pointed:()=>c8,Traversable:()=>uR,TraversableWithIndex:()=>uv,URI:()=>cY,Unfoldable:()=>ul,Witherable:()=>ux,Zero:()=>uc,_chainRecBreadthFirst:()=>cI,_chainRecDepthFirst:()=>cm,alt:()=>cW,altW:()=>cv,ap:()=>cM,apFirst:()=>ut,apS:()=>uD,apSecond:()=>ur,append:()=>l3,appendW:()=>l4,bind:()=>uB,bindTo:()=>uP,chain:()=>uV,chainFirst:()=>uo,chainRecBreadthFirst:()=>uy,chainRecDepthFirst:()=>uW,chainWithIndex:()=>pp,chop:()=>pH,chunksOf:()=>pY,compact:()=>cF,comprehension:()=>pQ,concat:()=>p0,concatW:()=>pX,cons:()=>uJ,deleteAt:()=>pq,difference:()=>p3,dropLeft:()=>pO,dropLeftWhile:()=>pb,dropRight:()=>pU,duplicate:()=>cj,elem:()=>pV,empty:()=>u_,every:()=>uK,exists:()=>uL,extend:()=>cK,filter:()=>cE,filterE:()=>uE,filterMap:()=>cS,filterMapWithIndex:()=>cA,filterWithIndex:()=>c_,findFirst:()=>pE,findFirstMap:()=>pA,findIndex:()=>px,findLast:()=>pS,findLastIndex:()=>pT,findLastMap:()=>pF,flap:()=>c6,flatMap:()=>cy,flatten:()=>cO,foldLeft:()=>pn,foldMap:()=>cC,foldMapWithIndex:()=>cL,foldRight:()=>pl,fromArray:()=>uq,fromEither:()=>l9,fromEitherK:()=>uS,fromOption:()=>l8,fromOptionK:()=>pG,fromPredicate:()=>l6,getDifferenceMagma:()=>c5,getEq:()=>c0,getIntersectionSemigroup:()=>c4,getMonoid:()=>cX,getOrd:()=>c1,getSemigroup:()=>cQ,getShow:()=>cG,getUnionMonoid:()=>c3,getUnionSemigroup:()=>c2,guard:()=>uu,head:()=>ps,init:()=>pg,insertAt:()=>pw,intercalate:()=>uN,intersection:()=>p2,intersperse:()=>pB,isEmpty:()=>lX,isNonEmpty:()=>l0,isOutOfBound:()=>pd,last:()=>pm,lefts:()=>pL,let:()=>uz,lookup:()=>ph,makeBy:()=>l5,map:()=>cU,mapWithIndex:()=>cb,match:()=>pt,matchLeft:()=>pa,matchLeftW:()=>pr,matchRight:()=>po,matchRightW:()=>pi,matchW:()=>pe,modifyAt:()=>p_,of:()=>cg,partition:()=>cT,partitionMap:()=>ck,partitionMapWithIndex:()=>cq,partitionWithIndex:()=>cw,prepend:()=>l1,prependAll:()=>pz,prependToAll:()=>uZ,prependW:()=>l2,range:()=>u$,readonlyArray:()=>uY,reduce:()=>cN,reduceRight:()=>cz,reduceRightWithIndex:()=>cB,reduceWithIndex:()=>cP,replicate:()=>l7,reverse:()=>pK,rights:()=>pj,rotate:()=>pD,scanLeft:()=>pc,scanRight:()=>pu,separate:()=>cx,sequence:()=>cV,size:()=>pf,snoc:()=>uH,some:()=>uj,sort:()=>pN,sortBy:()=>pJ,spanLeft:()=>py,splitAt:()=>pZ,tail:()=>pI,takeLeft:()=>pR,takeLeftWhile:()=>pW,takeRight:()=>pv,toArray:()=>uk,traverse:()=>cD,traverseWithIndex:()=>c$,unfold:()=>cZ,union:()=>p1,uniq:()=>p$,unsafeDeleteAt:()=>uw,unsafeInsertAt:()=>uF,unsafeUpdateAt:()=>uT,unzip:()=>pP,updateAt:()=>pk,wilt:()=>cH,wither:()=>cJ,zero:()=>cR,zip:()=>function e(t,r){return void 0===r?r=>e(r,t):pC(t,r,(e,t)=>[e,t])},zipWith:()=>pC});// NAMESPACE OBJECT: ./src/ReadonlyMap.ts
var eb={};e.r(eb),e.d(eb,{Compactable:()=>EI,Filterable:()=>Eg,Functor:()=>Eh,URI:()=>El,collect:()=>xk,compact:()=>x9,deleteAt:()=>xj,difference:()=>ET,elem:()=>xF,empty:()=>xD,filter:()=>Ee,filterMap:()=>Et,filterMapWithIndex:()=>xQ,filterWithIndex:()=>xX,flap:()=>Es,foldMap:()=>Ev,foldMapWithIndex:()=>EO,fromFoldable:()=>xH,fromMap:()=>xU,getDifferenceMagma:()=>Ef,getEq:()=>xV,getFilterableWithIndex:()=>Ed,getFoldable:()=>EM,getFoldableWithIndex:()=>Eb,getFunctorWithIndex:()=>Em,getIntersectionSemigroup:()=>Eu,getMonoid:()=>x$,getShow:()=>xx,getTraversable:()=>Ex,getTraversableWithIndex:()=>EE,getUnionMonoid:()=>Ec,getUnionSemigroup:()=>Ep,getWitherable:()=>EA,insertAt:()=>Ew,intersection:()=>EF,isEmpty:()=>xA,isSubmap:()=>xB,keys:()=>xT,lookup:()=>xz,lookupWithKey:()=>xP,map:()=>Er,mapWithIndex:()=>Ea,member:()=>xS,modifyAt:()=>xN,partition:()=>En,partitionMap:()=>Ei,partitionMapWithIndex:()=>xY,partitionWithIndex:()=>xG,pop:()=>xC,readonlyMap:()=>Ek,reduce:()=>ER,reduceRight:()=>EW,reduceRightWithIndex:()=>EU,reduceWithIndex:()=>Ey,separate:()=>Eo,singleton:()=>xJ,size:()=>xE,toMap:()=>xb,toReadonlyArray:()=>xq,toUnfoldable:()=>x_,union:()=>ES,updateAt:()=>xL,upsertAt:()=>xK,values:()=>xw});// NAMESPACE OBJECT: ./src/ReadonlyNonEmptyArray.ts
var ex={};e.r(ex),e.d(ex,{Alt:()=>n9,Applicative:()=>n1,Apply:()=>nQ,Chain:()=>n2,Comonad:()=>ie,Do:()=>it,Foldable:()=>n5,FoldableWithIndex:()=>n7,Functor:()=>nH,FunctorWithIndex:()=>nG,Monad:()=>n4,Pointed:()=>nY,Traversable:()=>n6,TraversableWithIndex:()=>n8,URI:()=>nB,alt:()=>nb,altW:()=>nU,ap:()=>nx,apFirst:()=>nX,apS:()=>io,apSecond:()=>n0,append:()=>aD,appendW:()=>aB,bind:()=>ii,bindTo:()=>ir,chain:()=>iy,chainFirst:()=>n3,chainWithIndex:()=>no,chop:()=>nl,chunksOf:()=>nc,concat:()=>a5,concatAll:()=>is,concatW:()=>a4,cons:()=>iA,duplicate:()=>nS,empty:()=>aL,extend:()=>nA,extract:()=>nz,filter:()=>iU,filterWithIndex:()=>ib,flap:()=>nZ,flatMap:()=>nE,flatten:()=>nF,fold:()=>iw,foldMap:()=>nq,foldMapWithIndex:()=>nj,fromArray:()=>a3,fromReadonlyArray:()=>aG,getEq:()=>n$,getSemigroup:()=>nV,getShow:()=>nD,getUnionSemigroup:()=>nJ,group:()=>a6,groupBy:()=>a8,groupSort:()=>iO,head:()=>il,init:()=>iu,insertAt:()=>iF,intercalate:()=>iM,intersperse:()=>ni,isNonEmpty:()=>aN,isOutOfBound:()=>aC,last:()=>ic,let:()=>ia,makeBy:()=>aQ,map:()=>nT,mapWithIndex:()=>nw,matchLeft:()=>im,matchRight:()=>iI,max:()=>ih,min:()=>id,modifyAt:()=>nt,modifyHead:()=>ig,modifyLast:()=>iv,of:()=>nO,prepend:()=>az,prependAll:()=>nn,prependToAll:()=>iT,prependW:()=>aP,range:()=>a0,readonlyNonEmptyArray:()=>ik,reduce:()=>nk,reduceRight:()=>n_,reduceRightWithIndex:()=>nL,reduceWithIndex:()=>nK,replicate:()=>aX,reverse:()=>a7,rotate:()=>aY,sequence:()=>nC,snoc:()=>iS,sort:()=>a9,sortBy:()=>aH,splitAt:()=>np,tail:()=>ip,traverse:()=>nN,traverseWithIndex:()=>nP,unappend:()=>a2,uncons:()=>ix,union:()=>aZ,uniq:()=>aJ,unprepend:()=>a1,unsafeInsertAt:()=>aV,unsafeUpdateAt:()=>a$,unsnoc:()=>iE,unzip:()=>na,updateAt:()=>ne,updateHead:()=>iR,updateLast:()=>iW,zip:()=>function e(t,r){return void 0===r?r=>e(r,t):nr(t,r,(e,t)=>[e,t])},zipWith:()=>nr});// NAMESPACE OBJECT: ./src/ReadonlyRecord.ts
var eE={};e.r(eE),e.d(eE,{Compactable:()=>P4,Filterable:()=>P5,FilterableWithIndex:()=>P7,Foldable:()=>zn,FoldableWithIndex:()=>zi,Functor:()=>PX,FunctorWithIndex:()=>P1,Traversable:()=>zo,TraversableWithIndex:()=>zl,URI:()=>PZ,Witherable:()=>zu,_filter:()=>Px,_filterMap:()=>PE,_filterMapWithIndex:()=>P_,_filterWithIndex:()=>PK,_foldMap:()=>PU,_foldMapWithIndex:()=>PT,_map:()=>PM,_mapWithIndex:()=>Py,_partition:()=>PA,_partitionMap:()=>PS,_partitionMapWithIndex:()=>Pk,_partitionWithIndex:()=>Pq,_reduce:()=>PO,_reduceRight:()=>Pb,_reduceRightWithIndex:()=>Pw,_reduceWithIndex:()=>PF,_sequence:()=>PL,_traverse:()=>Pj,collect:()=>CH,compact:()=>PJ,deleteAt:()=>CX,difference:()=>PW,elem:()=>Pg,empty:()=>C5,every:()=>Pm,filter:()=>PC,filterMap:()=>PP,filterMapWithIndex:()=>Pc,filterWithIndex:()=>Pu,flap:()=>P0,foldMap:()=>PV,foldMapWithIndex:()=>C9,fromEntries:()=>Ps,fromFoldable:()=>Pf,fromFoldableMap:()=>Pd,fromRecord:()=>Cz,getDifferenceMagma:()=>za,getEq:()=>PG,getFoldable:()=>P2,getFoldableWithIndex:()=>P3,getIntersectionSemigroup:()=>zr,getMonoid:()=>PQ,getShow:()=>PY,getTraversable:()=>P6,getTraversableWithIndex:()=>P8,getUnionMonoid:()=>zt,getUnionSemigroup:()=>ze,getWitherable:()=>P9,has:()=>CQ,hasOwnProperty:()=>zd,insertAt:()=>zf,intersection:()=>Pv,isEmpty:()=>CV,isSubrecord:()=>C3,keys:()=>CJ,lookup:()=>C4,map:()=>C6,mapWithIndex:()=>C7,modifyAt:()=>C1,partition:()=>Pz,partitionMap:()=>PB,partitionMapWithIndex:()=>Pl,partitionWithIndex:()=>Pp,pop:()=>C2,readonlyRecord:()=>zh,reduce:()=>PD,reduceRight:()=>P$,reduceRightWithIndex:()=>Pe,reduceWithIndex:()=>C8,separate:()=>PH,sequence:()=>Pn,singleton:()=>Pt,size:()=>CD,some:()=>PI,toEntries:()=>Ph,toReadonlyArray:()=>CZ,toRecord:()=>CB,toUnfoldable:()=>CY,traverse:()=>Pa,traverseWithIndex:()=>Pr,union:()=>PR,updateAt:()=>C0,upsertAt:()=>CG,wilt:()=>Po,wither:()=>Pi});// NAMESPACE OBJECT: ./src/ReadonlySet.ts
var eA={};e.r(eA),e.d(eA,{URI:()=>zB,chain:()=>zv,compact:()=>zw,difference:()=>zb,elem:()=>zP,empty:()=>z_,every:()=>zN,filter:()=>zW,filterMap:()=>zq,foldMap:()=>zE,fromArray:()=>zY,fromReadonlyArray:()=>zI,fromSet:()=>zs,getDifferenceMagma:()=>zZ,getEq:()=>zV,getIntersectionSemigroup:()=>zH,getShow:()=>zD,getUnionMonoid:()=>zJ,getUnionSemigroup:()=>z$,insert:()=>zS,intersection:()=>zO,isEmpty:()=>zK,isSubset:()=>zC,map:()=>zR,partition:()=>zM,partitionMap:()=>zU,reduce:()=>zx,reduceRight:()=>zA,remove:()=>zF,separate:()=>zk,singleton:()=>zm,size:()=>zj,some:()=>zL,toReadonlyArray:()=>zz,toSet:()=>zg,toggle:()=>zT,union:()=>zy});// NAMESPACE OBJECT: ./src/ReadonlyTuple.ts
var eS={};e.r(eS),e.d(eS,{Bifunctor:()=>By,Comonad:()=>BU,Foldable:()=>Bb,Functor:()=>BR,Semigroupoid:()=>BO,Traversable:()=>Bx,URI:()=>Bg,bimap:()=>Bi,compose:()=>Bp,duplicate:()=>Bf,extend:()=>Bc,extract:()=>Bu,flap:()=>Bv,foldMap:()=>Bh,fst:()=>zG,getApplicative:()=>z2,getApply:()=>z0,getChain:()=>z3,getChainRec:()=>z5,getMonad:()=>z4,map:()=>BW,mapFst:()=>Bo,mapLeft:()=>BM,mapSnd:()=>Bl,readonlyTuple:()=>BE,reduce:()=>Bd,reduceRight:()=>Bs,sequence:()=>BI,snd:()=>zQ,swap:()=>zX,traverse:()=>Bm});// NAMESPACE OBJECT: ./src/Record.ts
var eF={};e.r(eF),e.d(eF,{Compactable:()=>DU,Filterable:()=>Db,FilterableWithIndex:()=>Dx,Foldable:()=>Dq,FoldableWithIndex:()=>D_,Functor:()=>Dv,FunctorWithIndex:()=>DM,Traversable:()=>DK,TraversableWithIndex:()=>Dj,URI:()=>Dm,Witherable:()=>DC,collect:()=>Bk,compact:()=>Dh,deleteAt:()=>BL,difference:()=>Dn,elem:()=>Dt,empty:()=>DP,every:()=>B9,filter:()=>Do,filterMap:()=>Dl,filterMapWithIndex:()=>B3,filterWithIndex:()=>B4,flap:()=>DW,foldMap:()=>Df,foldMapWithIndex:()=>BJ,fromEntries:()=>B6,fromFoldable:()=>B5,fromFoldableMap:()=>B8,getDifferenceMagma:()=>Dk,getEq:()=>Dg,getFoldable:()=>Dy,getFoldableWithIndex:()=>DO,getIntersectionSemigroup:()=>Dw,getMonoid:()=>DR,getShow:()=>DI,getTraversable:()=>DE,getTraversableWithIndex:()=>DA,getUnionMonoid:()=>DT,getUnionSemigroup:()=>DF,getWitherable:()=>DS,has:()=>Bj,hasOwnProperty:()=>DB,insertAt:()=>Dz,intersection:()=>Da,isEmpty:()=>BF,isSubrecord:()=>Bz,keys:()=>Bw,lookup:()=>BB,map:()=>BV,mapWithIndex:()=>BD,modifyAt:()=>BC,partition:()=>Dp,partitionMap:()=>Dc,partitionMapWithIndex:()=>B1,partitionWithIndex:()=>B2,pop:()=>BP,record:()=>DD,reduce:()=>Du,reduceRight:()=>Dd,reduceRightWithIndex:()=>BH,reduceWithIndex:()=>B$,separate:()=>Ds,sequence:()=>BQ,singleton:()=>BZ,size:()=>BS,some:()=>De,toArray:()=>Bq,toEntries:()=>B7,toUnfoldable:()=>B_,traverse:()=>BG,traverseWithIndex:()=>BY,union:()=>Dr,updateAt:()=>BN,upsertAt:()=>BK,wilt:()=>B0,wither:()=>BX});// NAMESPACE OBJECT: ./src/Refinement.ts
var eT={};e.r(eT),e.d(eT,{and:()=>DY,compose:()=>DQ,fromEitherK:()=>D$,fromOptionK:()=>DV,id:()=>DJ,not:()=>DH,or:()=>DZ,zero:()=>DG});// NAMESPACE OBJECT: ./src/Ring.ts
var ew={};e.r(ew),e.d(ew,{getFunctionRing:()=>D2,getTupleRing:()=>D1,negate:()=>D0,tuple:()=>DX});// NAMESPACE OBJECT: ./src/Semigroup.ts
var ek={};e.r(ek),e.d(ek,{concatAll:()=>aW,constant:()=>ah,first:()=>aR,fold:()=>aT,getDualSemigroup:()=>aE,getFirstSemigroup:()=>aU,getFunctionSemigroup:()=>aq,getIntercalateSemigroup:()=>aF,getJoinSemigroup:()=>aA,getLastSemigroup:()=>aO,getMeetSemigroup:()=>aS,getObjectSemigroup:()=>ay,getStructSemigroup:()=>ax,getTupleSemigroup:()=>ab,intercalate:()=>ag,last:()=>av,max:()=>ad,min:()=>af,reverse:()=>as,semigroupAll:()=>aw,semigroupAny:()=>ak,semigroupProduct:()=>aj,semigroupString:()=>a_,semigroupSum:()=>aK,semigroupVoid:()=>aM,struct:()=>am,tuple:()=>aI});// NAMESPACE OBJECT: ./src/Semigroupoid.ts
var eq={};e.r(eq);// NAMESPACE OBJECT: ./src/Semiring.ts
var e_={};e.r(e_),e.d(e_,{getFunctionSemiring:()=>D3});// NAMESPACE OBJECT: ./src/Separated.ts
var eK={};e.r(eK),e.d(eK,{Bifunctor:()=>lD,Functor:()=>lV,URI:()=>lB,bimap:()=>lz,flap:()=>l$,left:()=>lJ,map:()=>lC,mapLeft:()=>lP,right:()=>lH,separated:()=>lN});// NAMESPACE OBJECT: ./src/Set.ts
var ej={};e.r(ej),e.d(ej,{chain:()=>D6,compact:()=>VI,difference:()=>Va,elem:()=>Vb,empty:()=>Vv,every:()=>VO,filter:()=>D8,filterMap:()=>VR,foldMap:()=>Vc,fromArray:()=>Vm,getDifferenceMagma:()=>Vl,getEq:()=>D5,getIntersectionSemigroup:()=>Vo,getShow:()=>D4,getUnionMonoid:()=>Vi,getUnionSemigroup:()=>Vn,insert:()=>Vd,intersection:()=>Vt,isEmpty:()=>VW,isSubset:()=>VU,map:()=>D7,partition:()=>D9,partitionMap:()=>Vr,reduce:()=>Vp,reduceRight:()=>Vu,remove:()=>Vh,separate:()=>Vg,singleton:()=>Vf,size:()=>VM,some:()=>Vy,subset:()=>VE,toArray:()=>Vx,toggle:()=>Vs,union:()=>Ve});// NAMESPACE OBJECT: ./src/Show.ts
var eL={};e.r(eL),e.d(eL,{getStructShow:()=>VT,getTupleShow:()=>VF,showBoolean:()=>Vw,showNumber:()=>Vq,showString:()=>Vk,struct:()=>VA,tuple:()=>VS});// NAMESPACE OBJECT: ./src/State.ts
var eN={};e.r(eN),e.d(eN,{Applicative:()=>W0,Apply:()=>WG,Chain:()=>W1,FromState:()=>W4,Functor:()=>WH,Monad:()=>W2,Pointed:()=>WY,URI:()=>WJ,ap:()=>WB,apFirst:()=>WQ,apS:()=>Me,apSecond:()=>WX,bind:()=>W9,bindTo:()=>W6,chain:()=>Mo,chainFirst:()=>Ml,evalState:()=>Mp,evaluate:()=>W5,execState:()=>Mc,execute:()=>W7,flap:()=>WZ,flatMap:()=>WV,flatten:()=>W$,get:()=>WK,gets:()=>WN,let:()=>W8,map:()=>Wz,modify:()=>WL,of:()=>WD,put:()=>Wj,sequenceArray:()=>Mi,state:()=>Mu,tap:()=>W3,traverseArray:()=>Mn,traverseArrayWithIndex:()=>Ma,traverseReadonlyArrayWithIndex:()=>Mr,traverseReadonlyNonEmptyArrayWithIndex:()=>Mt});// NAMESPACE OBJECT: ./src/StateReaderTaskEither.ts
var eC={};e.r(eC),e.d(eC,{Alt:()=>Jo,Applicative:()=>$J,Apply:()=>$z,Bifunctor:()=>Ji,Chain:()=>$H,FromEither:()=>$7,FromIO:()=>$6,FromReader:()=>$9,FromState:()=>$Z,FromTask:()=>$8,Functor:()=>$j,Monad:()=>$2,MonadIO:()=>$3,MonadTask:()=>$4,MonadThrow:()=>$5,Pointed:()=>$P,URI:()=>$K,alt:()=>$q,altW:()=>$k,ap:()=>$I,apFirst:()=>$B,apFirstW:()=>$D,apS:()=>Jz,apSW:()=>JB,apSecond:()=>$V,apSecondW:()=>$$,apW:()=>$g,as:()=>$L,asUnit:()=>$N,ask:()=>Jl,asks:()=>Jp,asksStateReaderTaskEither:()=>$r,asksStateReaderTaskEitherW:()=>$t,bimap:()=>$s,bind:()=>JC,bindTo:()=>JL,bindW:()=>JP,chain:()=>JZ,chainEitherK:()=>JR,chainEitherKW:()=>Jv,chainFirst:()=>JG,chainFirstEitherK:()=>JW,chainFirstEitherKW:()=>JM,chainFirstIOK:()=>JA,chainFirstReaderK:()=>Jd,chainFirstReaderKW:()=>Jh,chainFirstTaskK:()=>J_,chainFirstW:()=>JQ,chainIOEitherK:()=>Jw,chainIOEitherKW:()=>JT,chainIOK:()=>JE,chainOptionK:()=>JI,chainOptionKW:()=>Jg,chainReaderK:()=>Ju,chainReaderKW:()=>Jf,chainReaderTaskEitherK:()=>$l,chainReaderTaskEitherKW:()=>$o,chainStateK:()=>$1,chainTaskEitherK:()=>JF,chainTaskEitherKW:()=>JS,chainTaskK:()=>Jq,chainW:()=>JY,evalState:()=>J1,evaluate:()=>JK,execState:()=>J2,execute:()=>Jj,filterOrElse:()=>JO,filterOrElseW:()=>JU,flap:()=>$C,flatMap:()=>$W,flatMapEither:()=>$E,flatMapIO:()=>$O,flatMapIOEither:()=>$x,flatMapOption:()=>$A,flatMapReader:()=>$b,flatMapReaderTaskEither:()=>$S,flatMapState:()=>$F,flatMapTask:()=>$U,flatMapTaskEither:()=>$y,flatten:()=>$w,flattenW:()=>$T,fromEither:()=>V1,fromEitherK:()=>Jb,fromIO:()=>V3,fromIOEither:()=>V6,fromIOEitherK:()=>$a,fromIOK:()=>Jx,fromOption:()=>Js,fromOptionK:()=>Jm,fromPredicate:()=>Jy,fromReader:()=>V2,fromReaderEither:()=>V8,fromReaderK:()=>Jc,fromReaderTaskEither:()=>V9,fromReaderTaskEitherK:()=>$i,fromState:()=>V5,fromStateK:()=>$0,fromTask:()=>V4,fromTaskEither:()=>V7,fromTaskEitherK:()=>$n,fromTaskK:()=>Jk,get:()=>$Y,gets:()=>$X,left:()=>VV,leftIO:()=>VQ,leftReader:()=>VY,leftState:()=>V0,leftTask:()=>VH,let:()=>JN,local:()=>$e,map:()=>$h,mapLeft:()=>$m,modify:()=>$Q,of:()=>$R,put:()=>$G,right:()=>V$,rightIO:()=>VG,rightReader:()=>VZ,rightState:()=>VX,rightTask:()=>VJ,run:()=>J3,sequenceArray:()=>JH,stateReaderTaskEither:()=>JX,stateReaderTaskEitherSeq:()=>J0,tap:()=>Je,tapEither:()=>Jt,tapIO:()=>Jr,tapReader:()=>Jn,tapTask:()=>Ja,throwError:()=>$_,traverseArray:()=>JJ,traverseArrayWithIndex:()=>J$,traverseReadonlyArrayWithIndex:()=>JV,traverseReadonlyNonEmptyArrayWithIndex:()=>JD});// NAMESPACE OBJECT: ./src/StateT.ts
var eP={};e.r(eP),e.d(eP,{ap:()=>Vj,chain:()=>VL,evaluate:()=>Vz,execute:()=>VB,flatMap:()=>VN,fromF:()=>VP,fromState:()=>VC,getStateM:()=>VD,map:()=>VK,of:()=>V_});// NAMESPACE OBJECT: ./src/Store.ts
var ez={};e.r(ez),e.d(ez,{Comonad:()=>Ho,Functor:()=>Hn,URI:()=>Ha,duplicate:()=>Ht,experiment:()=>J6,extend:()=>J9,extract:()=>He,flap:()=>Hi,map:()=>Hr,peeks:()=>J7,seek:()=>J4,seeks:()=>J5,store:()=>Hl});// NAMESPACE OBJECT: ./src/Strong.ts
var eB={};e.r(eB),e.d(eB,{fanOut:()=>Hc,fanout:()=>Hf,split:()=>Hp,splitStrong:()=>Hu});// NAMESPACE OBJECT: ./src/Task.ts
var eD={};e.r(eD),e.d(eD,{ApT:()=>kI,ApplicativePar:()=>w4,ApplicativeSeq:()=>w7,ApplyPar:()=>w1,ApplySeq:()=>w5,Chain:()=>w6,Do:()=>kf,FromIO:()=>kr,FromTask:()=>kc,Functor:()=>wY,Monad:()=>w8,MonadIO:()=>w9,MonadTask:()=>kt,Pointed:()=>w0,URI:()=>wH,ap:()=>wD,apFirst:()=>w2,apS:()=>km,apSecond:()=>w3,as:()=>wG,asUnit:()=>wQ,bind:()=>ks,bindTo:()=>kd,chain:()=>kE,chainFirst:()=>kA,chainFirstIOK:()=>kp,chainIOK:()=>kl,delay:()=>wN,flap:()=>wX,flatMap:()=>w$,flatMapIO:()=>ka,flatten:()=>wJ,fromIO:()=>wL,fromIOK:()=>ko,fromTask:()=>ke,getMonoid:()=>kw,getRaceMonoid:()=>wZ,getSemigroup:()=>kT,let:()=>kh,map:()=>wB,never:()=>ku,of:()=>wV,sequenceArray:()=>kO,sequenceSeqArray:()=>kx,tap:()=>kn,tapIO:()=>ki,task:()=>kS,taskSeq:()=>kF,traverseArray:()=>ky,traverseArrayWithIndex:()=>kM,traverseReadonlyArrayWithIndex:()=>kR,traverseReadonlyArrayWithIndexSeq:()=>kW,traverseReadonlyNonEmptyArrayWithIndex:()=>kg,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>kv,traverseSeqArray:()=>kb,traverseSeqArrayWithIndex:()=>kU});// NAMESPACE OBJECT: ./src/TaskEither.ts
var eV={};e.r(eV),e.d(eV,{Alt:()=>KW,ApT:()=>K9,ApplicativePar:()=>Kn,ApplicativeSeq:()=>Ko,ApplyPar:()=>_9,ApplySeq:()=>Ki,Bifunctor:()=>Kv,Chain:()=>Kl,Do:()=>K2,FromEither:()=>Kd,FromIO:()=>Kh,FromTask:()=>Ks,Functor:()=>_4,Monad:()=>Kp,MonadIO:()=>Kc,MonadTask:()=>Ku,MonadThrow:()=>Kf,Pointed:()=>_8,URI:()=>_X,alt:()=>_Z,altW:()=>_Y,ap:()=>_D,apFirst:()=>Ke,apFirstW:()=>Kt,apS:()=>K6,apSW:()=>K8,apSecond:()=>Kr,apSecondW:()=>Ka,apW:()=>_V,as:()=>_5,asUnit:()=>_7,bimap:()=>_P,bind:()=>K5,bindTo:()=>K3,bindW:()=>K7,bracket:()=>K0,bracketW:()=>K1,chain:()=>ju,chainEitherK:()=>Kj,chainEitherKW:()=>KL,chainFirst:()=>jd,chainFirstEitherK:()=>KN,chainFirstEitherKW:()=>KC,chainFirstIOK:()=>KJ,chainFirstTaskK:()=>KY,chainFirstW:()=>jh,chainIOEitherK:()=>KQ,chainIOEitherKW:()=>KG,chainIOK:()=>K$,chainNullableK:()=>_O,chainOptionK:()=>KO,chainOptionKW:()=>KU,chainTaskK:()=>KZ,chainTaskOptionK:()=>_k,chainTaskOptionKW:()=>_w,chainW:()=>jf,filterOrElse:()=>Kz,filterOrElseW:()=>KB,flap:()=>_6,flatMap:()=>_$,flatMapEither:()=>Kw,flatMapIO:()=>Kk,flatMapIOEither:()=>K_,flatMapNullable:()=>KF,flatMapOption:()=>KT,flatMapTask:()=>Kq,flatMapTaskOption:()=>KK,flatten:()=>_H,flattenW:()=>_J,fold:()=>_h,foldW:()=>_m,fromEither:()=>_l,fromEitherK:()=>KD,fromIO:()=>_i,fromIOEither:()=>_p,fromIOEitherK:()=>_q,fromIOK:()=>KV,fromNullable:()=>_M,fromNullableK:()=>_y,fromOption:()=>KM,fromOptionK:()=>Ky,fromPredicate:()=>KP,fromTask:()=>_o,fromTaskK:()=>KH,fromTaskOption:()=>_c,fromTaskOptionK:()=>_T,getAltTaskValidation:()=>_1,getApplicativeTaskValidation:()=>_0,getApplyMonoid:()=>jv,getApplySemigroup:()=>jR,getCompactable:()=>_2,getFilterable:()=>_3,getOrElse:()=>_I,getOrElseW:()=>_g,getSemigroup:()=>jW,getTaskValidation:()=>jM,left:()=>q9,leftIO:()=>_n,leftTask:()=>_r,let:()=>K4,liftNullable:()=>Kx,liftOption:()=>KE,map:()=>_N,mapBoth:()=>_C,mapError:()=>_z,mapLeft:()=>_B,match:()=>_u,matchE:()=>_d,matchEW:()=>_s,matchW:()=>_f,of:()=>_G,orElse:()=>_U,orElseFirst:()=>js,orElseFirstIOK:()=>_E,orElseFirstTaskK:()=>_A,orElseFirstW:()=>jm,orElseW:()=>_b,orLeft:()=>_S,right:()=>_e,rightIO:()=>_a,rightTask:()=>_t,sequenceArray:()=>jo,sequenceSeqArray:()=>jc,swap:()=>_F,tap:()=>Km,tapEither:()=>KI,tapError:()=>_x,tapIO:()=>Kg,tapTask:()=>KR,taskEither:()=>jI,taskEitherSeq:()=>jg,taskify:()=>KX,throwError:()=>_Q,toUnion:()=>_W,traverseArray:()=>ji,traverseArrayWithIndex:()=>jn,traverseReadonlyArrayWithIndex:()=>jt,traverseReadonlyArrayWithIndexSeq:()=>ja,traverseReadonlyNonEmptyArrayWithIndex:()=>je,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>jr,traverseSeqArray:()=>jp,traverseSeqArrayWithIndex:()=>jl,tryCatch:()=>_R,tryCatchK:()=>_v});// NAMESPACE OBJECT: ./src/TaskOption.ts
var e$={};e.r(e$),e.d(e$,{Alt:()=>Zm,Alternative:()=>ZR,ApT:()=>ZL,ApplicativePar:()=>Za,ApplicativeSeq:()=>Zo,ApplyPar:()=>Ze,ApplySeq:()=>Zi,Chain:()=>Zl,Compactable:()=>Zy,Do:()=>Zk,Filterable:()=>ZO,FromEither:()=>Zp,FromIO:()=>Zc,FromTask:()=>Zu,Functor:()=>H5,Monad:()=>Zv,MonadIO:()=>ZW,MonadTask:()=>ZM,Pointed:()=>H9,URI:()=>H4,Zero:()=>ZI,alt:()=>HV,altW:()=>H$,ap:()=>HL,apFirst:()=>Zt,apS:()=>Zj,apSecond:()=>Zr,as:()=>H7,asUnit:()=>H6,bind:()=>ZK,bindTo:()=>Zq,chain:()=>ZZ,chainEitherK:()=>ZA,chainFirst:()=>ZY,chainFirstEitherK:()=>ZS,chainFirstIOK:()=>Zx,chainFirstTaskK:()=>Zw,chainIOK:()=>Zb,chainNullableK:()=>Hq,chainOptionK:()=>HK,chainTaskK:()=>ZT,compact:()=>HZ,filter:()=>HG,filterMap:()=>HQ,flap:()=>H8,flatMap:()=>HC,flatMapIO:()=>Hz,flatMapTask:()=>HB,flatten:()=>HD,fold:()=>Hb,foldW:()=>HE,fromEither:()=>HR,fromEitherK:()=>ZE,fromIO:()=>Hv,fromIOK:()=>ZU,fromNullable:()=>HF,fromNullableK:()=>Hk,fromOption:()=>Hg,fromOptionK:()=>H_,fromPredicate:()=>HI,fromTask:()=>HW,fromTaskEither:()=>HM,fromTaskK:()=>ZF,getOrElse:()=>HA,getOrElseW:()=>HS,guard:()=>Zg,let:()=>Z_,map:()=>Hj,match:()=>Hy,matchE:()=>HU,matchEW:()=>Hx,matchW:()=>HO,none:()=>HH,of:()=>HN,partition:()=>HX,partitionMap:()=>H0,separate:()=>HY,sequenceArray:()=>ZV,sequenceSeqArray:()=>ZH,some:()=>Hm,tap:()=>Zf,tapEither:()=>Zd,tapIO:()=>Zh,tapTask:()=>Zs,traverseArray:()=>ZD,traverseArrayWithIndex:()=>ZB,traverseReadonlyArrayWithIndex:()=>ZC,traverseReadonlyArrayWithIndexSeq:()=>Zz,traverseReadonlyNonEmptyArrayWithIndex:()=>ZN,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>ZP,traverseSeqArray:()=>ZJ,traverseSeqArrayWithIndex:()=>Z$,tryCatch:()=>HT,tryCatchK:()=>Hw,zero:()=>HJ});// NAMESPACE OBJECT: ./src/TaskThese.ts
var eJ={};e.r(eJ),e.d(eJ,{ApT:()=>GV,Bifunctor:()=>Gk,FromEither:()=>Gq,FromIO:()=>GC,FromTask:()=>Gz,FromThese:()=>GL,Functor:()=>GF,Pointed:()=>Gw,URI:()=>Gb,bifunctorTaskThese:()=>GG,bimap:()=>Gy,both:()=>Gt,flap:()=>GT,fold:()=>Gs,foldW:()=>GI,fromEither:()=>Go,fromIO:()=>Gp,fromIOEither:()=>Gc,fromIOK:()=>GP,fromOption:()=>G_,fromOptionK:()=>GK,fromPredicate:()=>Gj,fromTask:()=>Gu,fromTaskK:()=>GB,fromThese:()=>Gl,fromTheseK:()=>GN,functorTaskThese:()=>GY,getApplicative:()=>GE,getApply:()=>Gx,getChain:()=>GA,getMonad:()=>GS,getSemigroup:()=>G0,left:()=>Y9,leftIO:()=>Gi,leftTask:()=>Ga,map:()=>GM,mapLeft:()=>GO,match:()=>Gf,matchE:()=>Gh,matchEW:()=>Gm,matchW:()=>Gd,of:()=>GU,right:()=>Ge,rightIO:()=>Gn,rightTask:()=>Gr,swap:()=>Gg,taskThese:()=>GX,toTuple:()=>GQ,toTuple2:()=>GD,traverseReadonlyArrayWithIndex:()=>GJ,traverseReadonlyArrayWithIndexSeq:()=>GZ,traverseReadonlyNonEmptyArrayWithIndex:()=>G$,traverseReadonlyNonEmptyArrayWithIndexSeq:()=>GH});// NAMESPACE OBJECT: ./src/These.ts
var eH={};e.r(eH),e.d(eH,{ApT:()=>YD,Bifunctor:()=>Yw,Foldable:()=>Yq,FromEither:()=>YK,FromThese:()=>Yk,Functor:()=>YS,Pointed:()=>YT,Traversable:()=>Y_,URI:()=>YA,bimap:()=>Yv,both:()=>Z2,elem:()=>YC,exists:()=>YP,flap:()=>YF,fold:()=>Z7,foldMap:()=>YO,foldW:()=>Z4,fromOption:()=>YL,fromOptionK:()=>YN,fromOptions:()=>Yf,fromPredicate:()=>Yj,getApplicative:()=>Yr,getApply:()=>Yt,getChain:()=>Ya,getEq:()=>Z9,getLeft:()=>Yi,getLeftOnly:()=>Yc,getMonad:()=>Yn,getRight:()=>Yo,getRightOnly:()=>Yu,getSemigroup:()=>Ye,getShow:()=>Z8,isBoth:()=>ZX,isLeft:()=>ZG,isRight:()=>ZQ,left:()=>Z0,leftOrBoth:()=>Yl,map:()=>YM,mapLeft:()=>YW,match:()=>Z5,matchW:()=>Z3,of:()=>YE,reduce:()=>Yy,reduceRight:()=>YU,right:()=>Z1,rightOrBoth:()=>Yp,sequence:()=>Yx,swap:()=>Z6,these:()=>YJ,toTuple:()=>YB,toTuple2:()=>Yz,traverse:()=>Yb,traverseReadonlyArrayWithIndex:()=>Y$,traverseReadonlyNonEmptyArrayWithIndex:()=>YV});// NAMESPACE OBJECT: ./src/TheseT.ts
var eZ={};e.r(eZ),e.d(eZ,{ap:()=>Y0,bimap:()=>Y2,both:()=>YY,chain:()=>Y1,getTheseM:()=>Y8,left:()=>YZ,leftF:()=>YQ,map:()=>YX,mapLeft:()=>Y3,match:()=>Y4,matchE:()=>Y5,right:()=>YH,rightF:()=>YG,swap:()=>Y7,toTuple2:()=>Y6});// NAMESPACE OBJECT: ./src/Traced.ts
var eY={};e.r(eY),e.d(eY,{Functor:()=>G9,URI:()=>G8,censor:()=>G4,flap:()=>Qe,getComonad:()=>G5,listen:()=>G2,listens:()=>G3,map:()=>G6,traced:()=>Qt,tracks:()=>G1});// NAMESPACE OBJECT: ./src/Traversable.ts
var eG={};e.r(eG),e.d(eG,{getTraversableComposition:()=>Qn,sequence:()=>Qa,traverse:()=>Qr});// NAMESPACE OBJECT: ./src/TraversableWithIndex.ts
var eQ={};e.r(eQ);// NAMESPACE OBJECT: ./src/Tree.ts
var eX={};e.r(eX),e.d(eX,{Applicative:()=>QB,Apply:()=>QC,Chain:()=>QD,Comonad:()=>QZ,Do:()=>QY,Foldable:()=>QJ,Functor:()=>Qj,Monad:()=>QV,Pointed:()=>QN,Traversable:()=>QH,URI:()=>QK,ap:()=>QO,apFirst:()=>QP,apS:()=>Q0,apSecond:()=>Qz,bind:()=>QX,bindTo:()=>QG,chain:()=>Q3,chainFirst:()=>Q$,drawForest:()=>Qc,drawTree:()=>Qu,duplicate:()=>Qx,elem:()=>Q1,exists:()=>Q2,extend:()=>Qb,extract:()=>Qw,flap:()=>QL,flatMap:()=>QU,flatten:()=>QE,fold:()=>Qm,foldMap:()=>QF,getEq:()=>Ql,getShow:()=>Qo,let:()=>QQ,make:()=>Qi,map:()=>QA,of:()=>Q_,reduce:()=>QS,reduceRight:()=>QT,sequence:()=>Qq,traverse:()=>Qk,tree:()=>Q4,unfoldForest:()=>Qd,unfoldForestM:()=>Qs,unfoldTree:()=>Qf,unfoldTreeM:()=>Qh});// NAMESPACE OBJECT: ./src/Tuple.ts
var e0={};e.r(e0),e.d(e0,{Bifunctor:()=>XA,Comonad:()=>XF,Foldable:()=>XT,Functor:()=>Xx,Semigroupoid:()=>XS,Traversable:()=>Xw,URI:()=>Xb,bimap:()=>Xh,compose:()=>XI,duplicate:()=>XR,extend:()=>Xg,extract:()=>Xv,flap:()=>XE,foldMap:()=>XW,fst:()=>Q5,getApplicative:()=>Xe,getApply:()=>Q8,getChain:()=>Xt,getChainRec:()=>Xa,getMonad:()=>Xr,map:()=>Xk,mapFst:()=>Xs,mapLeft:()=>Xq,mapSnd:()=>Xm,reduce:()=>XM,reduceRight:()=>Xy,sequence:()=>XU,snd:()=>Q7,swap:()=>Q6,traverse:()=>XO,tuple:()=>X_});// NAMESPACE OBJECT: ./src/Unfoldable.ts
var e1={};e.r(e1);// NAMESPACE OBJECT: ./src/ValidationT.ts
var e2={};e.r(e2),e.d(e2,{getValidationM:()=>XK});// NAMESPACE OBJECT: ./src/Witherable.ts
var e3={};e.r(e3),e.d(e3,{filterE:()=>lG,wiltDefault:()=>lZ,witherDefault:()=>lY});// NAMESPACE OBJECT: ./src/Writer.ts
var e4={};e.r(e4),e.d(e4,{Functor:()=>XQ,URI:()=>X$,censor:()=>XB,evalWriter:()=>X2,evaluate:()=>X0,execWriter:()=>X3,execute:()=>X1,flap:()=>XX,getApplicative:()=>XZ,getApply:()=>XH,getChain:()=>XY,getMonad:()=>XG,getPointed:()=>XJ,listen:()=>XC,listens:()=>Xz,map:()=>XV,pass:()=>XP,tell:()=>XN,writer:()=>X4});// NAMESPACE OBJECT: ./src/WriterT.ts
var e5={};e.r(e5),e.d(e5,{getWriterM:()=>X5});// NAMESPACE OBJECT: ./src/Zero.ts
var e7={};e.r(e7),e.d(e7,{guard:()=>lQ});// NAMESPACE OBJECT: ./src/boolean.ts
var e6={};e.r(e6),e.d(e6,{BooleanAlgebra:()=>hX,Eq:()=>hQ,MonoidAll:()=>h2,MonoidAny:()=>h3,Ord:()=>h4,SemigroupAll:()=>h0,SemigroupAny:()=>h1,Show:()=>h5,fold:()=>hG,foldW:()=>hZ,isBoolean:()=>hJ,match:()=>hY,matchW:()=>hH});// NAMESPACE OBJECT: ./src/function.ts
var e8={};e.r(e8),e.d(e8,{SK:()=>tS,absurd:()=>tU,apply:()=>tu,constFalse:()=>tm,constNull:()=>tI,constTrue:()=>ts,constUndefined:()=>tg,constVoid:()=>tR,constant:()=>th,decrement:()=>tO,dual:()=>tw,flip:()=>tv,flow:()=>tW,getBooleanAlgebra:()=>ti,getEndomorphismMonoid:()=>tT,getMonoid:()=>tl,getRing:()=>tc,getSemigroup:()=>to,getSemiring:()=>tp,hole:()=>tA,identity:()=>tf,increment:()=>ty,not:()=>tF,pipe:()=>tE,tuple:()=>tM,tupled:()=>tb,unsafeCoerce:()=>td,untupled:()=>tx});// NAMESPACE OBJECT: ./src/number.ts
var e9={};e.r(e9),e.d(e9,{Bounded:()=>lT,Eq:()=>lS,Field:()=>lL,MagmaSub:()=>lk,MonoidProduct:()=>lj,MonoidSum:()=>lK,Ord:()=>lF,SemigroupProduct:()=>l_,SemigroupSum:()=>lq,Show:()=>lw,isNumber:()=>lA});// NAMESPACE OBJECT: ./src/pipeable.ts
var te={};e.r(te),e.d(te,{alt:()=>SU,ap:()=>Sh,bimap:()=>Sm,chain:()=>Ss,compose:()=>Sq,contramap:()=>Sf,extend:()=>Sg,filter:()=>Sb,filterMap:()=>Sx,filterMapWithIndex:()=>SF,filterWithIndex:()=>SS,foldMap:()=>Sv,foldMapWithIndex:()=>Sy,map:()=>Su,mapLeft:()=>SI,mapWithIndex:()=>Sd,partition:()=>SE,partitionMap:()=>SA,partitionMapWithIndex:()=>Sw,partitionWithIndex:()=>ST,pipe:()=>SK,pipeable:()=>S_,promap:()=>Sk,reduce:()=>SR,reduceRight:()=>SW,reduceRightWithIndex:()=>SO,reduceWithIndex:()=>SM});// NAMESPACE OBJECT: ./src/string.ts
var tt={};e.r(tt),e.d(tt,{Eq:()=>Cy,Monoid:()=>Cb,Ord:()=>Cx,Semigroup:()=>CO,Show:()=>CE,empty:()=>CU,endsWith:()=>CP,includes:()=>CN,isEmpty:()=>CK,isString:()=>CA,replace:()=>CT,size:()=>Cj,slice:()=>C_,split:()=>CL,startsWith:()=>CC,toLowerCase:()=>CF,toUpperCase:()=>CS,trim:()=>Cw,trimLeft:()=>Ck,trimRight:()=>Cq});// NAMESPACE OBJECT: ./src/struct.ts
var tr={};e.r(tr),e.d(tr,{evolve:()=>Hh,getAssignSemigroup:()=>Hd});// NAMESPACE OBJECT: ./src/void.ts
var ta={};/**
 * The `Alt` type class identifies an associative operation on a type constructor.  It is similar to `Semigroup`, except
 * that it applies to types of kind `* -> *`, like `Array` or `Option`, rather than concrete types like `string` or
 * `number`.
 *
 * `Alt` instances are required to satisfy the following laws:
 *
 * 1. Associativity: `A.alt(A.alt(fa, ga), ha) <-> A.alt(fa, A.alt(ga, ha))`
 * 2. Distributivity: `A.map(A.alt(fa, ga), ab) <-> A.alt(A.map(fa, ab), A.map(ga, ab))`
 *
 * @since 2.0.0
 */function tn(e){return t=>r=>r.reduce((t,r)=>e.alt(t,()=>r),t)}e.r(ta),e.d(ta,{Monoid:()=>XL,Semigroup:()=>Xj});/**
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.10.0
 */let ti=e=>()=>({meet:(t,r)=>a=>e.meet(t(a),r(a)),join:(t,r)=>a=>e.join(t(a),r(a)),zero:()=>e.zero,one:()=>e.one,implies:(t,r)=>a=>e.implies(t(a),r(a)),not:t=>r=>e.not(t(r))}),to=e=>()=>({concat:(t,r)=>a=>e.concat(t(a),r(a))}),tl=e=>{let t=to(e);return()=>({concat:t().concat,empty:()=>e.empty})},tp=e=>({add:(t,r)=>a=>e.add(t(a),r(a)),zero:()=>e.zero,mul:(t,r)=>a=>e.mul(t(a),r(a)),one:()=>e.one}),tc=e=>{let t=tp(e);return{add:t.add,mul:t.mul,one:t.one,zero:t.zero,sub:(t,r)=>a=>e.sub(t(a),r(a))}},tu=e=>t=>t(e);/**
 * @since 2.0.0
 */function tf(e){return e}/**
 * @since 2.0.0
 */let td=tf;/**
 * @since 2.0.0
 */function th(e){return()=>e}/**
 * A thunk that returns always `true`.
 *
 * @since 2.0.0
 */let ts=/*#__PURE__*/th(!0),tm=/*#__PURE__*/th(!1),tI=/*#__PURE__*/th(null),tg=/*#__PURE__*/th(void 0),tR=tg;function tv(e){return(...t)=>t.length>1?e(t[1],t[0]):r=>e(r)(t[0])}function tW(e,t,r,a,n,i,o,l,p){switch(arguments.length){case 1:return e;case 2:return function(){return t(e.apply(this,arguments))};case 3:return function(){return r(t(e.apply(this,arguments)))};case 4:return function(){return a(r(t(e.apply(this,arguments))))};case 5:return function(){return n(a(r(t(e.apply(this,arguments)))))};case 6:return function(){return i(n(a(r(t(e.apply(this,arguments))))))};case 7:return function(){return o(i(n(a(r(t(e.apply(this,arguments)))))))};case 8:return function(){return l(o(i(n(a(r(t(e.apply(this,arguments))))))))};case 9:return function(){return p(l(o(i(n(a(r(t(e.apply(this,arguments)))))))))}}}/**
 * @since 2.0.0
 */function tM(...e){return e}/**
 * @since 2.0.0
 */function ty(e){return e+1}/**
 * @since 2.0.0
 */function tO(e){return e-1}/**
 * @since 2.0.0
 */function tU(e){throw Error("Called `absurd` function which should be uncallable")}/**
 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
 *
 * @example
 * import { tupled } from 'fp-ts/function'
 *
 * const add = tupled((x: number, y: number): number => x + y)
 *
 * assert.strictEqual(add([1, 2]), 3)
 *
 * @since 2.4.0
 */function tb(e){return t=>e(...t)}/**
 * Inverse function of `tupled`
 *
 * @since 2.4.0
 */function tx(e){return(...t)=>e(t)}function tE(e,t,r,a,n,i,o,l,p){switch(arguments.length){case 1:return e;case 2:return t(e);case 3:return r(t(e));case 4:return a(r(t(e)));case 5:return n(a(r(t(e))));case 6:return i(n(a(r(t(e)))));case 7:return o(i(n(a(r(t(e))))));case 8:return l(o(i(n(a(r(t(e)))))));case 9:return p(l(o(i(n(a(r(t(e))))))));default:{let e=arguments[0];for(let t=1;t<arguments.length;t++)e=arguments[t](e);return e}}}/**
 * Type hole simulation
 *
 * @since 2.7.0
 */let tA=tU,tS=(e,t)=>t;/**
 * Use `Predicate` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function tF(e){return t=>!e(t)}/**
 * Use `Endomorphism` module instead.
 *
 * @category zone of death
 * @since 2.10.0
 * @deprecated
 */let tT=()=>({concat:(e,t)=>tW(e,t),empty:tf}),tw=(e,t)=>{let r="number"==typeof e?t=>t.length>=e:e;return function(){let e=Array.from(arguments);return r(arguments)?t.apply(this,e):r=>t(r,...e)}},tk=e=>"None"===e._tag,tq=e=>"Some"===e._tag,t_={_tag:"None"},tK=e=>({_tag:"Some",value:e}),tj=e=>"Left"===e._tag,tL=e=>"Right"===e._tag,tN=e=>({_tag:"Left",left:e}),tC=e=>({_tag:"Right",right:e}),tP=e=>[e],tz=e=>e.length>0,tB=e=>e[0],tD=e=>e.slice(1),tV=[],t$={},tJ=Object.prototype.hasOwnProperty,tH=e=>[e[0],...e.slice(1)],tZ=e=>(t,r)=>(...a)=>{let n=t(...a);return e.fromEither(null==n?tN(r(...a)):tC(n))},tY=e=>(t,r)=>(...a)=>{let n=t(...a);return e.fromEither(tk(n)?tN(r(...a)):tC(n.value))},tG=(e,t)=>/*#__PURE__*/tw(3,(r,a,n)=>t.flatMap(r,tZ(e)(a,n))),tQ=(e,t)=>/*#__PURE__*/tw(3,(r,a,n)=>t.flatMap(r,tY(e)(a,n))),tX=(e,t)=>/*#__PURE__*/tw(2,(r,a)=>t.flatMap(r,t=>e.fromEither(a(t)))),t0=(e,t)=>/*#__PURE__*/tw(2,(r,a)=>t.flatMap(r,t=>e.fromIO(a(t)))),t1=(e,t)=>/*#__PURE__*/tw(2,(r,a)=>t.flatMap(r,t=>e.fromTask(a(t)))),t2=(e,t)=>/*#__PURE__*/tw(2,(r,a)=>t.flatMap(r,t=>e.fromReader(a(t))));/**
 * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.
 *
 * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor
 * `f`.
 *
 * Instances must satisfy the following law in addition to the `Functor` laws:
 *
 * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`
 *
 * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)
 * const fa: O.Option<string> = O.some('s')
 * const fb: O.Option<number> = O.some(1)
 * const fc: O.Option<boolean> = O.some(true)
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     // lift a function
 *     O.some(f),
 *     // apply the first argument
 *     O.ap(fa),
 *     // apply the second argument
 *     O.ap(fb),
 *     // apply the third argument
 *     O.ap(fc)
 *   ),
 *   O.some('s1true')
 * )
 *
 * @since 2.0.0
 */function t3(e,t){return r=>a=>e.ap(e.map(a,e=>r=>t.ap(e,r)),r)}function t4(e){return t=>r=>e.ap(e.map(r,e=>()=>e),t)}function t5(e){return t=>r=>e.ap(e.map(r,()=>e=>e),t)}function t7(e){return(t,r)=>a=>e.ap(e.map(a,e=>r=>Object.assign({},e,{[t]:r})),r)}function t6(e){return t=>({concat:(r,a)=>e.ap(e.map(r,e=>r=>t.concat(e,r)),a)})}function t8(e,t,r){return function(a){let n=Array(r.length+1);for(let e=0;e<r.length;e++)n[e]=r[e];return n[r.length]=a,0===t?e.apply(null,n):t8(e,t-1,n)}}let t9={1:e=>[e],2:e=>t=>[e,t],3:e=>t=>r=>[e,t,r],4:e=>t=>r=>a=>[e,t,r,a],5:e=>t=>r=>a=>n=>[e,t,r,a,n]};function re(e){return(...t)=>{let r=t.length,a=(tJ.call(t9,r)||(t9[r]=t8(tM,r-1,[])),t9[r]),n=e.map(t[0],a);for(let a=1;a<r;a++)n=e.ap(n,t[a]);return n}}function rt(e){return t=>{let r=Object.keys(t),a=r.length,n=function(e){let t=e.length;switch(t){case 1:return t=>({[e[0]]:t});case 2:return t=>r=>({[e[0]]:t,[e[1]]:r});case 3:return t=>r=>a=>({[e[0]]:t,[e[1]]:r,[e[2]]:a});case 4:return t=>r=>a=>n=>({[e[0]]:t,[e[1]]:r,[e[2]]:a,[e[3]]:n});case 5:return t=>r=>a=>n=>i=>({[e[0]]:t,[e[1]]:r,[e[2]]:a,[e[3]]:n,[e[4]]:i});default:return t8((...r)=>{let a={};for(let n=0;n<t;n++)a[e[n]]=r[n];return a},t-1,[])}}(r),i=e.map(t[r[0]],n);for(let n=1;n<a;n++)i=e.ap(i,t[r[n]]);return i}}/**
 * The `Alternative` type class extends the `Alt` type class with a value that should be the left and right identity for `alt`.
 *
 * It is similar to `Monoid`, except that it applies to types of kind `* -> *`, like `Array` or `Option`, rather than
 * concrete types like `string` or `number`.
 *
 * `Alternative` instances should satisfy the following laws:
 *
 * 1. Left identity: `A.alt(zero, fa) <-> fa`
 * 2. Right identity: `A.alt(fa, zero) <-> fa`
 * 3. Annihilation: `A.map(zero, f) <-> zero`
 * 4. Distributivity: `A.ap(A.alt(fab, gab), fa) <-> A.alt(A.ap(fab, fa), A.ap(gab, fa))`
 * 5. Annihilation: `A.ap(zero, fa) <-> zero`
 *
 * @since 2.0.0
 */function rr(e){return tn(e)(e.zero())}function ra(e){let t=t6(e);return r=>{let a=t(r);return{concat:(t,r)=>e.alt(a.concat(t,r),()=>e.alt(t,()=>r)),empty:e.zero()}}}/**
 * A `Functor` is a type constructor which supports a mapping operation `map`.
 *
 * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
 * constructor `f` to represent some computational context.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Identity: `F.map(fa, a => a) <-> fa`
 * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
 *
 * @since 2.0.0
 */function rn(e,t){return r=>a=>e.map(a,e=>t.map(e,r))}function ri(e){return t=>r=>e.map(r,e=>e(t))}function ro(e){return t=>r=>e.map(r,e=>({[t]:e}))}function rl(e){return(t,r)=>a=>e.map(a,e=>Object.assign({},e,{[t]:r(e)}))}/** @deprecated */function rp(e,t){let r=rn(e,t);return{map:(e,t)=>tE(e,r(t))}}/** @internal */function rc(e){return(t,r)=>e.map(t,()=>r)}/** @internal */function ru(e){let t=rc(e);return e=>t(e,void 0)}/**
 * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values
 * of type `f a` from values of type `a`.
 *
 * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are
 * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the
 * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for
 * any number of function arguments.
 *
 * Instances must satisfy the following laws in addition to the `Apply` laws:
 *
 * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`
 * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`
 * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`
 *
 * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`
 *
 * @since 2.0.0
 */function rf(e){let t=t6(e);return r=>({concat:t(r).concat,empty:e.of(r.empty)})}/** @deprecated */function rd(e,t){let r=rp(e,t).map,a=t3(e,t);return{map:r,of:r=>e.of(t.of(r)),ap:(e,t)=>tE(e,a(t))}}/**
 * The `Chain` type class extends the `Apply` type class with a `chain` operation which composes computations in
 * sequence, using the return value of one computation to determine the next computation.
 *
 * Instances must satisfy the following law in addition to the `Apply` laws:
 *
 * 1. Associativity: `F.chain(F.chain(fa, afb), bfc) <-> F.chain(fa, a => F.chain(afb(a), bfc))`
 *
 * Note. `Apply`'s `ap` can be derived: `(fab, fa) => F.chain(fab, f => F.map(fa, f))`
 *
 * @since 2.0.0
 */function rh(e){let t=rs(e);return e=>r=>t(r,e)}/** @internal */function rs(e){return(t,r)=>e.chain(t,t=>e.map(r(t),()=>t))}function rm(e){return(t,r)=>a=>e.chain(a,a=>e.map(r(a),e=>Object.assign({},a,{[t]:e})))}/**
 * The `FromEither` type class represents those data types which support errors.
 *
 * @since 2.10.0
 */function rI(e){return t=>r=>e.fromEither(tk(r)?tN(t()):tC(r.value))}function rg(e){return(t,r)=>a=>e.fromEither(t(a)?tC(a):tN(r(a)))}function rR(e){let t=rI(e);return e=>{let r=t(e);return e=>tW(e,r)}}function rv(e,t){let r=rR(e);return e=>{let a=r(e);return e=>r=>t.chain(r,a(e))}}function rW(e){return t=>tW(t,e.fromEither)}function rM(e,t){let r=rW(e);return e=>a=>t.chain(a,r(e))}function ry(e,t){let r=rU(e,t);return e=>t=>r(t,e)}function rO(e,t){return(r,a)=>n=>t.chain(n,t=>e.fromEither(r(t)?tC(t):tN(a(t))))}/** @internal */function rU(e,t){let r=rW(e),a=rs(t);return(e,t)=>a(e,r(t))}/**
 * The `Eq` type class represents types which support decidable equality.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Reflexivity: `E.equals(a, a) === true`
 * 2. Symmetry: `E.equals(a, b) === E.equals(b, a)`
 * 3. Transitivity: if `E.equals(a, b) === true` and `E.equals(b, c) === true`, then `E.equals(a, c) === true`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */let rb=e=>({equals:(t,r)=>t===r||e(t,r)}),rx=e=>rb((t,r)=>{for(let a in e)if(!e[a].equals(t[a],r[a]))return!1;return!0}),rE=(...e)=>rb((t,r)=>e.every((e,a)=>e.equals(t[a],r[a]))),rA=e=>t=>rb((r,a)=>t.equals(e(r),e(a))),rS="Eq",rF={equals:(e,t)=>e===t},rT={equals:()=>!0},rw=()=>({concat:(e,t)=>rb((r,a)=>e.equals(r,a)&&t.equals(r,a))}),rk=()=>({concat:rw().concat,empty:rT}),rq={URI:rS,contramap:(e,t)=>tE(e,rA(t))},r_=rE,rK=rx,rj=rF.equals,rL=rq,rN=rF,rC=rF,rP=rF,rz={equals:(e,t)=>e.valueOf()===t.valueOf()},rB=e=>(t,r)=>t===r||0===e(t,r),rD=e=>({equals:rB(e),compare:(t,r)=>t===r?0:e(t,r)}),rV=(...e)=>rD((t,r)=>{let a=0;for(;a<e.length-1;a++){let n=e[a].compare(t[a],r[a]);if(0!==n)return n}return e[a].compare(t[a],r[a])}),r$=e=>rD((t,r)=>e.compare(r,t)),rJ=e=>t=>rD((r,a)=>t.compare(e(r),e(a))),rH="Ord",rZ=()=>({concat:(e,t)=>rD((r,a)=>{let n=e.compare(r,a);return 0!==n?n:t.compare(r,a)})}),rY=()=>({concat:rZ().concat,empty:rD(()=>0)}),rG={URI:rH,contramap:(e,t)=>tE(e,rJ(t))},rQ={equals:ts,compare:/*#__PURE__*/th(0)},rX=e=>t=>r=>r===t||0===e.compare(r,t),r0=e=>(t,r)=>-1===e.compare(t,r),r1=e=>(t,r)=>1===e.compare(t,r),r2=e=>(t,r)=>1!==e.compare(t,r),r3=e=>(t,r)=>-1!==e.compare(t,r),r4=e=>(t,r)=>t===r||1>e.compare(t,r)?t:r,r5=e=>(t,r)=>t===r||e.compare(t,r)>-1?t:r,r7=e=>{let t=r4(e),r=r5(e);return(e,a)=>n=>r(t(n,a),e)},r6=e=>{let t=r0(e),r=r1(e);return(e,a)=>n=>!(t(n,e)||r(n,a))},r8=rV,r9=r$,ae=rG,at={equals:rF.equals,compare:// default compare for primitive types
function(e,t){return e<t?-1:+(e>t)}},ar=at,aa=at,an=at,ai=/*#__PURE__*/tE(an,/*#__PURE__*/rJ(e=>e.valueOf())),ao=e=>({concat:(t,r)=>e.concat(r,t)}),al=e=>t=>({concat:(r,a)=>e(r)?t.concat(r,a):a}),ap=e=>t=>({concat:(r,a)=>e(a)?t.concat(r,a):r}),ac=e=>t=>({concat:(r,a)=>t.concat(e(r),e(a))}),au=e=>t=>r=>r.reduce((t,r)=>e.concat(t,r),t),af=e=>({concat:r4(e)}),ad=e=>({concat:r5(e)}),ah=e=>({concat:()=>e}),as=ao,am=e=>({concat:(t,r)=>{let a={};for(let n in e)tJ.call(e,n)&&(a[n]=e[n].concat(t[n],r[n]));return a}}),aI=(...e)=>({concat:(t,r)=>e.map((e,a)=>e.concat(t[a],r[a]))}),ag=e=>t=>({concat:(r,a)=>t.concat(r,t.concat(e,a))}),aR=()=>({concat:tf}),av=()=>({concat:(e,t)=>t}),aW=au,aM=ah(void 0),ay=()=>({concat:(e,t)=>Object.assign({},e,t)}),aO=av,aU=aR,ab=aI,ax=am,aE=as,aA=ad,aS=af,aF=ag;function aT(e){let t=aW(e);return(e,r)=>void 0===r?t(e):t(e)(r)}/**
 * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let aw={concat:(e,t)=>e&&t},ak={concat:(e,t)=>e||t},aq=to,a_={concat:(e,t)=>e+t},aK={concat:(e,t)=>e+t},aj={concat:(e,t)=>e*t},aL=tV,aN=tz,aC=(e,t)=>e<0||e>=t.length,aP=e=>t=>[e,...t],az=aP,aB=e=>t=>[...t,e],aD=aB,aV=(e,t,r)=>{if(aN(r)){let a=tH(r);return a.splice(e,0,t),a}return[t]},a$=(e,t,r)=>{if(r[e]===t)return r;{let a=tH(r);return a[e]=t,a}},aJ=e=>t=>{if(1===t.length)return t;let r=[il(t)];for(let a of ip(t))r.every(t=>!e.equals(t,a))&&r.push(a);return r},aH=e=>{if(aN(e)){let t=rY();return a9(e.reduce(t.concat,t.empty))}return tf},aZ=e=>{let t=aJ(e);return e=>r=>t(tE(r,a5(e)))},aY=e=>t=>{let r=t.length,a=Math.round(e)%r;if(aC(Math.abs(a),t)||0===a)return t;if(!(a<0))return aY(a-r)(t);{let[e,r]=np(-a)(t);return tE(r,a5(e))}},aG=e=>aN(e)?tK(e):t_,aQ=e=>t=>{let r=Math.max(0,Math.floor(t)),a=[e(0)];for(let t=1;t<r;t++)a.push(e(t));return a},aX=e=>aQ(()=>e),a0=(e,t)=>e<=t?aQ(t=>e+t)(t-e+1):[e],a1=e=>[il(e),ip(e)],a2=e=>[iu(e),ic(e)],a3=e=>aG(e.slice());function a4(e){return t=>t.concat(e)}function a5(e,t){return t?e.concat(t):t=>t.concat(e)}/**
 * @since 2.5.0
 */let a7=e=>1===e.length?e:[ic(e),...e.slice(0,-1).reverse()];function a6(e){return t=>{let r=t.length;if(0===r)return aL;let a=[],n=t[0],i=[n];for(let o=1;o<r;o++){let r=t[o];e.equals(r,n)?i.push(r):(a.push(i),i=[n=r])}return a.push(i),a}}/**
 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @example
 * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
 *   '1': ['a', 'b'],
 *   '2': ['ab']
 * })
 *
 * @since 2.5.0
 */let a8=e=>t=>{let r={};for(let a of t){let t=e(a);tJ.call(r,t)?r[t].push(a):r[t]=[a]}return r},a9=e=>t=>1===t.length?t:t.slice().sort(e.compare),ne=(e,t)=>nt(e,()=>t),nt=(e,t)=>r=>aC(e,r)?t_:tK(a$(e,t(r[e]),r)),nr=(e,t,r)=>{let a=[r(e[0],t[0])],n=Math.min(e.length,t.length);for(let i=1;i<n;i++)a[i]=r(e[i],t[i]);return a},na=e=>{let t=[e[0][0]],r=[e[0][1]];for(let a=1;a<e.length;a++)t[a]=e[a][0],r[a]=e[a][1];return[t,r]},nn=e=>t=>{let r=[e,t[0]];for(let a=1;a<t.length;a++)r.push(e,t[a]);return r},ni=e=>t=>{let r=ip(t);return aN(r)?tE(r,nn(e),az(il(t))):t},no=e=>t=>{let r=tH(e(0,il(t)));for(let a=1;a<t.length;a++){let n=e(a,t[a]);for(let e=0;e<n.length;e++)r.push(n[e])}return r},nl=e=>t=>{let[r,a]=e(t),n=[r],i=a;for(;aN(i);){let[t,r]=e(i);n.push(t),i=r}return n},np=e=>t=>{let r=Math.max(1,e);return r>=t.length?[t,aL]:[tE(t.slice(1,r),az(il(t))),t.slice(r)]},nc=e=>nl(np(e)),nu=(e,t)=>tE(e,nT(t)),nf=(e,t)=>tE(e,nw(t)),nd=(e,t)=>tE(e,nx(t)),nh=(e,t)=>tE(e,nA(t)),ns=(e,t,r)=>tE(e,nk(t,r)),nm=e=>{let t=nq(e);return(e,r)=>tE(e,t(r))},nI=(e,t,r)=>tE(e,n_(t,r)),ng=e=>{let t=nN(e);return(e,r)=>tE(e,t(r))},nR=(e,t)=>tE(e,nb(t)),nv=(e,t,r)=>tE(e,nK(t,r)),nW=e=>{let t=nj(e);return(e,r)=>tE(e,t(r))},nM=(e,t,r)=>tE(e,nL(t,r)),ny=e=>{let t=nP(e);return(e,r)=>tE(e,t(r))},nO=tP,nU=e=>t=>tE(t,a4(e())),nb=nU,nx=e=>nE(t=>tE(e,nT(t))),nE=/*#__PURE__*/tw(2,(e,t)=>tE(e,no((e,r)=>t(r,e)))),nA=e=>t=>{let r=ip(t),a=[e(t)];for(;aN(r);)a.push(e(r)),r=ip(r);return a},nS=/*#__PURE__*/nA(tf),nF=/*#__PURE__*/nE(tf),nT=e=>nw((t,r)=>e(r)),nw=e=>t=>{let r=[e(0,il(t))];for(let a=1;a<t.length;a++)r.push(e(a,t[a]));return r},nk=(e,t)=>nK(e,(e,r,a)=>t(r,a)),nq=e=>t=>r=>r.slice(1).reduce((r,a)=>e.concat(r,t(a)),t(r[0])),n_=(e,t)=>nL(e,(e,r,a)=>t(r,a)),nK=(e,t)=>r=>r.reduce((e,r,a)=>t(a,e,r),e),nj=e=>t=>r=>r.slice(1).reduce((r,a,n)=>e.concat(r,t(n+1,a)),t(0,r[0])),nL=(e,t)=>r=>r.reduceRight((e,r,a)=>t(a,r,e),e),nN=e=>{let t=nP(e);return e=>t((t,r)=>e(r))},nC=e=>nP(e)(tS),nP=e=>t=>r=>{let a=e.map(t(0,il(r)),nO);for(let n=1;n<r.length;n++)a=e.ap(e.map(a,e=>t=>tE(e,aD(t))),t(n,r[n]));return a},nz=tB,nB="ReadonlyNonEmptyArray",nD=e=>({show:t=>`[${t.map(e.show).join(", ")}]`}),nV=()=>({concat:a5}),n$=e=>rb((t,r)=>t.length===r.length&&t.every((t,a)=>e.equals(t,r[a]))),nJ=e=>{let t=aZ(e);return{concat:(e,r)=>t(r)(e)}},nH={URI:nB,map:nu},nZ=/*#__PURE__*/ri(nH),nY={URI:nB,of:nO},nG={URI:nB,map:nu,mapWithIndex:nf},nQ={URI:nB,map:nu,ap:nd},nX=/*#__PURE__*/t4(nQ),n0=/*#__PURE__*/t5(nQ),n1={URI:nB,map:nu,ap:nd,of:nO},n2={URI:nB,map:nu,ap:nd,chain:nE},n3=/*#__PURE__*/rh(n2),n4={URI:nB,map:nu,ap:nd,of:nO,chain:nE},n5={URI:nB,reduce:ns,foldMap:nm,reduceRight:nI},n7={URI:nB,reduce:ns,foldMap:nm,reduceRight:nI,reduceWithIndex:nv,foldMapWithIndex:nW,reduceRightWithIndex:nM},n6={URI:nB,map:nu,reduce:ns,foldMap:nm,reduceRight:nI,traverse:ng,sequence:nC},n8={URI:nB,map:nu,mapWithIndex:nf,reduce:ns,foldMap:nm,reduceRight:nI,traverse:ng,sequence:nC,reduceWithIndex:nv,foldMapWithIndex:nW,reduceRightWithIndex:nM,traverseWithIndex:ny},n9={URI:nB,map:nu,alt:nR},ie={URI:nB,map:nu,extend:nh,extract:nz},it=/*#__PURE__*/nO(t$),ir=/*#__PURE__*/ro(nH),ia=/*#__PURE__*/rl(nH),ii=/*#__PURE__*/rm(n2),io=/*#__PURE__*/t7(nQ),il=nz,ip=tD,ic=e=>e[e.length-1],iu=e=>e.slice(0,-1),id=e=>{let t=af(e);return e=>e.reduce(t.concat)},ih=e=>{let t=ad(e);return e=>e.reduce(t.concat)},is=e=>t=>t.reduce(e.concat),im=e=>t=>e(il(t),ip(t)),iI=e=>t=>e(iu(t),ic(t)),ig=e=>t=>[e(il(t)),...ip(t)],iR=e=>ig(()=>e),iv=e=>t=>tE(iu(t),aD(e(ic(t)))),iW=e=>iv(()=>e),iM=e=>{let t=is(e);return e=>tW(ni(e),t)},iy=nE;function iO(e){let t=a9(e),r=a6(e);return e=>aN(e)?r(t(e)):aL}function iU(e){return ib((t,r)=>e(r))}/**
 * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */let ib=e=>t=>aG(t.filter((t,r)=>e(r,t))),ix=a1,iE=a2;function iA(e,t){return void 0===t?az(e):tE(t,az(e))}/**
 * Use [`append`](./ReadonlyArray.ts.html#append) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */let iS=(e,t)=>tE(e,a5([t])),iF=(e,t)=>r=>e<0||e>r.length?t_:tK(aV(e,t,r)),iT=nn,iw=is,ik={URI:nB,of:nO,map:nu,mapWithIndex:nf,ap:nd,chain:nE,extend:nh,extract:nz,reduce:ns,foldMap:nm,reduceRight:nI,traverse:ng,sequence:nC,reduceWithIndex:nv,foldMapWithIndex:nW,reduceRightWithIndex:nM,traverseWithIndex:ny,alt:nR},iq=e=>e.length>0,i_=(e,t)=>e<0||e>=t.length,iK=e=>t=>[e,...t],ij=iK,iL=e=>t=>[...t,e],iN=iL,iC=(e,t,r)=>{if(iq(r)){let a=i$(r);return a.splice(e,0,t),a}return[t]},iP=(e,t,r)=>{let a=i$(r);return a[e]=t,a},iz=e=>t=>{if(1===t.length)return i8(t);let r=[la(t)];for(let a of ln(t))r.every(t=>!e.equals(t,a))&&r.push(a);return r},iB=e=>{if(iq(e)){let t=rY();return i4(e.reduce(t.concat,t.empty))}return i8},iD=e=>{let t=iz(e);return e=>r=>t(tE(r,i0(e)))},iV=e=>t=>{let r=t.length,a=Math.round(e)%r;if(i_(Math.abs(a),t)||0===a)return i8(t);if(!(a<0))return iV(a-r)(t);{let[e,r]=op(-a)(t);return tE(r,i0(e))}},i$=tH,iJ=e=>iq(e)?tK(e):t_,iH=e=>t=>{let r=Math.max(0,Math.floor(t)),a=[e(0)];for(let t=1;t<r;t++)a.push(e(t));return a},iZ=e=>iH(()=>e),iY=(e,t)=>e<=t?iH(t=>e+t)(t-e+1):[e],iG=e=>[la(e),ln(e)],iQ=e=>[lo(e),li(e)];function iX(e){return t=>t.concat(e)}function i0(e,t){return t?e.concat(t):t=>t.concat(e)}/**
 * @since 2.0.0
 */let i1=e=>[li(e),...e.slice(0,-1).reverse()];function i2(e){return t=>{let r=t.length;if(0===r)return[];let a=[],n=t[0],i=[n];for(let o=1;o<r;o++){let r=t[o];e.equals(r,n)?i.push(r):(a.push(i),i=[n=r])}return a.push(i),a}}/**
 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @example
 * import { groupBy } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
 *   '1': ['a', 'b'],
 *   '2': ['ab']
 * })
 *
 * @since 2.0.0
 */let i3=e=>t=>{let r={};for(let a of t){let t=e(a);tJ.call(r,t)?r[t].push(a):r[t]=[a]}return r},i4=e=>t=>t.slice().sort(e.compare),i5=(e,t)=>r=>e<0||e>r.length?t_:tK(iC(e,t,r)),i7=(e,t)=>i6(e,()=>t),i6=(e,t)=>r=>i_(e,r)?t_:tK(iP(e,t(r[e]),r)),i8=i$,i9=e=>[e],oe=(e,t,r)=>{let a=[r(e[0],t[0])],n=Math.min(e.length,t.length);for(let i=1;i<n;i++)a[i]=r(e[i],t[i]);return a},ot=e=>{let t=[e[0][0]],r=[e[0][1]];for(let a=1;a<e.length;a++)t[a]=e[a][0],r[a]=e[a][1];return[t,r]},or=e=>t=>{let r=[e,t[0]];for(let a=1;a<t.length;a++)r.push(e,t[a]);return r},oa=e=>t=>{let r=ln(t);return iq(r)?tE(r,or(e),ij(la(t))):i8(t)},on=nj,oi=nq,oo=e=>t=>{let r=i$(e(0,la(t)));for(let a=1;a<t.length;a++){let n=e(a,t[a]);for(let e=0;e<n.length;e++)r.push(n[e])}return r},ol=e=>t=>{let[r,a]=e(t),n=[r],i=a;for(;iq(i);){let[t,r]=e(i);n.push(t),i=r}return n},op=e=>t=>{let r=Math.max(1,e);return r>=t.length?[i8(t),[]]:[tE(t.slice(1,r),ij(la(t))),t.slice(r)]},oc=e=>ol(op(e)),ou=(e,t)=>tE(e,oF(t)),of=(e,t)=>tE(e,oT(t)),od=(e,t)=>tE(e,ob(t)),oh=(e,t)=>tE(e,oE(t)),os=(e,t,r)=>tE(e,ow(t,r)),om=e=>{let t=oi(e);return(e,r)=>tE(e,t(r))},oI=(e,t,r)=>tE(e,oq(t,r)),og=e=>{let t=oK(e);return(e,r)=>tE(e,t(r))},oR=(e,t)=>tE(e,oU(t)),ov=(e,t,r)=>tE(e,ok(t,r)),oW=e=>{let t=on(e);return(e,r)=>tE(e,t(r))},oM=(e,t,r)=>tE(e,o_(t,r)),oy=e=>{let t=oL(e);return(e,r)=>tE(e,t(r))},oO=e=>t=>tE(t,iX(e())),oU=oO,ob=e=>ox(t=>tE(e,oF(t))),ox=/*#__PURE__*/tw(2,(e,t)=>tE(e,oo((e,r)=>t(r,e)))),oE=e=>t=>{let r=ln(t),a=[e(t)];for(;iq(r);)a.push(e(r)),r=ln(r);return a},oA=/*#__PURE__*/oE(tf),oS=/*#__PURE__*/ox(tf),oF=e=>oT((t,r)=>e(r)),oT=e=>t=>{let r=[e(0,la(t))];for(let a=1;a<t.length;a++)r.push(e(a,t[a]));return r},ow=nk,ok=nK,oq=n_,o_=nL,oK=e=>{let t=oL(e);return e=>t((t,r)=>e(r))},oj=e=>oL(e)((e,t)=>t),oL=e=>t=>r=>{let a=e.map(t(0,la(r)),i9);for(let n=1;n<r.length;n++)a=e.ap(e.map(a,e=>t=>tE(e,iN(t))),t(n,r[n]));return a},oN=il,oC="NonEmptyArray",oP=nD,oz=()=>({concat:i0}),oB=n$,oD=e=>{let t=iD(e);return{concat:(e,r)=>t(r)(e)}},oV={URI:oC,map:ou},o$=/*#__PURE__*/ri(oV),oJ={URI:oC,of:i9},oH={URI:oC,map:ou,mapWithIndex:of},oZ={URI:oC,map:ou,ap:od},oY=/*#__PURE__*/t4(oZ),oG=/*#__PURE__*/t5(oZ),oQ={URI:oC,map:ou,ap:od,of:i9},oX={URI:oC,map:ou,ap:od,chain:ox},o0=/*#__PURE__*/rh(oX),o1={URI:oC,map:ou,ap:od,of:i9,chain:ox},o2={URI:oC,reduce:os,foldMap:om,reduceRight:oI},o3={URI:oC,reduce:os,foldMap:om,reduceRight:oI,reduceWithIndex:ov,foldMapWithIndex:oW,reduceRightWithIndex:oM},o4={URI:oC,map:ou,reduce:os,foldMap:om,reduceRight:oI,traverse:og,sequence:oj},o5={URI:oC,map:ou,mapWithIndex:of,reduce:os,foldMap:om,reduceRight:oI,traverse:og,sequence:oj,reduceWithIndex:ov,foldMapWithIndex:oW,reduceRightWithIndex:oM,traverseWithIndex:oy},o7={URI:oC,map:ou,alt:oR},o6={URI:oC,map:ou,extend:oh,extract:oN},o8=/*#__PURE__*/i9(t$),o9=/*#__PURE__*/ro(oV),le=/*#__PURE__*/rl(oV),lt=/*#__PURE__*/rm(oX),lr=/*#__PURE__*/t7(oZ),la=il,ln=e=>e.slice(1),li=ic,lo=e=>e.slice(0,-1),ll=id,lp=ih,lc=e=>t=>t.reduce(e.concat),lu=e=>t=>e(la(t),ln(t)),lf=e=>t=>e(lo(t),li(t)),ld=e=>t=>[e(la(t)),...ln(t)],lh=e=>ld(()=>e),ls=e=>t=>tE(lo(t),iN(e(li(t)))),lm=e=>ls(()=>e),lI=iM,lg=ox;function lR(e){let t=i4(e),r=i2(e);return e=>iq(e)?r(t(e)):[]}function lv(e){return lW((t,r)=>e(r))}/**
 * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let lW=e=>t=>iJ(t.filter((t,r)=>e(r,t))),lM=iG,ly=iQ;function lO(e,t){return void 0===t?ij(e):tE(t,ij(e))}/**
 * Use [`append`](./Array.ts.html#append) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let lU=(e,t)=>tE(e,iN(t)),lb=or,lx=is,lE={URI:oC,of:i9,map:ou,mapWithIndex:of,ap:od,chain:ox,extend:oh,extract:oN,reduce:os,foldMap:om,reduceRight:oI,traverse:og,sequence:oj,reduceWithIndex:ov,foldMapWithIndex:oW,reduceRightWithIndex:oM,traverseWithIndex:oy,alt:oR},lA=e=>"number"==typeof e,lS={equals:(e,t)=>e===t},lF={equals:lS.equals,compare:(e,t)=>e<t?-1:+(e>t)},lT={equals:lS.equals,compare:lF.compare,top:1/0,bottom:-1/0},lw={show:e=>JSON.stringify(e)},lk={concat:(e,t)=>e-t},lq={concat:(e,t)=>e+t},l_={concat:(e,t)=>e*t},lK={concat:lq.concat,empty:0},lj={concat:l_.concat,empty:1},lL={add:lq.concat,zero:0,mul:l_.concat,one:1,sub:lk.concat,degree:e=>1,div:(e,t)=>e/t,mod:(e,t)=>e%t},lN=(e,t)=>({left:e,right:t}),lC=e=>t=>lN(lJ(t),e(lH(t))),lP=e=>t=>lN(e(lJ(t)),lH(t)),lz=(e,t)=>r=>lN(e(lJ(r)),t(lH(r))),lB="Separated",lD={URI:lB,mapLeft:(e,t)=>tE(e,lP(t)),bimap:(e,t,r)=>tE(e,lz(t,r))},lV={URI:lB,map:(e,t)=>tE(e,lC(t))},l$=/*#__PURE__*/ri(lV),lJ=e=>e.left,lH=e=>e.right;/**
 * `Witherable` represents data structures which can be _partitioned_ with effects in some `Applicative` functor.
 *
 * Adapted from https://github.com/LiamGoodacre/purescript-filterable/blob/master/src/Data/Witherable.purs
 *
 * @since 2.0.0
 */function lZ(e,t){return r=>{let a=e.traverse(r);return(e,n)=>r.map(a(e,n),t.separate)}}function lY(e,t){return r=>{let a=e.traverse(r);return(e,n)=>r.map(a(e,n),t.compact)}}function lG(e){return t=>{let r=e.wither(t);return e=>a=>r(a,r=>t.map(e(r),e=>e?tK(r):t_))}}/**
 * @since 2.11.0
 */function lQ(e,t){return r=>r?t.of(void 0):e.zero()}/**
 * @since 2.5.0
 */// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Test whether a `ReadonlyArray` is empty.
 *
 * @example
 * import { isEmpty } from 'fp-ts/ReadonlyArray'
 *
 * assert.strictEqual(isEmpty([]), true)
 *
 * @category refinements
 * @since 2.5.0
 */let lX=e=>0===e.length,l0=aN,l1=az,l2=aP,l3=aD,l4=aB,l5=(e,t)=>e<=0?u_:aQ(t)(e),l7=(e,t)=>l5(e,()=>t);function l6(e){return t=>e(t)?[t]:u_}// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.11.0
 */let l8=e=>tk(e)?u_:[e.value],l9=e=>tj(e)?u_:[e.right],pe=(e,t)=>r=>l0(r)?t(r):e(),pt=pe,pr=(e,t)=>r=>l0(r)?t(il(r),ip(r)):e(),pa=pr,pn=pa,pi=(e,t)=>r=>l0(r)?t(iu(r),ic(r)):e(),po=pi,pl=po,pp=e=>t=>{if(lX(t))return u_;let r=[];for(let a=0;a<t.length;a++){let n=e(a,t[a]);for(let e=0;e<n.length;e++)r.push(n[e])}return r},pc=(e,t)=>r=>{let a=r.length,n=Array(a+1);n[0]=e;for(let e=0;e<a;e++)n[e+1]=t(n[e],r[e]);return n},pu=(e,t)=>r=>{let a=r.length,n=Array(a+1);n[a]=e;for(let e=a-1;e>=0;e--)n[e]=t(r[e],n[e+1]);return n},pf=e=>e.length,pd=aC;function ph(e,t){return void 0===t?t=>ph(e,t):pd(e,t)?t_:tK(t[e])}/**
 * Get the first element in an array, or `None` if the array is empty
 *
 * @example
 * import { head } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
 * assert.deepStrictEqual(head([]), none)
 *
 * @since 2.5.0
 */let ps=e=>l0(e)?tK(il(e)):t_,pm=e=>l0(e)?tK(ic(e)):t_,pI=e=>l0(e)?tK(ip(e)):t_,pg=e=>l0(e)?tK(iu(e)):t_,pR=e=>t=>pd(e,t)?t:0===e?u_:t.slice(0,e),pv=e=>t=>pd(e,t)?t:0===e?u_:t.slice(-e);function pW(e){return t=>{let r=[];for(let a of t){if(!e(a))break;r.push(a)}let a=r.length;return a===t.length?t:0===a?u_:r}}let pM=(e,t)=>{let r=e.length,a=0;for(;a<r&&t(e[a]);a++);return a};function py(e){return t=>{let[r,a]=pZ(pM(t,e))(t);return{init:r,rest:a}}}/**
 * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])
 * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)
 * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)
 *
 * @since 2.5.0
 */let pO=e=>t=>e<=0||lX(t)?t:e>=t.length?u_:t.slice(e,t.length),pU=e=>t=>e<=0||lX(t)?t:e>=t.length?u_:t.slice(0,t.length-e);function pb(e){return t=>{let r=pM(t,e);return 0===r?t:r===t.length?u_:t.slice(r)}}/**
 * Find the first index for which a predicate holds
 *
 * @example
 * import { findIndex } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
 *
 * @since 2.5.0
 */let px=e=>t=>{for(let r=0;r<t.length;r++)if(e(t[r]))return tK(r);return t_};function pE(e){return t=>{for(let r=0;r<t.length;r++)if(e(t[r]))return tK(t[r]);return t_}}/**
 * Find the first element returned by an option based selector function
 *
 * @example
 * import { findFirstMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the first person that has an age
 * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))
 *
 * @since 2.5.0
 */let pA=e=>t=>{for(let r=0;r<t.length;r++){let a=e(t[r]);if(tq(a))return a}return t_};function pS(e){return t=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return tK(t[r]);return t_}}/**
 * Find the last element returned by an option based selector function
 *
 * @example
 * import { findLastMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the last person that has an age
 * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))
 *
 * @since 2.5.0
 */let pF=e=>t=>{for(let r=t.length-1;r>=0;r--){let a=e(t[r]);if(tq(a))return a}return t_},pT=e=>t=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return tK(r);return t_},pw=(e,t)=>r=>e<0||e>r.length?t_:tK(aV(e,t,r)),pk=(e,t)=>p_(e,()=>t),pq=e=>t=>pd(e,t)?t_:tK(uw(e,t)),p_=(e,t)=>r=>pd(e,r)?t_:tK(uT(e,t(r[e]),r)),pK=e=>e.length<=1?e:e.slice().reverse(),pj=e=>{let t=[];for(let r=0;r<e.length;r++){let a=e[r];"Right"===a._tag&&t.push(a.right)}return t},pL=e=>{let t=[];for(let r=0;r<e.length;r++){let a=e[r];"Left"===a._tag&&t.push(a.left)}return t},pN=e=>t=>t.length<=1?t:t.slice().sort(e.compare),pC=(e,t,r)=>{let a=[],n=Math.min(e.length,t.length);for(let i=0;i<n;i++)a[i]=r(e[i],t[i]);return a},pP=e=>{let t=[],r=[];for(let a=0;a<e.length;a++)t[a]=e[a][0],r[a]=e[a][1];return[t,r]},pz=e=>{let t=nn(e);return e=>l0(e)?t(e):e},pB=e=>{let t=ni(e);return e=>l0(e)?t(e):e},pD=e=>{let t=aY(e);return e=>l0(e)?t(e):e};function pV(e){return(t,r)=>{if(void 0===r){let r=pV(e);return e=>r(t,e)}let a=r=>e.equals(r,t),n=0;for(;n<r.length;n++)if(a(r[n]))return!0;return!1}}/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @example
 * import { uniq } from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.5.0
 */let p$=e=>{let t=aJ(e);return e=>l0(e)?t(e):e},pJ=e=>{let t=aH(e);return e=>l0(e)?t(e):e},pH=e=>{let t=nl(e);return e=>l0(e)?t(e):u_},pZ=e=>t=>e>=1&&l0(t)?np(e)(t):lX(t)?[t,u_]:[u_,t],pY=e=>{let t=nc(e);return e=>l0(e)?t(e):u_},pG=e=>(...t)=>l8(e(...t));function pQ(e,t,r=()=>!0){let a=(e,n)=>l0(n)?cy(il(n),t=>a(tE(e,l3(t)),ip(n))):r(...e)?[t(...e)]:u_;return a(u_,e)}/**
 * @since 2.11.0
 */let pX=e=>t=>lX(t)?e:lX(e)?t:t.concat(e),p0=pX;function p1(e){let t=aZ(e);return(r,a)=>{if(void 0===a){let t=p1(e);return e=>t(e,r)}return l0(r)&&l0(a)?t(a)(r):l0(r)?r:a}}function p2(e){let t=pV(e);return(r,a)=>{if(void 0===a){let t=p2(e);return e=>t(e,r)}return r.filter(e=>t(e,a))}}function p3(e){let t=pV(e);return(r,a)=>{if(void 0===a){let t=p3(e);return e=>t(e,r)}return r.filter(e=>!t(e,a))}}let p4=(e,t)=>tE(e,cU(t)),p5=(e,t)=>tE(e,cb(t)),p7=(e,t)=>tE(e,cM(t)),p6=(e,t)=>tE(e,cE(t)),p8=(e,t)=>tE(e,cS(t)),p9=(e,t)=>tE(e,cT(t)),ce=(e,t)=>tE(e,ck(t)),ct=(e,t)=>tE(e,cw(t)),cr=(e,t)=>tE(e,cq(t)),ca=(e,t)=>tE(e,cW(t)),cn=(e,t,r)=>tE(e,cN(t,r)),ci=e=>{let t=cC(e);return(e,r)=>tE(e,t(r))},co=(e,t,r)=>tE(e,cz(t,r)),cl=(e,t,r)=>tE(e,cP(t,r)),cp=e=>{let t=cL(e);return(e,r)=>tE(e,t(r))},cc=(e,t,r)=>tE(e,cB(t,r)),cu=(e,t)=>tE(e,cA(t)),cf=(e,t)=>tE(e,c_(t)),cd=(e,t)=>tE(e,cK(t)),ch=e=>{let t=cD(e);return(e,r)=>tE(e,t(r))},cs=e=>{let t=c$(e);return(e,r)=>tE(e,t(r))},cm=(e,t)=>tE(e,uW(t)),cI=(e,t)=>tE(e,uy(t)),cg=nO,cR=()=>u_,cv=e=>t=>t.concat(e()),cW=cv,cM=e=>cy(t=>tE(e,cU(t))),cy=/*#__PURE__*/tw(2,(e,t)=>tE(e,pp((e,r)=>t(r,e)))),cO=/*#__PURE__*/cy(tf),cU=e=>t=>t.map(t=>e(t)),cb=e=>t=>t.map((t,r)=>e(r,t)),cx=e=>{let t=[],r=[];for(let a of e)"Left"===a._tag?t.push(a.left):r.push(a.right);return lN(t,r)},cE=e=>t=>t.filter(e),cA=e=>t=>{let r=[];for(let a=0;a<t.length;a++){let n=e(a,t[a]);tq(n)&&r.push(n.value)}return r},cS=e=>cA((t,r)=>e(r)),cF=/*#__PURE__*/cS(tf),cT=e=>cw((t,r)=>e(r)),cw=e=>t=>{let r=[],a=[];for(let n=0;n<t.length;n++){let i=t[n];e(n,i)?a.push(i):r.push(i)}return lN(r,a)},ck=e=>cq((t,r)=>e(r)),cq=e=>t=>{let r=[],a=[];for(let n=0;n<t.length;n++){let i=e(n,t[n]);"Left"===i._tag?r.push(i.left):a.push(i.right)}return lN(r,a)},c_=e=>t=>t.filter((t,r)=>e(r,t)),cK=e=>t=>t.map((r,a)=>e(t.slice(a))),cj=/*#__PURE__*/cK(tf),cL=e=>t=>r=>r.reduce((r,a,n)=>e.concat(r,t(n,a)),e.empty),cN=(e,t)=>cP(e,(e,r,a)=>t(r,a)),cC=e=>{let t=cL(e);return e=>t((t,r)=>e(r))},cP=(e,t)=>r=>{let a=r.length,n=e;for(let e=0;e<a;e++)n=t(e,n,r[e]);return n},cz=(e,t)=>cB(e,(e,r,a)=>t(r,a)),cB=(e,t)=>r=>r.reduceRight((e,r,a)=>t(a,r,e),e),cD=e=>{let t=c$(e);return e=>t((t,r)=>e(r))},cV=e=>t=>cn(t,e.of(cR()),(t,r)=>e.ap(e.map(t,e=>t=>tE(e,l3(t))),r)),c$=e=>t=>cP(e.of(cR()),(r,a,n)=>e.ap(e.map(a,e=>t=>tE(e,l3(t))),t(r,n))),cJ=e=>{let t=uU(e);return e=>r=>t(r,e)},cH=e=>{let t=ub(e);return e=>r=>t(r,e)},cZ=(e,t)=>{let r=[],a=e;// eslint-disable-next-line no-constant-condition
for(;;){let e=t(a);if(tq(e)){let[t,n]=e.value;r.push(t),a=n}else break}return r},cY="ReadonlyArray",cG=e=>({show:t=>`[${t.map(e.show).join(", ")}]`}),cQ=()=>({concat:(e,t)=>lX(e)?t:lX(t)?e:e.concat(t)}),cX=()=>({concat:cQ().concat,empty:u_}),c0=e=>rb((t,r)=>t.length===r.length&&t.every((t,a)=>e.equals(t,r[a]))),c1=e=>rD((t,r)=>{let a=t.length,n=r.length,i=Math.min(a,n);for(let a=0;a<i;a++){let n=e.compare(t[a],r[a]);if(0!==n)return n}return lF.compare(a,n)}),c2=e=>{let t=p1(e);return{concat:(e,r)=>t(r)(e)}},c3=e=>({concat:c2(e).concat,empty:u_}),c4=e=>{let t=p2(e);return{concat:(e,r)=>t(r)(e)}},c5=e=>{let t=p3(e);return{concat:(e,r)=>t(r)(e)}},c7={URI:cY,map:p4},c6=/*#__PURE__*/ri(c7),c8={URI:cY,of:cg},c9={URI:cY,map:p4,mapWithIndex:p5},ue={URI:cY,map:p4,ap:p7},ut=/*#__PURE__*/t4(ue),ur=/*#__PURE__*/t5(ue),ua={URI:cY,map:p4,ap:p7,of:cg},un={URI:cY,map:p4,ap:p7,chain:cy},ui={URI:cY,map:p4,ap:p7,of:cg,chain:cy},uo=/*#__PURE__*/rh(un),ul={URI:cY,unfold:cZ},up={URI:cY,map:p4,alt:ca},uc={URI:cY,zero:cR},uu=/*#__PURE__*/lQ(uc,c8),uf={URI:cY,map:p4,ap:p7,of:cg,alt:ca,zero:cR},ud={URI:cY,map:p4,extend:cd},uh={URI:cY,compact:cF,separate:cx},us={URI:cY,map:p4,compact:cF,separate:cx,filter:p6,filterMap:p8,partition:p9,partitionMap:ce},um={URI:cY,map:p4,mapWithIndex:p5,compact:cF,separate:cx,filter:p6,filterMap:p8,partition:p9,partitionMap:ce,partitionMapWithIndex:cr,partitionWithIndex:ct,filterMapWithIndex:cu,filterWithIndex:cf},uI={URI:cY,reduce:cn,foldMap:ci,reduceRight:co},ug={URI:cY,reduce:cn,foldMap:ci,reduceRight:co,reduceWithIndex:cl,foldMapWithIndex:cp,reduceRightWithIndex:cc},uR={URI:cY,map:p4,reduce:cn,foldMap:ci,reduceRight:co,traverse:ch,sequence:cV},uv={URI:cY,map:p4,mapWithIndex:p5,reduce:cn,foldMap:ci,reduceRight:co,reduceWithIndex:cl,foldMapWithIndex:cp,reduceRightWithIndex:cc,traverse:ch,sequence:cV,traverseWithIndex:cs},uW=e=>t=>{let r=[...e(t)],a=[];for(;r.length>0;){let t=r.shift();tj(t)?r.unshift(...e(t.left)):a.push(t.right)}return a},uM={URI:cY,map:p4,ap:p7,chain:cy,chainRec:cm},uy=e=>t=>{let r=e(t),a=[],n=[];function i(t){tj(t)?e(t.left).forEach(e=>a.push(e)):n.push(t.right)}for(let e of r)i(e);for(;a.length>0;)i(a.shift());return n},uO={URI:cY,map:p4,ap:p7,chain:cy,chainRec:cI},uU=/*#__PURE__*/lY(uR,uh),ub=/*#__PURE__*/lZ(uR,uh),ux={URI:cY,map:p4,compact:cF,separate:cx,filter:p6,filterMap:p8,partition:p9,partitionMap:ce,reduce:cn,foldMap:ci,reduceRight:co,traverse:ch,sequence:cV,wither:uU,wilt:ub},uE=/*#__PURE__*/lG(ux),uA={URI:cY,fromEither:l9},uS=/*#__PURE__*/rW(uA),uF=aV,uT=(e,t,r)=>l0(r)?a$(e,t,r):r,uw=(e,t)=>{let r=t.slice();return r.splice(e,1),r},uk=e=>e.slice(),uq=e=>lX(e)?u_:e.slice(),u_=aL;function uK(e){return t=>t.every(e)}/**
 * Check if a predicate holds true for any array member.
 *
 * @example
 * import { some } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const isPositive = (n: number): boolean => n > 0
 *
 * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)
 * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)
 *
 * @since 2.9.0
 */let uj=e=>t=>t.some(e),uL=uj,uN=e=>{let t=iM(e);return r=>pt(()=>e.empty,t(r))},uC=/*#__PURE__*/cg(t$),uP=/*#__PURE__*/ro(c7),uz=/*#__PURE__*/rl(c7),uB=/*#__PURE__*/rm(un),uD=/*#__PURE__*/t7(ue),uV=cy,u$=a0,uJ=iA,uH=iS,uZ=pz,uY={URI:cY,compact:cF,separate:cx,map:p4,ap:p7,of:cg,chain:cy,filter:p6,filterMap:p8,partition:p9,partitionMap:ce,mapWithIndex:p5,partitionMapWithIndex:cr,partitionWithIndex:ct,filterMapWithIndex:cu,filterWithIndex:cf,alt:ca,zero:cR,unfold:cZ,reduce:cn,foldMap:ci,reduceRight:co,traverse:ch,sequence:cV,reduceWithIndex:cl,foldMapWithIndex:cp,reduceRightWithIndex:cc,traverseWithIndex:cs,extend:cd,wither:uU,wilt:ub},uG=e=>0===e.length,uQ=iq,uX=ij,u0=iK,u1=iN,u2=iL,u3=(e,t)=>e<=0?[]:iH(t)(e),u4=(e,t)=>u3(e,()=>t);function u5(e){return t=>e(t)?[t]:[]}// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * Create an array from an `Option`. The resulting array will contain the content of the
 * `Option` if it is `Some` and it will be empty if the `Option` is `None`.
 *
 * @example
 * import { fromOption } from 'fp-ts/Array'
 * import { option } from "fp-ts";
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(option.some("a"), fromOption),["a"])
 * assert.deepStrictEqual(pipe(option.none, fromOption),[])
 *
 * @category conversions
 * @since 2.11.0
 */let u7=e=>tk(e)?[]:[e.value],u6=e=>tj(e)?[]:[e.right],u8=(e,t)=>r=>uQ(r)?t(r):e(),u9=u8,fe=(e,t)=>r=>uQ(r)?t(la(r),ln(r)):e(),ft=fe,fr=ft,fa=(e,t)=>r=>uQ(r)?t(lo(r),li(r)):e(),fn=fa,fi=fn,fo=e=>t=>{let r=[];for(let a=0;a<t.length;a++){let n=e(a,t[a]);for(let e=0;e<n.length;e++)r.push(n[e])}return r},fl=(e,t)=>r=>{let a=r.length,n=Array.from({length:a+1});n[0]=e;for(let e=0;e<a;e++)n[e+1]=t(n[e],r[e]);return n},fp=(e,t)=>r=>{let a=r.length,n=Array.from({length:a+1});n[a]=e;for(let e=a-1;e>=0;e--)n[e]=t(r[e],n[e+1]);return n},fc=e=>e.length,fu=i_,ff=ph,fd=ps,fh=pm,fs=e=>uQ(e)?tK(ln(e)):t_,fm=e=>uQ(e)?tK(lo(e)):t_,fI=e=>t=>fu(e,t)?fF(t):t.slice(0,e),fg=e=>t=>fu(e,t)?fF(t):0===e?[]:t.slice(-e);function fR(e){return t=>{let r=[];for(let a of t){if(!e(a))break;r.push(a)}return r}}let fv=(e,t)=>{let r=e.length,a=0;for(;a<r&&t(e[a]);a++);return a};function fW(e){return t=>{let[r,a]=fH(fv(t,e))(t);return{init:r,rest:a}}}/**
 * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { dropLeft } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);
 * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);
 * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);
 * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);
 *
 * @since 2.0.0
 */let fM=e=>t=>e<=0||uG(t)?fF(t):e>=t.length?[]:t.slice(e,t.length),fy=e=>t=>e<=0||uG(t)?fF(t):e>=t.length?[]:t.slice(0,t.length-e);function fO(e){return t=>t.slice(fv(t,e))}/**
 * `findIndex` returns an `Option` containing the first index for which a predicate holds.
 * It returns `None` if no element satisfies the predicate.
 * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.
 *
 * @example
 * import { findIndex } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
 *
 * @since 2.0.0
 */let fU=px;function fb(e){return pE(e)}/**
 * Given a selector function which takes an element and returns an option,
 * this function applies the selector to each element of the array and
 * returns the first `Some` result. Otherwise it returns `None`.
 *
 * @example
 * import { findFirstMap } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string;
 *   readonly age: number;
 * }
 *
 * const persons: Array<Person> = [
 *   { name: "John", age: 16 },
 *   { name: "Mary", age: 45 },
 *   { name: "Joey", age: 28 },
 * ];
 *
 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some("Mary"));
 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);
 *
 * @since 2.0.0
 */let fx=pA;function fE(e){return pS(e)}/**
 * Given a selector function which takes an element and returns an option,
 * this function applies the selector to each element of the array starting from the
 * end and returns the last `Some` result. Otherwise it returns `None`.
 *
 * @example
 * import { findLastMap } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string;
 *   readonly age: number;
 * }
 *
 * const persons: Array<Person> = [
 *   { name: "John", age: 16 },
 *   { name: "Mary", age: 45 },
 *   { name: "Joey", age: 28 },
 * ];
 *
 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some("Joey"));
 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);
 *
 * @since 2.0.0
 */let fA=pF,fS=pT,fF=e=>e.slice(),fT=(e,t)=>r=>e<0||e>r.length?t_:tK(hA(e,t,r)),fw=(e,t)=>fq(e,()=>t),fk=e=>t=>fu(e,t)?t_:tK(hF(e,t)),fq=(e,t)=>r=>fu(e,r)?t_:tK(hS(e,t(r[e]),r)),f_=e=>uG(e)?[]:e.slice().reverse(),fK=e=>{let t=[];for(let r=0;r<e.length;r++){let a=e[r];"Right"===a._tag&&t.push(a.right)}return t},fj=e=>{let t=[];for(let r=0;r<e.length;r++){let a=e[r];"Left"===a._tag&&t.push(a.left)}return t},fL=e=>t=>t.length<=1?fF(t):t.slice().sort(e.compare),fN=(e,t,r)=>{let a=[],n=Math.min(e.length,t.length);for(let i=0;i<n;i++)a[i]=r(e[i],t[i]);return a},fC=e=>{let t=[],r=[];for(let a=0;a<e.length;a++)t[a]=e[a][0],r[a]=e[a][1];return[t,r]},fP=e=>{let t=or(e);return e=>uQ(e)?t(e):[]},fz=e=>{let t=oa(e);return e=>uQ(e)?t(e):fF(e)},fB=e=>{let t=iV(e);return e=>uQ(e)?t(e):fF(e)},fD=pV,fV=e=>{let t=iz(e);return e=>uQ(e)?t(e):fF(e)},f$=e=>{let t=iB(e);return e=>uQ(e)?t(e):fF(e)},fJ=e=>{let t=ol(e);return e=>uQ(e)?t(e):[]},fH=e=>t=>e>=1&&uQ(t)?op(e)(t):uG(t)?[fF(t),[]]:[[],fF(t)],fZ=e=>{let t=oc(e);return e=>uQ(e)?t(e):[]},fY=e=>(...t)=>u7(e(...t));function fG(e,t,r=()=>!0){let a=(e,n)=>uQ(n)?dv(la(n),t=>a(tE(e,u1(t)),ln(n))):r(...e)?[t(...e)]:[];return a([],e)}/**
 * @since 2.11.0
 */let fQ=e=>t=>uG(t)?fF(e):uG(e)?fF(t):t.concat(e),fX=fQ;function f0(e){let t=iD(e);return(r,a)=>{if(void 0===a){let t=f0(e);return e=>t(e,r)}return uQ(r)&&uQ(a)?t(a)(r):uQ(r)?fF(r):fF(a)}}function f1(e){let t=fD(e);return(r,a)=>{if(void 0===a){let t=f1(e);return e=>t(e,r)}return r.filter(e=>t(e,a))}}function f2(e){let t=fD(e);return(r,a)=>{if(void 0===a){let t=f2(e);return e=>t(e,r)}return r.filter(e=>!t(e,a))}}let f3=(e,t)=>tE(e,dg(t)),f4=(e,t)=>tE(e,dM(t)),f5=(e,t)=>tE(e,dR(t)),f7=(e,t)=>tE(e,dx(t)),f6=(e,t)=>tE(e,dO(t)),f8=(e,t)=>tE(e,dE(t)),f9=(e,t)=>tE(e,dS(t)),de=(e,t)=>tE(e,dA(t)),dt=(e,t)=>tE(e,dF(t)),dr=(e,t)=>tE(e,dw(t)),da=(e,t,r)=>tE(e,dL(t,r)),dn=e=>{let t=dK(e);return(e,r)=>tE(e,t(r))},di=(e,t,r)=>tE(e,dC(t,r)),dl=(e,t,r)=>tE(e,dN(t,r)),dp=e=>{let t=dj(e);return(e,r)=>tE(e,t(r))},dc=(e,t,r)=>tE(e,dP(t,r)),du=(e,t)=>tE(e,dy(t)),df=(e,t)=>tE(e,dk(t)),dd=(e,t)=>tE(e,dq(t)),dh=e=>{let t=dz(e);return(e,r)=>tE(e,t(r))},ds=e=>{let t=dD(e);return(e,r)=>tE(e,t(r))},dm=i9,dI=()=>[],dg=e=>t=>t.map(t=>e(t)),dR=e=>dv(t=>tE(e,dg(t))),dv=/*#__PURE__*/tw(2,(e,t)=>tE(e,fo((e,r)=>t(r,e)))),dW=/*#__PURE__*/dv(tf),dM=e=>t=>t.map((t,r)=>e(r,t)),dy=e=>t=>{let r=[];for(let a=0;a<t.length;a++){let n=e(a,t[a]);tq(n)&&r.push(n.value)}return r},dO=e=>dy((t,r)=>e(r)),dU=/*#__PURE__*/dO(tf),db=e=>{let t=[],r=[];for(let a of e)"Left"===a._tag?t.push(a.left):r.push(a.right);return lN(t,r)},dx=e=>t=>t.filter(e),dE=e=>dA((t,r)=>e(r)),dA=e=>t=>{let r=[],a=[];for(let n=0;n<t.length;n++){let i=t[n];e(n,i)?a.push(i):r.push(i)}return lN(r,a)},dS=e=>dF((t,r)=>e(r)),dF=e=>t=>{let r=[],a=[];for(let n=0;n<t.length;n++){let i=e(n,t[n]);"Left"===i._tag?r.push(i.left):a.push(i.right)}return lN(r,a)},dT=e=>t=>t.concat(e()),dw=dT,dk=e=>t=>t.filter((t,r)=>e(r,t)),dq=e=>t=>t.map((r,a)=>e(t.slice(a))),d_=/*#__PURE__*/dq(tf),dK=cC,dj=cL,dL=cN,dN=cP,dC=cz,dP=cB,dz=e=>{let t=dD(e);return e=>t((t,r)=>e(r))},dB=e=>t=>da(t,e.of(dI()),(t,r)=>e.ap(e.map(t,e=>t=>tE(e,u1(t))),r)),dD=e=>t=>dN(e.of(dI()),(r,a,n)=>e.ap(e.map(a,e=>t=>tE(e,u1(t))),t(r,n))),dV=e=>{let t=hR(e);return e=>r=>t(r,e)},d$=e=>{let t=hv(e);return e=>r=>t(r,e)},dJ=(e,t)=>{let r=[],a=e;// eslint-disable-next-line no-constant-condition
for(;;){let e=t(a);if(tq(e)){let[t,n]=e.value;r.push(t),a=n}else break}return r},dH="Array",dZ=cG,dY=()=>({concat:(e,t)=>e.concat(t)}),dG=()=>({concat:dY().concat,empty:[]}),dQ=c0,dX=c1,d0=e=>{let t=f0(e);return{concat:(e,r)=>t(r)(e)}},d1=e=>({concat:d0(e).concat,empty:[]}),d2=e=>{let t=f1(e);return{concat:(e,r)=>t(r)(e)}},d3=e=>{let t=f2(e);return{concat:(e,r)=>t(r)(e)}},d4={URI:dH,map:f3},d5=/*#__PURE__*/ri(d4),d7={URI:dH,of:dm},d6={URI:dH,map:f3,mapWithIndex:f4},d8={URI:dH,map:f3,ap:f5},d9=/*#__PURE__*/t4(d8),he=/*#__PURE__*/t5(d8),ht={URI:dH,map:f3,ap:f5,of:dm},hr={URI:dH,map:f3,ap:f5,chain:dv},ha=/*#__PURE__*/rh(hr),hn={URI:dH,map:f3,ap:f5,of:dm,chain:dv},hi={URI:dH,unfold:dJ},ho={URI:dH,map:f3,alt:dr},hl={URI:dH,zero:dI},hp=/*#__PURE__*/lQ(hl,d7),hc={URI:dH,map:f3,ap:f5,of:dm,alt:dr,zero:dI},hu={URI:dH,map:f3,extend:dd},hf={URI:dH,compact:dU,separate:db},hd={URI:dH,map:f3,compact:dU,separate:db,filter:f7,filterMap:f6,partition:f8,partitionMap:f9},hh={URI:dH,map:f3,mapWithIndex:f4,compact:dU,separate:db,filter:f7,filterMap:f6,partition:f8,partitionMap:f9,partitionMapWithIndex:dt,partitionWithIndex:de,filterMapWithIndex:du,filterWithIndex:df},hs={URI:dH,reduce:da,foldMap:dn,reduceRight:di},hm={URI:dH,reduce:da,foldMap:dn,reduceRight:di,reduceWithIndex:dl,foldMapWithIndex:dp,reduceRightWithIndex:dc},hI={URI:dH,map:f3,reduce:da,foldMap:dn,reduceRight:di,traverse:dh,sequence:dB},hg={URI:dH,map:f3,mapWithIndex:f4,reduce:da,foldMap:dn,reduceRight:di,reduceWithIndex:dl,foldMapWithIndex:dp,reduceRightWithIndex:dc,traverse:dh,sequence:dB,traverseWithIndex:ds},hR=/*#__PURE__*/lY(hI,hf),hv=/*#__PURE__*/lZ(hI,hf),hW={URI:dH,map:f3,compact:dU,separate:db,filter:f7,filterMap:f6,partition:f8,partitionMap:f9,reduce:da,foldMap:dn,reduceRight:di,traverse:dh,sequence:dB,wither:hR,wilt:hv},hM=uW,hy={URI:dH,map:f3,ap:f5,chain:dv,chainRec:cm},hO=uy,hU={URI:dH,map:f3,ap:f5,chain:dv,chainRec:cI},hb=/*#__PURE__*/lG(hW),hx={URI:dH,fromEither:u6},hE=/*#__PURE__*/rW(hx),hA=iC,hS=(e,t,r)=>uQ(r)?iP(e,t,r):[],hF=(e,t)=>{let r=t.slice();return r.splice(e,1),r},hT=uK,hw=e=>t=>t.some(e),hk=hw,hq=uN,h_=/*#__PURE__*/dm(t$),hK=/*#__PURE__*/ro(d4),hj=/*#__PURE__*/rl(d4),hL=/*#__PURE__*/rm(hr),hN=/*#__PURE__*/t7(d8),hC=dv,hP=iY,hz=[],hB=lO,hD=lU,hV=fP,h$={URI:dH,compact:dU,separate:db,map:f3,ap:f5,of:dm,chain:dv,filter:f7,filterMap:f6,partition:f8,partitionMap:f9,mapWithIndex:f4,partitionMapWithIndex:dt,partitionWithIndex:de,filterMapWithIndex:du,filterWithIndex:df,alt:dr,zero:dI,unfold:dJ,reduce:da,foldMap:dn,reduceRight:di,traverse:dh,sequence:dB,reduceWithIndex:dl,foldMapWithIndex:dp,reduceRightWithIndex:dc,traverseWithIndex:ds,extend:dd,wither:hR,wilt:hv},hJ=e=>"boolean"==typeof e,hH=(e,t)=>r=>r?t():e(),hZ=hH,hY=hZ,hG=hY,hQ={equals:(e,t)=>e===t},hX={meet:(e,t)=>e&&t,join:(e,t)=>e||t,zero:!1,one:!0,implies:(e,t)=>!e||t,not:e=>!e},h0={concat:(e,t)=>e&&t},h1={concat:(e,t)=>e||t},h2={concat:h0.concat,empty:!0},h3={concat:h1.concat,empty:!1},h4={equals:hQ.equals,compare:(e,t)=>e<t?-1:+(e>t)},h5={show:e=>JSON.stringify(e)},h7=e=>({meet:(t,r)=>e.join(t,r),join:(t,r)=>e.meet(t,r),zero:e.one,one:e.zero,implies:(t,r)=>e.join(e.not(t),r),not:e.not}),h6={meet:()=>void 0,join:()=>void 0,zero:void 0,one:void 0,implies:()=>void 0,not:()=>void 0},h8=h7,h9={meet:(e,t)=>e&&t,join:(e,t)=>e||t,zero:!1,one:!0,implies:(e,t)=>!e||t,not:e=>!e},se=ti,st=e=>r7(e)(e.bottom,e.top),sr=e=>{let t=r$(e);return{equals:t.equals,compare:t.compare,top:e.bottom,bottom:e.top}},sa={equals:an.equals,compare:an.compare,top:1/0,bottom:-1/0};/**
 * A `DistributiveLattice` must satisfy the following laws in addition to `Lattice` laws:
 *
 * - Distributivity for meet: `a  (b  c) <-> (a  b)  (a  c)`
 * - Distributivity for join: `a  (b  c) <-> (a  b)  (a  c)`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */function sn(e){return{meet:r4(e),join:r5(e)}}/**
 * A `BoundedDistributiveLattice` is a lattice that is both bounded and distributive
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */function si(e){let t=sn(e);return(e,r)=>({join:t.join,meet:t.meet,zero:e,one:r})}/**
 * A `BoundedJoinSemilattice` must satisfy the following laws in addition to `JoinSemilattice` laws:
 *
 * - `a  0 <-> a`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * A `BoundedLattice` must satisfy the following in addition to `BoundedMeetSemilattice` and `BoundedJoinSemilattice` laws:
 *
 * - Absorption law for meet: `a  (a  b) <-> a`
 * - Absorption law for join: `a  (a  b) <-> a`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * A `BoundedMeetSemilattice` must satisfy the following laws in addition to `MeetSemilattice` laws:
 *
 * - `a  1 <-> a`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * @since 2.0.0
 *//**
 * @category model
 * @since 2.0.0
 *//**
 * @since 2.0.0
 *//**
 * @since 2.0.0
 */let so=(e,t)=>{let r=t(e);for(;"Left"===r._tag;)r=t(r.left);return r.right};/**
 * The `Choice` class extends `Profunctor` with combinators for working with
 * sum types.
 *
 * `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 * `Right` components of a sum, respectively.
 *
 * Looking at `Choice` through the intuition of inputs and outputs
 * yields the following type signature:
 *
 * ```purescript
 * left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 * right :: forall input output a. p input output -> p (Either a input) (Either a output)
 * ```
 *
 * If we specialize the profunctor `p` to the `function` arrow, we get the following type
 * signatures:
 *
 * ```purescript
 * left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 * right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 * ```
 *
 * When the `profunctor` is `Function` application, `left` allows you to map a function over the
 * left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 *
 * Adapted from https://github.com/purescript/purescript-profunctor/blob/master/src/Data/Profunctor/Choice.purs
 *
 * @since 2.0.0
 */function sl(e,t){return(r,a)=>t.compose(e.right(a),e.left(r))}function sp(e,t){let r=sl(e,t);return(a,n)=>t.compose(e.promap(t.id(),e=>"Left"===e._tag?e.left:e.right,tf),r(a,n))}function sc(e){return sl(e,e)}function su(e){return sp(e,e)}/**
 * @since 2.11.0
 */let sf=e=>t=>tW(e,t),sd="Predicate",sh=()=>({concat:(e,t)=>tE(e,sv(t))}),ss=()=>({concat:sh().concat,empty:tm}),sm=()=>({concat:(e,t)=>tE(e,sW(t))}),sI=()=>({concat:sm().concat,empty:ts}),sg={URI:sd,contramap:(e,t)=>tE(e,sf(t))},sR=e=>t=>!e(t),sv=e=>t=>r=>t(r)||e(r),sW=e=>t=>r=>t(r)&&e(r),sM=t_,sy=tK;function sO(e){return t=>e(t)?sy(t):sM}/**
 * Returns the `Left` value of an `Either` if possible.
 *
 * @example
 * import { getLeft, none, some } from 'fp-ts/Option'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(getLeft(right(1)), none)
 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
 *
 * @category constructors
 * @since 2.0.0
 */let sU=e=>"Right"===e._tag?sM:sy(e.left),sb=e=>"Left"===e._tag?sM:sy(e.right),sx=(e,t)=>tE(e,sB(t)),sE=(e,t)=>tE(e,sZ(t)),sA=(e,t,r)=>tE(e,s1(t,r)),sS=e=>{let t=s2(e);return(e,r)=>tE(e,t(r))},sF=(e,t,r)=>tE(e,s3(t,r)),sT=e=>{let t=ms(e);return(e,r)=>tE(e,t(r))},sw=(e,t)=>tE(e,s6(t)),sk=(e,t)=>tE(e,mc(t)),sq=(e,t)=>tE(e,mu(t)),s_=(e,t)=>tE(e,ma(t)),sK=(e,t)=>tE(e,mf(t)),sj=(e,t)=>tE(e,md(t)),sL="Option",sN=e=>({show:t=>mE(t)?"none":`some(${e.show(t.value)})`}),sC=e=>({equals:(t,r)=>t===r||(mE(t)?mE(r):!mE(r)&&e.equals(t.value,r.value))}),sP=e=>({equals:sC(e).equals,compare:(t,r)=>t===r?0:mx(t)?mx(r)?e.compare(t.value,r.value):1:mx(r)?-1:0}),sz=e=>({concat:(t,r)=>mE(t)?r:mE(r)?t:sy(e.concat(t.value,r.value)),empty:sM}),sB=e=>t=>mE(t)?sM:sy(e(t.value)),sD={URI:sL,map:sx},sV=tw(2,rc(sD)),s$=ru(sD),sJ=sy,sH={URI:sL,of:sJ},sZ=e=>t=>mE(t)||mE(e)?sM:sy(t.value(e.value)),sY={URI:sL,map:sx,ap:sE},sG={URI:sL,map:sx,ap:sE,of:sJ},sQ=/*#__PURE__*/tw(2,(e,t)=>mE(e)?sM:t(e.value)),sX={URI:sL,map:sx,ap:sE,chain:sQ},s0={URI:sL,map:sx,ap:sE,of:sJ,chain:sQ},s1=(e,t)=>r=>mE(r)?e:t(e,r.value),s2=e=>t=>r=>mE(r)?e.empty:t(r.value),s3=(e,t)=>r=>mE(r)?e:t(r.value,e),s4={URI:sL,reduce:sA,foldMap:sS,reduceRight:sF},s5=tw(2,(e,t)=>mE(e)?t():e),s7=s5,s6=s5,s8={URI:sL,map:sx,alt:sw},s9=()=>sM,me={URI:sL,zero:s9},mt=/*#__PURE__*/lQ(me,sH),mr={URI:sL,map:sx,ap:sE,of:sJ,alt:sw,zero:s9},ma=e=>t=>mE(t)?sM:sy(e(t)),mn={URI:sL,map:sx,extend:s_},mi=/*#__PURE__*/sQ(tf),mo=/*#__PURE__*/lN(sM,sM),ml=e=>mE(e)?mo:lN(sU(e.value),sb(e.value)),mp={URI:sL,compact:mi,separate:ml},mc=e=>t=>mE(t)?sM:e(t.value)?t:sM,mu=e=>t=>mE(t)?sM:e(t.value),mf=e=>t=>lN(sk(t,sR(e)),sk(t,e)),md=e=>tW(sB(e),ml),mh={URI:sL,map:sx,compact:mi,separate:ml,filter:sk,filterMap:sq,partition:sK,partitionMap:sj},ms=e=>t=>r=>mE(r)?e.of(sM):e.map(t(r.value),sy),mm=e=>t=>mE(t)?e.of(sM):e.map(t.value,sy),mI={URI:sL,map:sx,reduce:sA,foldMap:sS,reduceRight:sF,traverse:sT,sequence:mm},mg=/*#__PURE__*/lY(mI,mp),mR=/*#__PURE__*/lZ(mI,mp),mv=e=>{let t=mg(e);return e=>r=>t(r,e)},mW=e=>{let t=mR(e);return e=>r=>t(r,e)},mM={URI:sL,map:sx,reduce:sA,foldMap:sS,reduceRight:sF,traverse:sT,sequence:mm,compact:mi,separate:ml,filter:sk,filterMap:sq,partition:sK,partitionMap:sj,wither:mg,wilt:mR},my=()=>sM,mO={URI:sL,map:sx,ap:sE,of:sJ,chain:sQ,throwError:my},mU=sb,mb={URI:sL,fromEither:mU},mx=tq,mE=e=>"None"===e._tag,mA=(e,t)=>r=>mE(r)?e():t(r.value),mS=mA,mF=mA,mT=mF,mw=e=>t=>mE(t)?e():t.value,mk=mw,mq=/*#__PURE__*/ri(sD),m_=/*#__PURE__*/t4(sY),mK=/*#__PURE__*/t5(sY),mj=mi,mL=/*#__PURE__*/tw(2,rs(sX)),mN=/*#__PURE__*/tw(2,rU(mb,sX)),mC=/*#__PURE__*/ma(tf),mP=/*#__PURE__*/rW(mb),mz=/*#__PURE__*/rM(mb,sX),mB=mN,mD=e=>null==e?sM:sy(e),mV=e=>{try{return sy(e())}catch(e){return sM}},m$=e=>(...t)=>mV(()=>e(...t)),mJ=e=>tW(e,mD),mH=e=>t=>mE(t)?sM:mD(e(t.value)),mZ=/*#__PURE__*/mF(tI,tf),mY=/*#__PURE__*/mF(tg,tf),mG=e=>t=>!mE(t)&&e(t.value),mQ=/*#__PURE__*/sJ(t$),mX=/*#__PURE__*/ro(sD),m0=/*#__PURE__*/rl(sD),m1=/*#__PURE__*/rm(sX),m2=/*#__PURE__*/t7(sY),m3=/*#__PURE__*/sJ(tV),m4=e=>t=>{let r=e(0,tB(t));if(mE(r))return sM;let a=[r.value];for(let r=1;r<t.length;r++){let n=e(r,t[r]);if(mE(n))return sM;a.push(n.value)}return sy(a)},m5=e=>{let t=m4(e);return e=>tz(e)?t(e):m3},m7=m5,m6=e=>m5((t,r)=>e(r)),m8=/*#__PURE__*/m6(tf),m9=sQ,Ie=mL;// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `Refinement` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function It(e){return t=>mx(e(t))}/**
 * Use [`chainNullableK`](#chainnullablek) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let Ir=mH,Ia={URI:sL,map:sx,of:sJ,ap:sE,chain:sQ,reduce:sA,foldMap:sS,reduceRight:sF,traverse:sT,sequence:mm,zero:s9,alt:sw,extend:s_,compact:mi,separate:ml,filter:sk,filterMap:sq,partition:sK,partitionMap:sj,wither:mg,wilt:mR,throwError:my},In=/*#__PURE__*/t6(sY),Ii=/*#__PURE__*/rf(sG),Io=()=>sz(aR()),Il=()=>sz(av());/**
 * `Compactable` represents data structures which can be _compacted_/_filtered_. This is a generalization of
 * `catOptions` as a new function `compact`. `compact` has relations with `Functor`, `Applicative`,
 * `Monad`, `Alternative`, and `Traversable` in that we can use these classes to provide the ability to
 * operate on a data type by eliminating intermediate `None`s. This is useful for representing the filtering out of
 * values, or failure.
 *
 * Adapted from https://github.com/LiamGoodacre/purescript-filterable/blob/master/src/Data/Compactable.purs
 *
 * @since 2.0.0
 */function Ip(e,t){return r=>e.map(r,t.compact)}function Ic(e,t,r){let a=Ip(e,t),n=rn(e,r);return e=>lN(a(tE(e,n(sU))),a(tE(e,n(sb))))}/** @deprecated */function Iu(e,t){return{map:rp(e,t).map,compact:Ip(e,t),separate:Ic(e,t,t)}}/**
 * @since 2.0.0
 *//**
 * @since 2.0.0
 */let If=e=>()=>console.log(e),Id=e=>()=>console.warn(e),Ih=e=>()=>console.error(e),Is=e=>()=>console.info(e),Im=td;/**
 * @category instances
 * @since 2.0.0
 */function II(e){return{show:t=>`make(${e.show(t)})`}}/**
 * @category instances
 * @since 2.0.0
 */let Ig=tf,IR=tf,Iv=tf,IW=tf,IM=tf,Iy=tf,IO=tf,IU=tf,Ib=tf;/**
 * @category instances
 * @since 2.0.0
 */function Ix(e){return{URI:IK,_E:void 0,map:IS,ap:(t,r)=>Im(e.concat(t,r))}}/**
 * @category instances
 * @since 2.0.0
 */function IE(e){let t=Ix(e);return{URI:IK,_E:void 0,map:t.map,ap:t.ap,of:()=>Im(e.empty)}}let IA=(e,t)=>tE(e,Iw(t)),IS=(e,t)=>tE(e,Ik(t)),IF=(e,t,r)=>tE(e,Iq(t,r)),IT=(e,t)=>tE(e,I_(t)),Iw=()=>td,Ik=()=>td,Iq=e=>t=>Im(e(t)),I_=e=>t=>Im(e(t)),IK="Const",Ij={URI:IK,map:IS},IL=/*#__PURE__*/ri(Ij),IN={URI:IK,contramap:IA},IC={URI:IK,bimap:IF,mapLeft:IT},IP={URI:IK,map:IS,contramap:IA,bimap:IF,mapLeft:IT},Iz={equals:(e,t)=>e.valueOf()===t.valueOf()},IB={equals:(e,t)=>e.getDate()===t.getDate()},ID={equals:(e,t)=>e.getMonth()===t.getMonth()},IV={equals:(e,t)=>e.getFullYear()===t.getFullYear()},I$=/*#__PURE__*/tE(lF,/*#__PURE__*/rJ(e=>e.valueOf())),IJ=()=>new Date,IH=()=>new Date().getTime(),IZ=tN,IY=tC,IG=/*#__PURE__*/tw(2,(e,t)=>gP(e)?e:t(e.right)),IQ=(e,t)=>tE(e,gp(t)),IX=(e,t)=>tE(e,gm(t)),I0=(e,t,r)=>tE(e,gW(t,r)),I1=e=>(t,r)=>tE(t,gM(e)(r)),I2=(e,t,r)=>tE(e,gy(t,r)),I3=e=>{let t=gU(e);return(e,r)=>tE(e,t(r))},I4=(e,t,r)=>tE(e,gE(t,r)),I5=(e,t)=>tE(e,gA(t)),I7=(e,t)=>tE(e,gT(t)),I6=(e,t)=>tE(e,gk(t)),I8=(e,t)=>so(t(e),e=>gP(e)?IY(IZ(e.left)):gP(e.right)?IZ(t(e.right.left)):IY(IY(e.right.right))),I9="Either",ge=(e,t)=>({show:r=>gP(r)?`left(${e.show(r.left)})`:`right(${t.show(r.right)})`}),gt=(e,t)=>({equals:(r,a)=>r===a||(gP(r)?gP(a)&&e.equals(r.left,a.left):gz(a)&&t.equals(r.right,a.right))}),gr=e=>({concat:(t,r)=>gP(r)?t:gP(t)?r:IY(e.concat(t.right,r.right))}),ga=e=>{let t=IZ(e.empty);return{URI:I9,_E:void 0,compact:e=>gP(e)?e:"None"===e.right._tag?t:IY(e.right.value),separate:e=>gP(e)?lN(e,e):gP(e.right)?lN(IY(e.right.left),t):lN(t,IY(e.right.right))}},gn=e=>{let t=IZ(e.empty),{compact:r,separate:a}=ga(e);return{URI:I9,_E:void 0,map:IQ,compact:r,separate:a,filter:(e,r)=>gP(e)||r(e.right)?e:t,filterMap:(e,r)=>{if(gP(e))return e;let a=r(e.right);return"None"===a._tag?t:IY(a.value)},partition:(e,r)=>gP(e)?lN(e,e):r(e.right)?lN(t,IY(e.right)):lN(IY(e.right),t),partitionMap:(e,r)=>{if(gP(e))return lN(e,e);let a=r(e.right);return gP(a)?lN(IY(a.left),t):lN(t,IY(a.right))}}},gi=e=>{let t=gn(e),r=ga(e);return{URI:I9,_E:void 0,map:IQ,compact:t.compact,separate:t.separate,filter:t.filter,filterMap:t.filterMap,partition:t.partition,partitionMap:t.partitionMap,traverse:I3,sequence:gb,reduce:I0,foldMap:I1,reduceRight:I2,wither:lY(gx,r),wilt:lZ(gx,r)}},go=e=>({URI:I9,_E:void 0,map:IQ,ap:(t,r)=>gP(t)?gP(r)?IZ(e.concat(t.left,r.left)):t:gP(r)?r:IY(t.right(r.right)),of:gd}),gl=e=>({URI:I9,_E:void 0,map:IQ,alt:(t,r)=>{if(gz(t))return t;let a=r();return gP(a)?IZ(e.concat(t.left,a.left)):a}}),gp=e=>t=>gP(t)?t:IY(e(t.right)),gc={URI:I9,map:IQ},gu=tw(2,rc(gc)),gf=ru(gc),gd=IY,gh={URI:I9,of:gd},gs=e=>t=>gP(t)?t:gP(e)?e:IY(t.right(e.right)),gm=gs,gI={URI:I9,map:IQ,ap:IX},gg={URI:I9,map:IQ,ap:IX,of:gd},gR={URI:I9,map:IQ,ap:IX,chain:IG},gv={URI:I9,map:IQ,ap:IX,of:gd,chain:IG},gW=(e,t)=>r=>gP(r)?e:t(e,r.right),gM=e=>t=>r=>gP(r)?e.empty:t(r.right),gy=(e,t)=>r=>gP(r)?e:t(r.right,e),gO={URI:I9,reduce:I0,foldMap:I1,reduceRight:I2},gU=e=>t=>r=>gP(r)?e.of(IZ(r.left)):e.map(t(r.right),IY),gb=e=>t=>gP(t)?e.of(IZ(t.left)):e.map(t.right,IY),gx={URI:I9,map:IQ,reduce:I0,foldMap:I1,reduceRight:I2,traverse:I3,sequence:gb},gE=(e,t)=>r=>gP(r)?IZ(e(r.left)):IY(t(r.right)),gA=e=>t=>gP(t)?IZ(e(t.left)):t,gS={URI:I9,bimap:I4,mapLeft:I5},gF=e=>t=>gP(t)?e():t,gT=gF,gw={URI:I9,map:IQ,alt:I7},gk=e=>t=>gP(t)?t:IY(e(t)),gq={URI:I9,map:IQ,extend:I6},g_={URI:I9,map:IQ,ap:IX,chain:IG,chainRec:I8},gK=IZ,gj={URI:I9,map:IQ,ap:IX,of:gd,chain:IG,throwError:gK},gL={URI:I9,fromEither:tf},gN=/*#__PURE__*/rg(gL),gC=/*#__PURE__*/rI(gL),gP=tj,gz=tL,gB=(e,t)=>r=>gP(r)?e(r.left):t(r.right),gD=gB,gV=gB,g$=gV,gJ=e=>t=>gP(t)?e(t.left):t.right,gH=gJ,gZ=/*#__PURE__*/ri(gc),gY=/*#__PURE__*/t4(gI),gG=gY,gQ=/*#__PURE__*/t5(gI),gX=gQ,g0=/*#__PURE__*/tw(2,rs(gR)),g1=/*#__PURE__*/IG(tf),g2=g1,g3=/*#__PURE__*/gk(tf),g4=/*#__PURE__*/rR(gL),g5=/*#__PURE__*/rv(gL,gR),g7=g5,g6={fromEither:gL.fromEither},g8=/*#__PURE__*/tZ(g6),g9=/*#__PURE__*/tY(g6),Re={flatMap:IG},Rt=/*#__PURE__*/tG(g6,Re),Rr=/*#__PURE__*/tQ(g6,Re),Ra=/*#__PURE__*/rO(gL,gR),Rn=Ra,Ri=e=>gP(e)?IY(e.left):IZ(e.right),Ro=e=>t=>gP(t)?e(t.left):t,Rl=Ro,Rp=e=>t=>null==t?IZ(e):IY(t),Rc=(e,t)=>{try{return IY(e())}catch(e){return IZ(t(e))}},Ru=(e,t)=>(...r)=>Rc(()=>e(...r),t),Rf=e=>{let t=Rp(e);return e=>tW(e,t)},Rd=e=>{let t=Rf(e);return e=>IG(t(e))},Rh=/*#__PURE__*/gD(tf,tf);// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Default value for the `onError` argument of `tryCatch`
 *
 * @since 2.0.0
 */function Rs(e){try{return e instanceof Error?e:Error(String(e))}catch(e){return Error()}}/**
 * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.
 *
 * @example
 * import { exists, left, right } from 'fp-ts/Either'
 *
 * const gt2 = exists((n: number) => n > 2)
 *
 * assert.strictEqual(gt2(left('a')), false)
 * assert.strictEqual(gt2(right(1)), false)
 * assert.strictEqual(gt2(right(3)), true)
 *
 * @since 2.0.0
 */let Rm=e=>t=>!gP(t)&&e(t.right),RI=/*#__PURE__*/gd(t$),Rg=/*#__PURE__*/ro(gc),RR=/*#__PURE__*/rl(gc),Rv=/*#__PURE__*/rm(gR),RW=Rv,RM=/*#__PURE__*/t7(gI),Ry=RM,RO=/*#__PURE__*/gd(tV),RU=e=>t=>{let r=e(0,tB(t));if(gP(r))return r;let a=[r.right];for(let r=1;r<t.length;r++){let n=e(r,t[r]);if(gP(n))return n;a.push(n.right)}return IY(a)},Rb=e=>{let t=RU(e);return e=>tz(e)?t(e):RO},Rx=Rb,RE=e=>Rb((t,r)=>e(r)),RA=/*#__PURE__*/RE(tf),RS=IG,RF=IG,RT=g0,Rw=g0;/**
 * Use [`parse`](./Json.ts.html#parse) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function Rk(e,t){return Rc(()=>JSON.parse(e),t)}/**
 * Use [`stringify`](./Json.ts.html#stringify) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let Rq=(e,t)=>Rc(()=>{let t=JSON.stringify(e);if("string"!=typeof t)throw Error("Converting unsupported structure to JSON");return t},t),R_={URI:I9,map:IQ,of:gd,ap:IX,chain:IG,reduce:I0,foldMap:I1,reduceRight:I2,traverse:I3,sequence:gb,bimap:I4,mapLeft:I5,alt:I7,extend:I6,chainRec:I8,throwError:gK},RK=/*#__PURE__*/t6(gI),Rj=/*#__PURE__*/rf(gg),RL=(e,t)=>t6(go(e))(t),RN=(e,t)=>rf(go(e))(t);/**
 * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function RC(e){return{URI:I9,_E:void 0,map:IQ,of:gd,chain:IG,bimap:I4,mapLeft:I5,reduce:I0,foldMap:I1,reduceRight:I2,extend:I6,traverse:I3,sequence:gb,chainRec:I8,throwError:gK,ap:go(e).ap,alt:gl(e).alt}}/**
 * The error monad transformer. It can be used to add error handling to other monads.
 *
 * The `of` function yields a successful computation, while `chain` sequences two subcomputations, failing on the first error.
 *
 * @since 2.0.0
 */function RP(e){return tW(IY,e.of)}function Rz(e){return tW(IZ,e.of)}function RB(e){return t=>e.map(t,IY)}function RD(e){return t=>e.map(t,IZ)}function RV(e){return t=>tW(Rp(t),e.of)}function R$(e){let t=RV(e);return e=>{let r=t(e);return e=>tW(e,r)}}function RJ(e){let t=RY(e),r=R$(e);return e=>{let a=r(e);return e=>t(a(e))}}function RH(e){return rn(e,gc)}function RZ(e){return t3(e,gI)}function RY(e){let t=RG(e);return e=>r=>t(r,e)}/** @internal */function RG(e){return(t,r)=>e.chain(t,t=>gP(t)?e.of(t):r(t.right))}function RQ(e){return t=>r=>e.chain(r,r=>gP(r)?t():e.of(r))}function RX(e){let t=R0(e);return(e,r)=>a=>t(a,e,r)}/** @internal */function R0(e){return(t,r,a)=>e.map(t,gE(r,a))}function R1(e){let t=R2(e);return e=>r=>t(r,e)}/** @internal */function R2(e){return(t,r)=>e.map(t,gA(r))}function R3(e,t){return r=>a=>e.chain(a,gV(a=>e.map(r(),gA(e=>t.concat(a,e))),RP(e)))}function R4(e){return(t,r)=>a=>e.map(a,gV(t,r))}function R5(e){return(t,r)=>a=>e.chain(a,gV(t,r))}function R7(e){return t=>r=>e.chain(r,gV(t,e.of))}function R6(e){return t=>r=>e.chain(r,r=>gP(r)?e.map(t(r.left),e=>e):e.of(r.right))}function R8(e){return t=>r=>e.chain(r,r=>gP(r)?t(r.left):e.of(r))}function R9(e){let t=ve(e);return e=>r=>t(r,e)}/** @internal */function ve(e){let t=R8(e);return(r,a)=>tE(r,t(t=>e.map(a(t),e=>gP(e)?e:IZ(t))))}function vt(e){return t=>r=>e.chain(r,gV(r=>e.map(t(r),IZ),t=>e.of(IY(t))))}function vr(e){return t=>e.map(t,Ri)}function va(e){return t=>e.map(t,Rh)}/** @deprecated  *//* istanbul ignore next */function vn(e){let t=RZ(e),r=RH(e),a=RY(e),n=RQ(e),i=RX(e),o=R1(e),l=R5(e),p=R7(e),c=R8(e);return{map:(e,t)=>tE(e,r(t)),ap:(e,r)=>tE(e,t(r)),of:RP(e),chain:(e,t)=>tE(e,a(t)),alt:(e,t)=>tE(e,n(t)),bimap:(e,t,r)=>tE(e,i(t,r)),mapLeft:(e,t)=>tE(e,o(t)),fold:(e,t,r)=>tE(e,l(t,r)),getOrElse:(e,t)=>tE(e,p(t)),orElse:(e,t)=>tE(e,c(t)),swap:vr(e),rightM:RB(e),leftM:RD(e),left:Rz(e)}}/**
 * @since 2.11.0
 *//**
 * @category type lambdas
 * @since 2.11.0
 */let vi="Endomorphism",vo=()=>({concat:(e,t)=>tW(e,t)}),vl=()=>({concat:vo().concat,empty:tf});/**
 * @since 2.0.0
 *//**
 * @category model
 * @since 2.0.0
 *//**
 * Adapted from https://github.com/purescript/purescript-prelude/blob/master/src/Data/Field.purs
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * The *greatest common divisor* of two values
 *
 * @since 2.0.0
 */function vp(e,t){let r=t.zero,a=(n,i)=>e.equals(i,r)?n:a(i,t.mod(n,i));return a}/**
 * The *least common multiple* of two values
 *
 * @since 2.0.0
 */function vc(e,t){let r=t.zero,a=vp(e,t);return(n,i)=>e.equals(n,r)||e.equals(i,r)?r:t.div(t.mul(n,i),a(n,i))}// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`Field`](./number.ts.html#field) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */let vu={add:(e,t)=>e+t,zero:0,mul:(e,t)=>e*t,one:1,sub:(e,t)=>e-t,degree:e=>1,div:(e,t)=>e/t,mod:(e,t)=>e%t};/**
 * `Filterable` represents data structures which can be _partitioned_/_filtered_.
 *
 * Adapted from https://github.com/LiamGoodacre/purescript-filterable/blob/master/src/Data/Filterable.purs
 *
 * @since 2.0.0
 */function vf(e,t){return r=>a=>e.map(a,e=>t.filter(e,r))}function vd(e,t){return r=>a=>e.map(a,e=>t.filterMap(e,r))}function vh(e,t){let r=vf(e,t);return e=>{let t=r(sR(e)),a=r(e);return e=>lN(t(e),a(e))}}function vs(e,t){let r=vd(e,t);return e=>t=>lN(tE(t,r(t=>sU(e(t)))),tE(t,r(t=>sb(e(t)))))}/** @deprecated */function vm(e,t){let r=rp(e,t).map,a=Ip(e,t),n=Ic(e,t,t),i=vf(e,t),o=vd(e,t),l=vh(e,t),p=vs(e,t);return{map:r,compact:a,separate:n,filter:(e,t)=>tE(e,i(t)),filterMap:(e,t)=>tE(e,o(t)),partition:(e,t)=>tE(e,l(t)),partitionMap:(e,t)=>tE(e,p(t))}}/**
 * @since 2.0.0
 *//**
 * @category model
 * @since 2.0.0
 *//**
 * @since 2.0.0
 */function vI(e,t){return(r,a)=>n=>e.reduce(n,r,(e,r)=>t.reduce(r,e,a))}function vg(e,t){return r=>{let a=e.foldMap(r),n=t.foldMap(r);return e=>t=>a(t,t=>n(t,e))}}function vR(e,t){return(r,a)=>n=>e.reduceRight(n,r,(e,r)=>t.reduceRight(e,r,a))}function vv(e,t){return(r,a)=>n=>t.reduce(n,e.of(r),(t,r)=>e.chain(t,e=>a(e,r)))}function vW(e,t){return(r,a)=>t.reduce(a,{init:!0,acc:e.empty},({init:t,acc:a},n)=>t?{init:!1,acc:n}:{init:!1,acc:e.concat(e.concat(a,r),n)}).acc}function vM(e){return t=>e.reduce(t,[],(e,t)=>(e.push(t),e))}function vy(e,t){let r=e.of(void 0);return(a,n)=>t.reduce(a,r,(t,r)=>{let a;return a=n(r),e.ap(e.map(t,th),a)})}function vO(e,t){return(r,a,n)=>t.reduce(r,e.of(a),(t,r)=>e.chain(t,e=>n(e,r)))}/**
 * Use [`toReadonlyArray`](#toreadonlyarray) instead
 *
 * @category zone of death
 * @since 2.8.0
 * @deprecated
 */let vU=vM;/** @deprecated */function vb(e,t){let r=vI(e,t),a=vg(e,t),n=vR(e,t);return{reduce:(e,t,a)=>tE(e,r(t,a)),foldMap:e=>{let t=a(e);return(e,r)=>tE(e,t(r))},reduceRight:(e,t,r)=>tE(e,n(t,r))}}/**
 * A `Foldable` with an additional index.
 * A `FoldableWithIndex` instance must be compatible with its `Foldable` instance
 *
 * ```ts
 * reduce(fa, b, f) = reduceWithIndex(fa, b, (_, b, a) => f(b, a))
 * foldMap(M)(fa, f) = foldMapWithIndex(M)(fa, (_, a) => f(a))
 * reduceRight(fa, b, f) = reduceRightWithIndex(fa, b, (_, a, b) => f(a, b))
 * ```
 *
 * @since 2.0.0
 */function vx(e,t){return(r,a)=>n=>e.reduceWithIndex(n,r,(e,r,n)=>t.reduceWithIndex(n,r,(t,r,n)=>a([e,t],r,n)))}function vE(e,t){return r=>{let a=e.foldMapWithIndex(r),n=t.foldMapWithIndex(r);return e=>t=>a(t,(t,r)=>n(r,(r,a)=>e([t,r],a)))}}function vA(e,t){return(r,a)=>n=>e.reduceRightWithIndex(n,r,(e,r,n)=>t.reduceRightWithIndex(r,n,(t,r,n)=>a([e,t],r,n)))}/** @deprecated */function vS(e,t){let r=vb(e,t),a=vx(e,t),n=vE(e,t),i=vA(e,t);return{reduce:r.reduce,foldMap:r.foldMap,reduceRight:r.reduceRight,reduceWithIndex:(e,t,r)=>tE(e,a(t,r)),foldMapWithIndex:e=>{let t=n(e);return(e,r)=>tE(e,t(r))},reduceRightWithIndex:(e,t,r)=>tE(e,i(t,r))}}/**
 * Lift a computation from the `IO` monad
 *
 * @since 2.10.0
 */function vF(e){return t=>tW(t,e.fromIO)}function vT(e,t){return r=>{let a=tW(r,e.fromIO);return e=>t.chain(e,a)}}function vw(e,t){let r=vk(e,t);return e=>t=>r(t,e)}/** @internal */function vk(e,t){let r=rs(t);return(t,a)=>r(t,tW(a,e.fromIO))}/**
 * The `Reader` monad (also called the Environment monad). Represents a computation, which can read values from a shared environment,
 * pass values from function to function, and execute sub-computations in a modified environment.
 * Using `Reader` monad for such computations is often clearer and easier than using the `State` monad.
 *
 * In this example the `Reader` monad provides access to variable bindings. `Bindings` are a map of `number` variables.
 * The variable count contains number of variables in the bindings. You can see how to run a `Reader` monad and retrieve
 * data from it, how to access the `Reader` data with `ask` and `asks`.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as O from 'fp-ts/Option'
 * import * as R from 'fp-ts/Reader'
 * import * as RR from 'fp-ts/ReadonlyRecord'
 *
 * interface Bindings extends RR.ReadonlyRecord<string, number> {}
 *
 * // The Reader monad, which implements this complicated check.
 * const isCountCorrect: R.Reader<Bindings, boolean> = pipe(
 *   R.Do,
 *   R.bind('count', () => R.asks(lookupVar('count'))),
 *   R.bind('bindings', () => R.ask()),
 *   R.map(({ count, bindings }) => count === RR.size(bindings))
 * )
 *
 * // The selector function to use with 'asks'.
 * // Returns value of the variable with specified name.
 * const lookupVar = (name: string) => (bindings: Bindings): number =>
 *   pipe(
 *     bindings,
 *     RR.lookup(name),
 *     O.getOrElse(() => 0)
 *   )
 *
 * const sampleBindings: Bindings = { count: 3, a: 1, b: 2 }
 *
 * assert.deepStrictEqual(isCountCorrect(sampleBindings), true)
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Reads the current context
 *
 * @category constructors
 * @since 2.0.0
 */let vq=()=>tf,v_=tf,vK=e=>t=>r=>t(e(r)),vj=e=>t=>e(t)(t),vL=vj,vN=(e,t)=>tE(e,vB(t)),vC=(e,t)=>tE(e,vV(t)),vP=(e,t)=>tE(e,vY(t)),vz=(e,t,r)=>tE(e,vG(t,r)),vB=e=>t=>r=>e(t(r)),vD=e=>t=>r=>t(r)(e(r)),vV=vD,v$=th,vJ=/*#__PURE__*/tw(2,(e,t)=>r=>t(e(r))(r)),vH=/*#__PURE__*/vJ(tf),vZ=vH,vY=e=>t=>tW(e,t),vG=(e,t)=>r=>a=>t(r(e(a))),vQ=()=>tf,vX=e=>([t,r])=>[e(t),r],v0=e=>([t,r])=>[t,e(r)],v1=e=>g$(t=>tN(e(t)),IY),v2=e=>g$(IZ,t=>tC(e(t))),v3="Reader",v4={URI:v3,map:vN},v5=/*#__PURE__*/ri(v4),v7={URI:v3,of:v$},v6={URI:v3,map:vN,ap:vC},v8=/*#__PURE__*/t4(v6),v9=v8,We=/*#__PURE__*/t5(v6),Wt=We,Wr={URI:v3,map:vN,ap:vC,of:v$},Wa={URI:v3,map:vN,ap:vC,chain:vJ},Wn={URI:v3,map:vN,of:v$,ap:vC,chain:vJ},Wi=/*#__PURE__*/tw(2,rs(Wa)),Wo={URI:v3,map:vN,promap:vz},Wl={URI:v3,compose:vP,id:vQ},Wp={URI:v3,map:vN,promap:vz,first:vX,second:v0},Wc={URI:v3,map:vN,promap:vz,left:v1,right:v2},Wu=/*#__PURE__*/ro(v4),Wf=/*#__PURE__*/rl(v4),Wd=/*#__PURE__*/rm(Wa),Wh=Wd,Ws=/*#__PURE__*/v$(t$),Wm=/*#__PURE__*/t7(v6),WI=Wm,Wg=/*#__PURE__*/v$(tV),WR=e=>t=>r=>{let a=[e(0,tB(t))(r)];for(let n=1;n<t.length;n++)a.push(e(n,t[n])(r));return a},Wv=e=>{let t=WR(e);return e=>tz(e)?t(e):Wg},WW=Wv,WM=e=>Wv((t,r)=>e(r)),Wy=/*#__PURE__*/WM(tf),WO=vJ,WU=vJ,Wb=Wi,Wx=Wi,WE={URI:v3,map:vN,of:v$,ap:vC,chain:vJ,promap:vz,compose:vP,id:vQ,first:vX,second:v0,left:v1,right:v2},WA=/*#__PURE__*/t6(v6),WS=/*#__PURE__*/rf(Wr);/**
 * Lift a computation from the `Reader` monad.
 *
 * @since 2.11.0
 */function WF(e){return()=>e.fromReader(vq())}function WT(e){return e.fromReader}function Ww(e){return t=>tW(t,e.fromReader)}function Wk(e,t){let r=Ww(e);return e=>a=>t.chain(a,r(e))}function Wq(e,t){let r=W_(e,t);return e=>t=>r(t,e)}/** @internal */function W_(e,t){let r=rs(t);return(t,a)=>r(t,tW(a,e.fromReader))}/**
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Get the current state
 *
 * @category constructors
 * @since 2.0.0
 */let WK=()=>e=>[e,e],Wj=e=>()=>[void 0,e],WL=e=>t=>[void 0,e(t)],WN=e=>t=>[e(t),t],WC=(e,t)=>tE(e,Wz(t)),WP=(e,t)=>tE(e,WB(t)),Wz=e=>t=>r=>{let[a,n]=t(r);return[e(a),n]},WB=e=>t=>r=>{let[a,n]=t(r),[i,o]=e(n);return[a(i),o]},WD=e=>t=>[e,t],WV=/*#__PURE__*/tw(2,(e,t)=>r=>{let[a,n]=e(r);return t(a)(n)}),W$=/*#__PURE__*/WV(tf),WJ="State",WH={URI:WJ,map:WC},WZ=/*#__PURE__*/ri(WH),WY={URI:WJ,of:WD},WG={URI:WJ,map:WC,ap:WP},WQ=/*#__PURE__*/t4(WG),WX=/*#__PURE__*/t5(WG),W0={URI:WJ,map:WC,ap:WP,of:WD},W1={URI:WJ,map:WC,ap:WP,chain:WV},W2={URI:WJ,map:WC,ap:WP,of:WD,chain:WV},W3=/*#__PURE__*/tw(2,rs(W1)),W4={URI:WJ,fromState:tf},W5=e=>t=>t(e)[0],W7=e=>t=>t(e)[1],W6=/*#__PURE__*/ro(WH),W8=/*#__PURE__*/rl(WH),W9=/*#__PURE__*/rm(W1),Me=/*#__PURE__*/t7(WG),Mt=e=>t=>r=>{let[a,n]=e(0,tB(t))(r),i=[a],o=n;for(let r=1;r<t.length;r++){let[a,n]=e(r,t[r])(o);i.push(a),o=n}return[i,o]},Mr=e=>{let t=Mt(e);return e=>tz(e)?t(e):WD(tV)},Ma=Mr,Mn=e=>Mr((t,r)=>e(r)),Mi=/*#__PURE__*/Mn(tf),Mo=WV,Ml=W3,Mp=(e,t)=>e(t)[0],Mc=(e,t)=>e(t)[1],Mu=W2;/**
 * Lift a computation from the `State` monad.
 *
 * @since 2.11.0
 */function Mf(e){return()=>e.fromState(WK())}function Md(e){return t=>e.fromState(Wj(t))}function Mh(e){return tW(WL,e.fromState)}function Ms(e){return tW(WN,e.fromState)}function Mm(e){return t=>tW(t,e.fromState)}function MI(e,t){let r=Mm(e);return e=>a=>t.chain(a,r(e))}/**
 * Lift a computation from the `Task` monad
 *
 * @since 2.10.0
 */function Mg(e){return t=>tW(t,e.fromTask)}function MR(e,t){return r=>{let a=tW(r,e.fromTask);return e=>t.chain(e,a)}}function Mv(e,t){let r=MW(e,t);return e=>t=>r(t,e)}/** @internal */function MW(e,t){let r=rs(t);return(t,a)=>r(t,tW(a,e.fromTask))}/**
 * The `FromThese` type class represents those data types which support errors and warnings.
 *
 * @since 2.11.0
 */function MM(e){return t=>tW(t,e.fromThese)}/**
 * A `FunctorWithIndex` is a type constructor which supports a mapping operation `mapWithIndex`.
 *
 * `mapWithIndex` can be used to turn functions `i -> a -> b` into functions `f a -> f b` whose argument and return types use the type
 * constructor `f` to represent some computational context.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Identity: `F.mapWithIndex(fa, (_i, a) => a) <-> fa`
 * 2. Composition: `F.mapWithIndex(fa, (_i, a) => bc(ab(a))) <-> F.mapWithIndex(F.mapWithIndex(fa, ab), bc)`
 *
 * @since 2.0.0
 */function My(e,t){return r=>a=>e.mapWithIndex(a,(e,a)=>t.mapWithIndex(a,(t,a)=>r([e,t],a)))}/** @deprecated */function MO(e,t){let r=rp(e,t).map,a=My(e,t);return{map:r,mapWithIndex:(e,t)=>tE(e,a(t))}}/**
 * A `Group` is a `Monoid` with inverses. Instances must satisfy the following law in addition to the monoid laws:
 *
 * - Inverse: `concat(inverse(a), a) <-> empty = concat(a, inverse(a))`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * Heyting algebras are bounded (distributive) lattices that are also equipped with an additional binary operation
 * `implies` (also written as ``). Heyting algebras also define a complement operation `not` (sometimes written as
 * `a`)
 *
 * However, in Heyting algebras this operation is only a pseudo-complement, since Heyting algebras do not necessarily
 * provide the law of the excluded middle. This means that there is no guarantee that `a  a = 1`.
 *
 * Heyting algebras model intuitionistic logic. For a model of classical logic, see the boolean algebra type class
 * implemented as `BooleanAlgebra`.
 *
 * A `HeytingAlgebra` must satisfy the following laws in addition to `BoundedDistributiveLattice` laws:
 *
 * - Implication:
 *   - `a  a <-> 1`
 *   - `a  (a  b) <-> a  b`
 *   - `b  (a  b) <-> b`
 *   - `a  (b  c) <-> (a  b)  (a  c)`
 * - Complemented
 *   - `a <-> a  0`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * Type defunctionalization (as describe in [Lightweight higher-kinded polymorphism](https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf))
 *
 * @since 2.0.0
 *//**
 * `* -> *` constructors
 * @since 2.0.0
 *//**
 * `* -> * -> * -> * -> *` constructors
 * @since 2.0.0
 *//**
 * @since 2.0.0
 */let MU=(e,t)=>tE(e,Mw(t)),Mb=(e,t)=>tE(e,Mk(t)),Mx=(e,t,r)=>tE(e,MC(t,r)),ME=e=>(t,r)=>tE(t,MP(e)(r)),MA=(e,t,r)=>tE(e,Mz(t,r)),MS=(e,t)=>tE(e,M$(t)),MF=(e,t)=>tE(e,MK(t)),MT=e=>{let t=MB(e);return(e,r)=>tE(e,t(r))},Mw=e=>t=>e(t),Mk=e=>t=>t(e),Mq=tf,M_=/*#__PURE__*/tw(2,(e,t)=>t(e)),MK=e=>t=>e(t),Mj=tf,ML=/*#__PURE__*/MK(tf),MN=/*#__PURE__*/M_(tf),MC=(e,t)=>r=>t(e,r),MP=()=>e=>t=>e(t),Mz=(e,t)=>r=>t(r,e),MB=e=>t=>r=>e.map(t(r),tf),MD=e=>t=>e.map(t,tf),MV=()=>tf,M$=MV,MJ="Identity",MH=tf,MZ=tf,MY={URI:MJ,map:MU},MG=/*#__PURE__*/ri(MY),MQ={URI:MJ,of:Mq},MX={URI:MJ,map:MU,ap:Mb},M0=/*#__PURE__*/t4(MX),M1=/*#__PURE__*/t5(MX),M2={URI:MJ,map:MU,ap:Mb,of:Mq},M3={URI:MJ,map:MU,ap:Mb,chain:M_},M4={URI:MJ,map:MU,ap:Mb,of:Mq,chain:M_},M5=/*#__PURE__*/tw(2,rs(M3)),M7=M5,M6={URI:MJ,reduce:Mx,foldMap:ME,reduceRight:MA},M8={URI:MJ,map:MU,reduce:Mx,foldMap:ME,reduceRight:MA,traverse:MT,sequence:MD},M9={URI:MJ,map:MU,alt:MS},ye={URI:MJ,map:MU,extend:MF,extract:Mj},yt={URI:MJ,map:MU,ap:Mb,chain:M_,chainRec:so},yr=/*#__PURE__*/Mq(t$),ya=/*#__PURE__*/ro(MY),yn=/*#__PURE__*/rl(MY),yi=/*#__PURE__*/rm(M3),yo=/*#__PURE__*/t7(MX),yl=M_,yp={URI:MJ,map:MU,ap:Mb,of:Mq,chain:M_,reduce:Mx,foldMap:ME,reduceRight:MA,traverse:MT,sequence:MD,alt:MS,extract:Mj,extend:MF,chainRec:so},yc=(e,t)=>()=>t(e()),yu=(e,t)=>()=>e()(t()),yf=(e,t)=>()=>{let r=t(e)();for(;"Left"===r._tag;)r=t(r.left)();return r.right},yd=e=>t=>yc(t,e),yh=e=>t=>yu(t,e),ys=th,ym=/*#__PURE__*/tw(2,(e,t)=>()=>t(e())()),yI=/*#__PURE__*/ym(tf),yg="IO",yR={URI:yg,map:yc},yv=tw(2,rc(yR)),yW=ru(yR),yM=/*#__PURE__*/ri(yR),yy={URI:yg,of:ys},yO={URI:yg,map:yc,ap:yu},yU=/*#__PURE__*/t4(yO),yb=/*#__PURE__*/t5(yO),yx={URI:yg,map:yc,ap:yu,of:ys},yE={URI:yg,map:yc,ap:yu,chain:ym},yA={URI:yg,map:yc,ap:yu,of:ys,chain:ym},yS=/*#__PURE__*/tw(2,rs(yE)),yF=tf,yT={URI:yg,map:yc,ap:yu,of:ys,chain:ym,fromIO:yF},yw={URI:yg,map:yc,ap:yu,chain:ym,chainRec:yf},yk={URI:yg,fromIO:tf},yq=/*#__PURE__*/ys(t$),y_=/*#__PURE__*/ro(yR),yK=/*#__PURE__*/rl(yR),yj=/*#__PURE__*/rm(yE),yL=/*#__PURE__*/t7(yO),yN=/*#__PURE__*/ys(tV),yC=e=>t=>()=>{let r=[e(0,tB(t))()];for(let a=1;a<t.length;a++)r.push(e(a,t[a])());return r},yP=e=>{let t=yC(e);return e=>tz(e)?t(e):yN},yz=yP,yB=e=>yP((t,r)=>e(r)),yD=/*#__PURE__*/yB(tf),yV=ym,y$=yS,yJ={URI:yg,map:yc,of:ys,ap:yu,chain:ym,fromIO:yF,chainRec:yf},yH=/*#__PURE__*/t6(yO),yZ=/*#__PURE__*/rf(yx),yY=/*#__PURE__*/Rz(yy),yG=/*#__PURE__*/RP(yy),yQ=/*#__PURE__*/RB(yR),yX=/*#__PURE__*/RD(yR),y0=ys,y1=yQ,y2=/*#__PURE__*/R4(yR),y3=y2,y4=/*#__PURE__*/R5(yA),y5=y4,y7=y4,y6=y7,y8=/*#__PURE__*/R7(yA),y9=y8,Oe=(e,t)=>()=>Rc(e,t),Ot=(e,t)=>(...r)=>Oe(()=>e(...r),t),Or=/*#__PURE__*/va(yR),Oa=/*#__PURE__*/R8(yA),On=Oa,Oi=/*#__PURE__*/tw(2,ve(yA)),Oo=e=>Oi(O0(e)),Ol=/*#__PURE__*/vt(yA),Op=/*#__PURE__*/vr(yR),Oc=(e,t)=>tE(e,Od(t)),Ou=(e,t)=>tE(e,Og(t)),Of=(e,t)=>tE(e,OO(t)),Od=/*#__PURE__*/RH(yR),Oh=/*#__PURE__*/tw(3,R0(yR)),Os=Oh,Om=/*#__PURE__*/tw(2,R2(yR)),OI=Om,Og=/*#__PURE__*/RZ(yO),OR=Og,Ov=yG,OW=/*#__PURE__*/tw(2,RG(yA)),OM=/*#__PURE__*/OW(tf),Oy=OM,OO=/*#__PURE__*/RQ(yA),OU=OO,Ob=yY,Ox="IOEither";/**
 * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getApplicativeValidation`](./Either.ts.html#getapplicativevalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function OE(e){let t=t3(yO,go(e));return{URI:Ox,_E:void 0,map:Oc,ap:(e,r)=>tE(e,t(r)),of:Ov}}/**
 * The default [`Alt`](#alt) instance returns the last error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getAltValidation`](./Either.ts.html#getaltvalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function OA(e){let t=R3(yA,e);return{URI:Ox,_E:void 0,map:Oc,alt:(e,r)=>tE(e,t(r))}}/**
 * @category filtering
 * @since 2.10.0
 */let OS=e=>{let t=ga(e);return{URI:Ox,_E:void 0,compact:Ip(yR,t),separate:Ic(yR,t,gc)}};/**
 * @category filtering
 * @since 2.1.0
 */function OF(e){let t=gn(e),r=OS(e),a=vf(yR,t),n=vd(yR,t),i=vh(yR,t),o=vs(yR,t);return{URI:Ox,_E:void 0,map:Oc,compact:r.compact,separate:r.separate,filter:(e,t)=>tE(e,a(t)),filterMap:(e,t)=>tE(e,n(t)),partition:(e,t)=>tE(e,i(t)),partitionMap:(e,t)=>tE(e,o(t))}}/**
 * @category instances
 * @since 2.7.0
 */let OT={URI:Ox,map:Oc},Ow=tw(2,rc(OT)),Ok=ru(OT),Oq=/*#__PURE__*/ri(OT),O_={URI:Ox,of:Ov},OK={URI:Ox,bimap:Oh,mapLeft:Om},Oj={URI:Ox,map:Oc,ap:Ou},OL=/*#__PURE__*/t4(Oj),ON=OL,OC=/*#__PURE__*/t5(Oj),OP=OC,Oz={URI:Ox,map:Oc,ap:Ou,of:Ov},OB={URI:Ox,map:Oc,ap:(e,t)=>OW(e,e=>tE(t,Od(e))),of:Ov},OD={URI:Ox,map:Oc,ap:Ou,chain:OW},OV={URI:Ox,map:Oc,ap:Ou,of:Ov,chain:OW},O$={URI:Ox,fromEither:y0},OJ={URI:Ox,fromIO:y1},OH=/*#__PURE__*/tw(2,rs(OD)),OZ=/*#__PURE__*/tw(2,rU(O$,OD)),OY=/*#__PURE__*/tw(2,vk(OJ,OD)),OG={URI:Ox,map:Oc,alt:Of},OQ={URI:Ox,map:Oc,ap:Ou,of:Ov,chain:OW,fromIO:y1},OX={URI:Ox,map:Oc,ap:Ou,of:Ov,chain:OW,throwError:Ob},O0=/*#__PURE__*/vF(OJ),O1=OY,O2=/*#__PURE__*/rI(O$),O3=/*#__PURE__*/rR(O$),O4=/*#__PURE__*/rv(O$,OD),O5=O4,O7={fromEither:O$.fromEither},O6=/*#__PURE__*/tZ(O7),O8=/*#__PURE__*/tY(O7),O9={flatMap:OW},Ue=/*#__PURE__*/tG(O7,O9),Ut=/*#__PURE__*/tQ(O7,O9),Ur=/*#__PURE__*/tX(O7,O9),Ua=/*#__PURE__*/t0({fromIO:y1},O9),Un=Ua,Ui=Ur,Uo=Ur,Ul=OZ,Up=OZ,Uc=/*#__PURE__*/rg(O$),Uu=/*#__PURE__*/rO(O$,OD),Uf=Uu,Ud=/*#__PURE__*/rW(O$),Uh=(e,t,r)=>Us(e,t,r),Us=(e,t,r)=>OW(e,e=>ym(t(e),t=>OW(r(e,t),()=>ys(t)))),Um=/*#__PURE__*/Ov(t$),UI=/*#__PURE__*/ro(OT),Ug=/*#__PURE__*/rl(OT),UR=/*#__PURE__*/rm(OD),Uv=UR,UW=/*#__PURE__*/t7(Oj),UM=UW,Uy=/*#__PURE__*/Ov(tV),UO=e=>tW(yC(e),yd(RU(tS))),UU=e=>{let t=UO(e);return e=>tz(e)?t(e):Uy},Ub=e=>t=>()=>{let r=e(0,tB(t))();if(tj(r))return r;let a=[r.right];for(let r=1;r<t.length;r++){let n=e(r,t[r])();if(tj(n))return n;a.push(n.right)}return tC(a)},Ux=e=>{let t=Ub(e);return e=>tz(e)?t(e):Uy},UE=UU,UA=e=>UU((t,r)=>e(r)),US=/*#__PURE__*/UA(tf),UF=Ux,UT=e=>Ux((t,r)=>e(r)),Uw=/*#__PURE__*/UT(tf),Uk=Oz,Uq=OW,U_=OW,UK=OH,Uj=OH,UL=Oi,UN=Oi,UC={URI:Ox,bimap:Oh,mapLeft:Om,map:Oc,of:Ov,ap:Ou,chain:OW,alt:Of,fromIO:y1,throwError:Ob},UP=/*#__PURE__*/t6(Oj),Uz=/*#__PURE__*/rf(Oz),UB=e=>t6(yO)(gr(e));/**
 * Use [`getApplicativeIOValidation`](#getapplicativeiovalidation) and [`getAltIOValidation`](#getaltiovalidation).
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function UD(e){let t=OE(e),r=OA(e);return{URI:Ox,_E:void 0,map:Oc,ap:t.ap,of:Ov,chain:OW,bimap:Oh,mapLeft:Om,alt:r.alt,fromIO:y1,throwError:Ob}}/**
 * @since 2.0.0
 */function UV(e){return tW(sy,e.of)}function U$(e){return th(e.of(sM))}function UJ(e){return t=>e.map(t,sy)}function UH(e){return tW(mD,e.of)}function UZ(e){let t=UH(e);return e=>tW(e,t)}function UY(e){let t=U7(e),r=UZ(e);return e=>t(r(e))}function UG(e){return t=>tW(t,e.of)}function UQ(e){let t=U7(e),r=UG(e);return e=>t(r(e))}function UX(e){return t=>r=>e.of(sO(t)(r))}function U0(e){return tW(mU,e.of)}function U1(e){return(t,r)=>a=>e.map(a,mF(t,r))}function U2(e){return(t,r)=>a=>e.chain(a,mF(t,r))}function U3(e){return t=>r=>e.chain(r,mF(t,e.of))}function U4(e){return rn(e,sD)}function U5(e){return t3(e,sY)}function U7(e){let t=U6(e);return e=>r=>t(r,e)}/** @internal */function U6(e){let t=U$(e);return(r,a)=>e.chain(r,mF(()=>t(),a))}function U8(e){let t=UV(e);return r=>a=>e.chain(a,mF(r,t))}/** @deprecated */function U9(e){let t=U5(e),r=U4(e),a=U7(e),n=U8(e),i=U2(e),o=U3(e),l=U$(e);return{map:(e,t)=>tE(e,r(t)),ap:(e,r)=>tE(e,t(r)),of:UV(e),chain:(e,t)=>tE(e,a(t)),alt:(e,t)=>tE(e,n(t)),fold:(e,t,r)=>tE(e,i(t,r)),getOrElse:(e,t)=>tE(e,o(t)),fromM:UJ(e),none:()=>l()}}/**
 * `IOOption<A>` represents a synchronous computation that either yields a value of type `A` or nothing.
 *
 * If you want to represent a synchronous computation that never fails, please see `IO`.
 * If you want to represent a synchronous computation that may fail, please see `IOEither`.
 *
 * @since 2.12.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.12.0
 */let be=/*#__PURE__*/UV(yy),bt=/*#__PURE__*/UX(yy),br=ys,ba=/*#__PURE__*/U0(yy),bn=/*#__PURE__*/UJ(yR),bi=/*#__PURE__*/yd(mU),bo=/*#__PURE__*/U1(yR),bl=bo,bp=/*#__PURE__*/U2(yE),bc=bp,bu=bp,bf=/*#__PURE__*/U3(yA),bd=bf,bh=yd(mY),bs=yd(mZ),bm=/*#__PURE__*/UH(yy),bI=/*#__PURE__*/UZ(yy),bg=/*#__PURE__*/UY(yA),bR=/*#__PURE__*/UG(yy),bv=/*#__PURE__*/U4(yR),bW=/*#__PURE__*/U5(yO),bM=be,by=/*#__PURE__*/tw(2,U6(yA)),bO=/*#__PURE__*/by(tf),bU=/*#__PURE__*/U8(yA),bb=bU,bx=/*#__PURE__*/U$(yy),bE=/*#__PURE__*/bx(),bA=/*#__PURE__*/Ip(yR,mp),bS=/*#__PURE__*/Ic(yR,mp,sD),bF=/*#__PURE__*/vf(yR,mh),bT=/*#__PURE__*/vd(yR,mh),bw=/*#__PURE__*/vh(yR,mh),bk=/*#__PURE__*/vs(yR,mh),bq=(e,t)=>tE(e,bv(t)),b_=(e,t)=>tE(e,bW(t)),bK=(e,t)=>tE(e,bU(t)),bj="IOOption",bL={URI:bj,map:bq},bN=tw(2,rc(bL)),bC=ru(bL),bP=/*#__PURE__*/ri(bL),bz={URI:bj,of:bM},bB={URI:bj,map:bq,ap:b_},bD=/*#__PURE__*/t4(bB),bV=/*#__PURE__*/t5(bB),b$={URI:bj,map:bq,ap:b_,of:bM},bJ={URI:bj,map:bq,ap:b_,chain:by},bH={URI:bj,fromEither:ba},bZ={URI:bj,fromIO:bn},bY=/*#__PURE__*/tw(2,rs(bJ)),bG=/*#__PURE__*/tw(2,rU(bH,bJ)),bQ=/*#__PURE__*/tw(2,vk(bZ,bJ)),bX={URI:bj,map:bq,alt:bK},b0={URI:bj,zero:bx},b1=/*#__PURE__*/lQ(b0,bz),b2={URI:bj,map:bq,ap:b_,of:bM,alt:bK,zero:bx},b3={URI:bj,map:bq,ap:b_,of:bM,chain:by},b4={URI:bj,map:bq,ap:b_,of:bM,chain:by,fromIO:bn},b5={URI:bj,compact:bA,separate:bS},b7={URI:bj,map:bq,compact:bA,separate:bS,filter:(e,t)=>tE(e,bF(t)),filterMap:(e,t)=>tE(e,bT(t)),partition:(e,t)=>tE(e,bw(t)),partitionMap:(e,t)=>tE(e,bk(t))},b6={flatMap:by},b8=t0({fromIO:bZ.fromIO},b6),b9=/*#__PURE__*/tw(2,(e,t)=>by(e,bR(t))),xe=/*#__PURE__*/tX({fromEither:ba},b6),xt=/*#__PURE__*/tw(2,(e,t)=>by(e,bI(t))),xr=/*#__PURE__*/vF(bZ),xa=b8,xn=bQ,xi=/*#__PURE__*/rW(bH),xo=xe,xl=bG,xp=b9,xc=/*#__PURE__*/bM(t$),xu=/*#__PURE__*/ro(bL),xf=/*#__PURE__*/rl(bL),xd=/*#__PURE__*/rm(bJ),xh=/*#__PURE__*/t7(bB),xs=/*#__PURE__*/bM(tV),xm=e=>tW(yC(e),yd(m4(tS))),xI=e=>{let t=xm(e);return e=>tz(e)?t(e):xs},xg=by,xR=bY;/**
 * Mutable references in the `IO` monad
 *
 * @since 2.0.0
 */function xv(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}/**
 * @example
 * import { flatMap } from 'fp-ts/IO'
 * import { newIORef } from 'fp-ts/IORef'
 *
 * assert.strictEqual(flatMap(newIORef(1), ref => flatMap(ref.write(2), () => ref.read))(), 2)
 *
 * @category model
 * @since 2.0.0
 */class xW{/**
   * @since 2.0.0
   */write(e){return()=>{this.value=e}}/**
   * @since 2.0.0
   */modify(e){return()=>{this.value=e(this.value)}}constructor(e){xv(this,"value",void 0),/**
   * @since 2.0.0
   */xv(this,"read",void 0),this.value=e,this.read=()=>this.value,this.write=this.write.bind(this),this.modify=this.modify.bind(this)}}/**
 * @category constructors
 * @since 2.0.0
 */function xM(e){return()=>new xW(e)}/**
 * A join-semilattice (or upper semilattice) is a semilattice whose operation is called `join`, and which can be thought
 * of as a least upper bound.
 *
 * A `JoinSemilattice` must satisfy the following laws:
 *
 * - Associativity: `a  (b  c) <-> (a  b)  c`
 * - Commutativity: `a  b <-> b  a`
 * - Idempotency:   `a  a <-> a`
 *
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @category model
 * @since 2.0.0
 *//**
 * @since 2.10.0
 *//**
 * Converts a JavaScript Object Notation (JSON) string into a `Json` type.
 *
 * @example
 * import * as J from 'fp-ts/Json'
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('{"a":1}', J.parse), E.right({ a: 1 }))
 * assert.deepStrictEqual(pipe('{"a":}', J.parse), E.left(new SyntaxError(`Unexpected token '}', "{"a":}" is not valid JSON`)))
 *
 * @since 2.10.0
 */let xy=e=>Rc(()=>JSON.parse(e),tf),xO=e=>Rc(()=>{let t=JSON.stringify(e);if("string"!=typeof t)throw Error("Converting unsupported structure to JSON");return t},tf),xU=e=>new Map(e);/**
 * @category conversions
 * @since 2.5.0
 */function xb(e){return new Map(e)}/**
 * @category instances
 * @since 2.5.0
 */function xx(e,t){return{show:r=>{let a=[];return r.forEach((r,n)=>{a.push(`[${e.show(n)}, ${t.show(r)}]`)}),`new Map([${a.sort().join(", ")}])`}}}/**
 * Calculate the number of key/value pairs in a map
 *
 * @since 2.5.0
 */let xE=e=>e.size,xA=e=>0===e.size;function xS(e){let t=xz(e);return(r,a)=>{if(void 0===a){let t=xS(e);return e=>t(r,e)}return tq(t(r,a))}}function xF(e){return(t,r)=>{let a;if(void 0===r){let r=xF(e);return e=>r(t,e)}let n=r.values();for(;!(a=n.next()).done;){let r=a.value;if(e.equals(t,r))return!0}return!1}}/**
 * Get a sorted `ReadonlyArray` of the keys contained in a `ReadonlyMap`.
 *
 * @since 2.5.0
 */let xT=e=>t=>Array.from(t.keys()).sort(e.compare),xw=e=>t=>Array.from(t.values()).sort(e.compare);/**
 * @since 2.5.0
 */function xk(e){let t=xT(e);return e=>r=>{let a=[];for(let n of t(r))a.push(e(n,r.get(n)));return a}}/**
 * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyMap`.
 *
 * @category conversions
 * @since 2.5.0
 */let xq=e=>xk(e)((e,t)=>[e,t]);function x_(e,t){let r=xq(e);return e=>{let a=r(e),n=a.length;return t.unfold(0,e=>e<n?tK([a[e],e+1]):t_)}}/**
 * Insert or replace a key/value pair in a `ReadonlyMap`.
 *
 * @since 2.10.0
 */let xK=e=>{let t=xP(e);return(e,r)=>{let a=t(e);return t=>{let n=a(t);if(tk(n)){let a=new Map(t);return a.set(e,r),a}if(n.value[1]!==r){let e=new Map(t);return e.set(n.value[0],r),e}return t}}},xj=e=>{let t=xP(e);return e=>r=>{let a=t(e,r);if(tq(a)){let e=new Map(r);return e.delete(a.value[0]),e}return r}},xL=e=>{let t=xN(e);return(e,r)=>t(e,()=>r)},xN=e=>{let t=xP(e);return(e,r)=>a=>{let n=t(e,a);if(tk(n))return t_;let[i,o]=n.value,l=r(o);if(l===o)return tK(a);let p=new Map(a);return p.set(i,l),tK(p)}};/**
 * Delete a key and value from a map, returning the value as well as the subsequent map
 *
 * @since 2.5.0
 */function xC(e){let t=xz(e),r=xj(e);return e=>{let a=r(e);return r=>tE(t(e,r),sB(e=>[e,a(r)]))}}function xP(e){return(t,r)=>{let a;if(void 0===r){let r=xP(e);return e=>r(t,e)}let n=r.entries();for(;!(a=n.next()).done;){let[r,n]=a.value;if(e.equals(r,t))return tK([r,n])}return t_}}function xz(e){let t=xP(e);return(r,a)=>{if(void 0===a){let t=xz(e);return e=>t(r,e)}return tE(t(r,a),sB(([e,t])=>t))}}function xB(e,t){let r=xP(e);return(a,n)=>{let i;if(void 0===n){let r=xB(e,t);return e=>r(e,a)}let o=a.entries();for(;!(i=o.next()).done;){let[a,o]=i.value,l=r(a,n);if(tk(l)||!e.equals(a,l.value[0])||!t.equals(o,l.value[1]))return!1}return!0}}/**
 * @since 2.5.0
 */let xD=new Map;/**
 * @category instances
 * @since 2.5.0
 */function xV(e,t){let r=xB(e,t);return rb((e,t)=>r(e,t)&&r(t,e))}/**
 * Gets `Monoid` instance for Maps given `Semigroup` instance for their values
 *
 * @category instances
 * @since 2.5.0
 */function x$(e,t){let r=xP(e);return{concat:(e,a)=>{let n;if(xA(e))return a;if(xA(a))return e;let i=new Map(e),o=a.entries();for(;!(n=o.next()).done;){let[a,o]=n.value,l=r(a,e);tq(l)?i.set(l.value[0],t.concat(l.value[1],o)):i.set(a,o)}return i},empty:xD}}/**
 * Create a map with one key/value pair
 *
 * @category constructors
 * @since 2.5.0
 */let xJ=(e,t)=>new Map([[e,t]]);function xH(e,t,r){return a=>{let n=xP(e);return r.reduce(a,new Map,(e,[r,a])=>{let i=n(r,e);return tq(i)?e.set(i.value[0],t.concat(i.value[1],a)):e.set(r,a),e})}}let xZ=(e,t)=>{let r,a=new Map,n=e.entries();for(;!(r=n.next()).done;){let[e,n]=r.value;a.set(e,t(e,n))}return a},xY=e=>t=>{let r,a=new Map,n=new Map,i=t.entries();for(;!(r=i.next()).done;){let[t,i]=r.value,o=e(t,i);tj(o)?a.set(t,o.left):n.set(t,o.right)}return lN(a,n)};function xG(e){return t=>{let r,a=new Map,n=new Map,i=t.entries();for(;!(r=i.next()).done;){let[t,i]=r.value;e(t,i)?n.set(t,i):a.set(t,i)}return lN(a,n)}}/**
 * @since 2.10.0
 */let xQ=e=>t=>{let r,a=new Map,n=t.entries();for(;!(r=n.next()).done;){let[t,n]=r.value,i=e(t,n);tq(i)&&a.set(t,i.value)}return a};function xX(e){return t=>{let r,a=new Map,n=t.entries();for(;!(r=n.next()).done;){let[t,n]=r.value;e(t,n)&&a.set(t,n)}return a}}let x0=(e,t)=>xZ(e,(e,r)=>t(r)),x1=(e,t)=>x5(e,(e,r)=>t(r)),x2=(e,t)=>x7(e,(e,r)=>t(r)),x3=(e,t)=>x6(e,(e,r)=>t(r)),x4=(e,t)=>x8(e,(e,r)=>t(r)),x5=(e,t)=>tE(e,xX(t)),x7=(e,t)=>tE(e,xQ(t)),x6=(e,t)=>tE(e,xG(t)),x8=(e,t)=>tE(e,xY(t)),x9=e=>{let t,r=new Map,a=e.entries();for(;!(t=a.next()).done;){let[e,a]=t.value;tq(a)&&r.set(e,a.value)}return r},Ee=e=>t=>x1(t,e),Et=e=>t=>x2(t,e),Er=e=>t=>x0(t,e),Ea=e=>t=>xZ(t,e),En=e=>t=>x3(t,e),Ei=e=>t=>x4(t,e),Eo=e=>{let t,r=new Map,a=new Map,n=e.entries();for(;!(t=n.next()).done;){let[e,n]=t.value;tj(n)?r.set(e,n.left):a.set(e,n.right)}return lN(r,a)},El="ReadonlyMap",Ep=(e,t)=>{let r=ES(e,t);return{concat:(e,t)=>r(t)(e)}},Ec=(e,t)=>({concat:Ep(e,t).concat,empty:xD}),Eu=(e,t)=>{let r=EF(e,t);return{concat:(e,t)=>r(t)(e)}},Ef=e=>()=>{let t=ET(e);return{concat:(e,r)=>t(r)(e)}};/**
 * @category filtering
 * @since 2.5.0
 */function Ed(){return{URI:El,_E:void 0,map:x0,mapWithIndex:xZ,compact:x9,separate:Eo,filter:x1,filterMap:x2,partition:x3,partitionMap:x4,partitionMapWithIndex:x8,partitionWithIndex:x6,filterMapWithIndex:x7,filterWithIndex:x5}}/**
 * @category instances
 * @since 2.7.0
 */let Eh={URI:El,map:x0},Es=/*#__PURE__*/ri(Eh),Em=()=>({URI:El,_E:void 0,map:x0,mapWithIndex:xZ}),EI={URI:El,compact:x9,separate:Eo},Eg={URI:El,map:x0,compact:x9,separate:Eo,filter:x1,filterMap:x2,partition:x3,partitionMap:x4},ER=e=>{let t=Ey(e);return(e,r)=>t(e,(e,t,a)=>r(t,a))},Ev=e=>{let t=EO(e);return e=>{let r=t(e);return e=>r((t,r)=>e(r))}},EW=e=>{let t=EU(e);return(e,r)=>t(e,(e,t,a)=>r(t,a))},EM=e=>{let t=ER(e),r=Ev(e),a=EW(e);return{URI:El,_E:void 0,reduce:(e,r,a)=>tE(e,t(r,a)),foldMap:e=>{let t=r(e);return(e,r)=>tE(e,t(r))},reduceRight:(e,t,r)=>tE(e,a(t,r))}},Ey=e=>{let t=xT(e);return(e,r)=>a=>{let n=e;for(let e of t(a))n=r(e,n,a.get(e));return n}},EO=e=>{let t=xT(e);return e=>r=>a=>{let n=e.empty;for(let i of t(a))n=e.concat(n,r(i,a.get(i)));return n}},EU=e=>{let t=xT(e);return(e,r)=>a=>{let n=e,i=t(a),o=i.length;for(let e=o-1;e>=0;e--){let t=i[e];n=r(t,a.get(t),n)}return n}},Eb=e=>{let t=EM(e),r=Ey(e),a=EO(e),n=EU(e);return{URI:El,_E:void 0,reduce:t.reduce,foldMap:t.foldMap,reduceRight:t.reduceRight,reduceWithIndex:(e,t,a)=>tE(e,r(t,a)),foldMapWithIndex:e=>{let t=a(e);return(e,r)=>tE(e,t(r))},reduceRightWithIndex:(e,t,r)=>tE(e,n(t,r))}},Ex=e=>{let t=EE(e),r=EM(e);return{URI:El,_E:void 0,map:x0,reduce:r.reduce,foldMap:r.foldMap,reduceRight:r.reduceRight,traverse:t.traverse,sequence:t.sequence}},EE=e=>{let t=Eb(e),r=xT(e),a=e=>(t,a)=>{let n=e.of(new Map),i=r(t),o=i.length;for(let r=0;r<o;r++){let o=i[r],l=t.get(o);n=e.ap(e.map(n,e=>t=>e.set(o,t)),a(o,l))}return n};return{URI:El,_E:void 0,map:x0,mapWithIndex:xZ,reduce:t.reduce,foldMap:t.foldMap,reduceRight:t.reduceRight,reduceWithIndex:t.reduceWithIndex,foldMapWithIndex:t.foldMapWithIndex,reduceRightWithIndex:t.reduceRightWithIndex,traverse:e=>{let t=a(e);return(e,r)=>t(e,(e,t)=>r(t))},sequence:e=>{let t=a(e);return e=>t(e,tS)},traverseWithIndex:a}};/**
 * @category filtering
 * @since 2.5.0
 */function EA(e){let t=EE(e);return{URI:El,_E:void 0,map:x0,compact:x9,separate:Eo,filter:x1,filterMap:x2,partition:x3,partitionMap:x4,reduce:t.reduce,foldMap:t.foldMap,reduceRight:t.reduceRight,traverse:t.traverse,sequence:t.sequence,mapWithIndex:xZ,reduceWithIndex:t.reduceWithIndex,foldMapWithIndex:t.foldMapWithIndex,reduceRightWithIndex:t.reduceRightWithIndex,traverseWithIndex:t.traverseWithIndex,wilt:lZ(t,EI),wither:lY(t,EI)}}// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */let ES=(e,t)=>{let r=xz(e);return e=>a=>{let n;if(xA(a))return e;if(xA(e))return a;let i=new Map,o=a.entries();for(;!(n=o.next()).done;){let[a,o]=n.value,l=r(a)(e);tq(l)?i.set(a,t.concat(o,l.value)):i.set(a,o)}let l=e.entries();for(;!(n=l.next()).done;){let[e,t]=n.value;tk(r(e)(i))&&i.set(e,t)}return i}},EF=(e,t)=>{let r=xz(e);return e=>a=>{let n;if(xA(a)||xA(e))return xD;let i=new Map,o=a.entries();for(;!(n=o.next()).done;){let[a,o]=n.value,l=r(a)(e);tq(l)&&i.set(a,t.concat(o,l.value))}return i}},ET=e=>{let t=xS(e);return e=>r=>{let a;if(xA(r))return e;if(xA(e))return r;let n=new Map,i=r.entries();for(;!(a=i.next()).done;){let[r,i]=a.value;t(r)(e)||n.set(r,i)}let o=e.entries();for(;!(a=o.next()).done;){let[e,i]=a.value;t(e)(r)||n.set(e,i)}return n}},Ew=xK,Ek={URI:El,map:x0,compact:x9,separate:Eo,filter:x1,filterMap:x2,partition:x3,partitionMap:x4};function Eq(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},a=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),a.forEach(function(t){var a;a=r[t],t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a})}return e}function E_(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):(function(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r.push.apply(r,a)}return r})(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}),e}/**
 * @category instances
 * @since 2.0.0
 */let EK=xx,Ej=xE,EL=xA,EN=xS,EC=xF,EP=e=>t=>Array.from(t.keys()).sort(e.compare),Ez=e=>t=>Array.from(t.values()).sort(e.compare);/**
 * @since 2.0.0
 */function EB(e){let t=EP(e);return e=>r=>{let a=[];for(let n of t(r))a.push(e(n,r.get(n)));return a}}/**
 * Get a sorted `Array` of the key/value pairs contained in a `Map`.
 *
 * @since 2.0.0
 */function ED(e){return EB(e)((e,t)=>[e,t])}function EV(e,t){let r=ED(e);return e=>{let a=r(e),n=a.length;return t.unfold(0,e=>e<n?tK([a[e],e+1]):t_)}}/**
 * Insert or replace a key/value pair in a `Map`.
 *
 * @since 2.0.0
 */let E$=e=>{let t=EG(e);return(e,r)=>{let a=t(e);return t=>{let n=a(t);if(tk(n)){let a=new Map(t);return a.set(e,r),a}if(n.value[1]!==r){let e=new Map(t);return e.set(n.value[0],r),e}return t}}},EJ=e=>{let t=EG(e);return e=>r=>{let a=t(e,r);if(tq(a)){let e=new Map(r);return e.delete(a.value[0]),e}return r}},EH=e=>{let t=EZ(e);return(e,r)=>t(e,()=>r)},EZ=e=>{let t=EG(e);return(e,r)=>a=>{let n=t(e,a);if(tk(n))return t_;let i=new Map(a);return i.set(n.value[0],r(n.value[1])),tK(i)}};/**
 * Delete a key and value from a map, returning the value as well as the subsequent map
 *
 * @since 2.0.0
 */function EY(e){let t=EQ(e),r=EJ(e);return e=>{let a=r(e);return r=>tE(t(e,r),sB(e=>[e,a(r)]))}}function EG(e){return(t,r)=>{let a;if(void 0===r){let r=EG(e);return e=>r(t,e)}let n=r.entries();for(;!(a=n.next()).done;){let[r,n]=a.value;if(e.equals(r,t))return tK([r,n])}return t_}}// TODO: remove non-curried overloading in v3
/**
 * Lookup the value for a key in a `Map`.
 *
 * @since 2.0.0
 */let EQ=xz,EX=xB,E0=xV;/**
 * Gets `Monoid` instance for Maps given `Semigroup` instance for their values
 *
 * @category instances
 * @since 2.0.0
 */function E1(e,t){let r=EG(e);return{concat:(e,a)=>{let n;if(EL(e))return a;if(EL(a))return e;let i=new Map(e),o=a.entries();for(;!(n=o.next()).done;){let[a,o]=n.value,l=r(a,e);tq(l)?i.set(l.value[0],t.concat(l.value[1],o)):i.set(a,o)}return i},empty:new Map}}/**
 * Create a map with one key/value pair
 *
 * @since 2.0.0
 */let E2=(e,t)=>new Map([[e,t]]);function E3(e,t,r){return a=>{let n=EG(e);return r.reduce(a,new Map,(e,[r,a])=>{let i=n(r,e);return tq(i)?e.set(i.value[0],t.concat(i.value[1],a)):e.set(r,a),e})}}let E4=(e,t)=>{let r,a=new Map,n=e.entries();for(;!(r=n.next()).done;){let[e,n]=r.value;a.set(e,t(e,n))}return a},E5=e=>t=>{let r,a=new Map,n=new Map,i=t.entries();for(;!(r=i.next()).done;){let[t,i]=r.value,o=e(t,i);tj(o)?a.set(t,o.left):n.set(t,o.right)}return lN(a,n)};function E7(e){return t=>{let r,a=new Map,n=new Map,i=t.entries();for(;!(r=i.next()).done;){let[t,i]=r.value;e(t,i)?n.set(t,i):a.set(t,i)}return lN(a,n)}}/**
 * @since 2.10.0
 */let E6=e=>t=>{let r,a=new Map,n=t.entries();for(;!(r=n.next()).done;){let[t,n]=r.value,i=e(t,n);tq(i)&&a.set(t,i.value)}return a};function E8(e){return t=>{let r,a=new Map,n=t.entries();for(;!(r=n.next()).done;){let[t,n]=r.value;e(t,n)&&a.set(t,n)}return a}}let E9=(e,t)=>E4(e,(e,r)=>t(r)),Ae=(e,t)=>An(e,(e,r)=>t(r)),At=(e,t)=>Ai(e,(e,r)=>t(r)),Ar=(e,t)=>Ao(e,(e,r)=>t(r)),Aa=(e,t)=>Al(e,(e,r)=>t(r)),An=(e,t)=>tE(e,E8(t)),Ai=(e,t)=>tE(e,E6(t)),Ao=(e,t)=>tE(e,E7(t)),Al=(e,t)=>tE(e,E5(t)),Ap=e=>{let t,r=new Map,a=e.entries();for(;!(t=a.next()).done;){let[e,a]=t.value;tq(a)&&r.set(e,a.value)}return r},Ac=e=>t=>Ae(t,e),Au=e=>t=>At(t,e),Af=e=>t=>E9(t,e),Ad=e=>t=>E4(t,e),Ah=e=>t=>Ar(t,e),As=e=>t=>Aa(t,e),Am=e=>{let t,r=new Map,a=new Map,n=e.entries();for(;!(t=n.next()).done;){let[e,n]=t.value;tj(n)?r.set(e,n.left):a.set(e,n.right)}return lN(r,a)},AI="Map",Ag=(e,t)=>{let r=Aj(e,t);return{concat:(e,t)=>r(t)(e)}},AR=(e,t)=>({concat:Ag(e,t).concat,empty:new Map}),Av=(e,t)=>{let r=AL(e,t);return{concat:(e,t)=>r(t)(e)}},AW=e=>()=>{let t=AN(e);return{concat:(e,r)=>t(r)(e)}};/**
 * @category filtering
 * @since 2.0.0
 */function AM(){return{URI:AI,_E:void 0,map:E9,mapWithIndex:E4,compact:Ap,separate:Am,filter:Ae,filterMap:At,partition:Ar,partitionMap:Aa,partitionMapWithIndex:Al,partitionWithIndex:Ao,filterMapWithIndex:Ai,filterWithIndex:An}}/**
 * @category filtering
 * @since 2.0.0
 */function Ay(e){let t=AT(e);return{URI:AI,_E:void 0,map:E9,compact:Ap,separate:Am,filter:Ae,filterMap:At,partition:Ar,partitionMap:Aa,reduce:t.reduce,foldMap:t.foldMap,reduceRight:t.reduceRight,traverse:t.traverse,sequence:t.sequence,mapWithIndex:E4,reduceWithIndex:t.reduceWithIndex,foldMapWithIndex:t.foldMapWithIndex,reduceRightWithIndex:t.reduceRightWithIndex,traverseWithIndex:t.traverseWithIndex,wilt:lZ(t,Aq),wither:lY(t,Aq)}}/**
 * @category folding
 * @since 2.11.0
 */let AO=ER,AU=Ev,Ab=EW,Ax=e=>E_(Eq({},EM(e)),{URI:AI}),AE=Ey,AA=EO,AS=EU,AF=e=>E_(Eq({},Eb(e)),{URI:AI}),AT=e=>{let t=AF(e),r=EP(e),a=e=>(t,a)=>{let n=e.of(new Map),i=r(t),o=i.length;for(let r=0;r<o;r++){let o=i[r],l=t.get(o);n=e.ap(e.map(n,e=>t=>e.set(o,t)),a(o,l))}return n};return{URI:AI,_E:void 0,map:E9,mapWithIndex:E4,reduce:t.reduce,foldMap:t.foldMap,reduceRight:t.reduceRight,reduceWithIndex:t.reduceWithIndex,foldMapWithIndex:t.foldMapWithIndex,reduceRightWithIndex:t.reduceRightWithIndex,traverse:e=>{let t=a(e);return(e,r)=>t(e,(e,t)=>r(t))},sequence:e=>{let t=a(e);return e=>t(e,(e,t)=>t)},traverseWithIndex:a}},Aw={URI:AI,map:E9},Ak=/*#__PURE__*/ri(Aw),Aq={URI:AI,compact:Ap,separate:Am},A_={URI:AI,map:E9,compact:Ap,separate:Am,filter:Ae,filterMap:At,partition:Ar,partitionMap:Aa},AK=e=>new Map(e),Aj=(e,t)=>{let r=ES(e,t);return e=>t=>EL(t)?AK(e):EL(e)?AK(t):r(e)(t)},AL=(e,t)=>{let r=EF(e,t);return e=>t=>EL(t)||EL(e)?new Map:r(e)(t)},AN=e=>{let t=ET(e);return e=>r=>EL(r)?AK(e):EL(e)?AK(r):t(e)(r)},AC=new Map,AP=E$,Az=A_,AB=e=>({concat:af(e).concat,empty:e.top}),AD=e=>({concat:ad(e).concat,empty:e.bottom}),AV=e=>({concat:as(e).concat,empty:e.empty}),A$=e=>{let t={};for(let r in e)tJ.call(e,r)&&(t[r]=e[r].empty);return{concat:am(e).concat,empty:t}},AJ=(...e)=>({concat:aI(...e).concat,empty:e.map(e=>e.empty)}),AH=e=>aW(e)(e.empty),AZ={concat:aM.concat,empty:void 0},AY=AJ,AG=A$,AQ=AV,AX=AD,A0=AB,A1=AH,A2={concat:aw.concat,empty:!0},A3={concat:ak.concat,empty:!1},A4=tl,A5=()=>AV(vl()),A7={concat:a_.concat,empty:""},A6={concat:aK.concat,empty:0},A8={concat:aj.concat,empty:1},A9=(e,t,r)=>a=>-1===a?e():0===a?t():r(),Se=A9,St=e=>-1===e?1:1===e?-1:0,Sr={equals:(e,t)=>e===t},Sa={concat:(e,t)=>0!==e?e:t},Sn={concat:Sa.concat,empty:0},Si=e=>e<=-1?-1:+(e>=1),So=St,Sl=Sa,Sp=Sr,Sc=Sn;/**
 * @since 2.0.0
 */function Su(e){return t=>r=>e.map(r,t)}function Sf(e){return t=>r=>e.contramap(r,t)}function Sd(e){return t=>r=>e.mapWithIndex(r,t)}function Sh(e){return t=>r=>e.ap(r,t)}function Ss(e){return t=>r=>e.chain(r,t)}function Sm(e){return(t,r)=>a=>e.bimap(a,t,r)}function SI(e){return t=>r=>e.mapLeft(r,t)}function Sg(e){return t=>r=>e.extend(r,t)}function SR(e){return(t,r)=>a=>e.reduce(a,t,r)}function Sv(e){return t=>{let r=e.foldMap(t);return e=>t=>r(t,e)}}function SW(e){return(t,r)=>a=>e.reduceRight(a,t,r)}function SM(e){return(t,r)=>a=>e.reduceWithIndex(a,t,r)}function Sy(e){return t=>{let r=e.foldMapWithIndex(t);return e=>t=>r(t,e)}}function SO(e){return(t,r)=>a=>e.reduceRightWithIndex(a,t,r)}function SU(e){return t=>r=>e.alt(r,t)}function Sb(e){return t=>r=>e.filter(r,t)}function Sx(e){return t=>r=>e.filterMap(r,t)}function SE(e){return t=>r=>e.partition(r,t)}function SA(e){return t=>r=>e.partitionMap(r,t)}function SS(e){return t=>r=>e.filterWithIndex(r,t)}function SF(e){return t=>r=>e.filterMapWithIndex(r,t)}function ST(e){return t=>r=>e.partitionWithIndex(r,t)}function Sw(e){return t=>r=>e.partitionMapWithIndex(r,t)}function Sk(e){return(t,r)=>a=>e.promap(a,t,r)}function Sq(e){return t=>r=>e.compose(r,t)}/** @deprecated */function S_(e){let t={};return"function"==typeof e.map&&(t.map=Su(e)),"function"==typeof e.contramap&&(t.contramap=Sf(e)),"function"==typeof e.mapWithIndex&&(t.mapWithIndex=Sd(e)),"function"==typeof e.ap&&(t.ap=Sh(e),t.apFirst=t4(e),t.apSecond=t5(e)),"function"==typeof e.chain&&(t.chain=Ss(e),t.chainFirst=rh(e),t.flatten=t.chain(tf)),"function"==typeof e.bimap&&(t.bimap=Sm(e),t.mapLeft=SI(e)),"function"==typeof e.extend&&(t.extend=Sg(e),t.duplicate=t.extend(tf)),"function"==typeof e.reduce&&(t.reduce=SR(e),t.foldMap=Sv(e),t.reduceRight=SW(e)),"function"==typeof e.reduceWithIndex&&(t.reduceWithIndex=SM(e),t.foldMapWithIndex=Sy(e),t.reduceRightWithIndex=SO(e)),"function"==typeof e.alt&&(t.alt=SU(e)),"function"==typeof e.compact&&(t.compact=e.compact,t.separate=e.separate),"function"==typeof e.filter&&(t.filter=Sb(e),t.filterMap=Sx(e),t.partition=SE(e),t.partitionMap=SA(e)),"function"==typeof e.filterWithIndex&&(t.filterWithIndex=SS(e),t.filterMapWithIndex=SF(e),t.partitionWithIndex=ST(e),t.partitionMapWithIndex=Sw(e)),"function"==typeof e.promap&&(t.promap=Sk(e)),"function"==typeof e.compose&&(t.compose=Sq(e)),"function"==typeof e.throwError&&(t.fromOption=t=>r=>"None"===r._tag?e.throwError(t()):e.of(r.value),t.fromEither=t=>"Left"===t._tag?e.throwError(t.left):e.of(t.right),t.fromPredicate=(t,r)=>a=>t(a)?e.of(a):e.throwError(r(a)),t.filterOrElse=(t,r)=>a=>e.chain(a,a=>t(a)?e.of(a):e.throwError(r(a)))),t}/**
 * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */let SK=tE,Sj=()=>Math.random();/**
 * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly
 * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of
 * `low` or `high` is not an integer.
 *
 * @since 2.0.0
 */function SL(e,t){return tE(Sj,yd(r=>Math.floor((t-e+1)*r+e)))}/**
 * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what
 * happens if `maximum < minimum`.
 *
 * @since 2.0.0
 */function SN(e,t){return tE(Sj,yd(r=>(t-e)*r+e))}/**
 * Returns a random boolean value with an equal chance of being `true` or `false`
 *
 * @since 2.0.0
 */let SC=/*#__PURE__*/tE(Sj,yd(e=>e<.5)),SP=e=>tE(SL(0,e.length-1),yd(t=>e[t])),Sz=/*#__PURE__*/Rz(v7),SB=/*#__PURE__*/RP(v7),SD=/*#__PURE__*/RB(v4),SV=/*#__PURE__*/RD(v4),S$=v$,SJ=SD,SH=/*#__PURE__*/R4(v4),SZ=SH,SY=/*#__PURE__*/R5(Wn),SG=SY,SQ=SY,SX=SQ,S0=/*#__PURE__*/R7(Wn),S1=S0,S2=/*#__PURE__*/va(v4),S3=vK,S4=vj,S5=S4,S7=/*#__PURE__*/R8(Wn),S6=S7,S8=/*#__PURE__*/tw(2,ve(Wn)),S9=/*#__PURE__*/vt(Wn),Fe=S9,Ft=/*#__PURE__*/vr(v4),Fr=(e,t)=>tE(e,Fi(t)),Fa=(e,t)=>tE(e,Fu(t)),Fn=(e,t)=>tE(e,FI(t)),Fi=/*#__PURE__*/RH(v4),Fo=/*#__PURE__*/tw(3,R0(v4)),Fl=Fo,Fp=/*#__PURE__*/tw(2,R2(v4)),Fc=Fp,Fu=/*#__PURE__*/RZ(v6),Ff=Fu,Fd=SB,Fh=/*#__PURE__*/tw(2,RG(Wn)),Fs=/*#__PURE__*/Fh(tf),Fm=Fs,FI=/*#__PURE__*/RQ(Wn),Fg=FI,FR=Sz,Fv="ReaderEither",FW=e=>{let t=ga(e);return{URI:Fv,_E:void 0,compact:Ip(v4,t),separate:Ic(v4,t,gc)}};/**
 * @category filtering
 * @since 2.10.0
 */function FM(e){let t=gn(e),r=FW(e),a=vf(v4,t),n=vd(v4,t),i=vh(v4,t),o=vs(v4,t);return{URI:Fv,_E:void 0,map:Fr,compact:r.compact,separate:r.separate,filter:(e,t)=>tE(e,a(t)),filterMap:(e,t)=>tE(e,n(t)),partition:(e,t)=>tE(e,i(t)),partitionMap:(e,t)=>tE(e,o(t))}}/**
 * The default [`Applicative`](#applicative) instance returns the first error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getApplicativeValidation`](./Either.ts.html#getapplicativevalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function Fy(e){let t=t3(v6,go(e));return{URI:Fv,_E:void 0,map:Fr,ap:(e,r)=>tE(e,t(r)),of:Fd}}/**
 * The default [`Alt`](#alt) instance returns the last error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getAltValidation`](./Either.ts.html#getaltvalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function FO(e){let t=R3(Wn,e);return{URI:Fv,_E:void 0,map:Fr,alt:(e,r)=>tE(e,t(r))}}/**
 * @category instances
 * @since 2.7.0
 */let FU={URI:Fv,map:Fr},Fb=tw(2,rc(FU)),Fx=ru(FU),FE=/*#__PURE__*/ri(FU),FA={URI:Fv,of:Fd},FS={URI:Fv,map:Fr,ap:Fa},FF=/*#__PURE__*/t4(FS),FT=FF,Fw=/*#__PURE__*/t5(FS),Fk=Fw,Fq={URI:Fv,map:Fr,ap:Fa,of:Fd},F_={URI:Fv,map:Fr,ap:Fa,chain:Fh},FK={URI:Fv,map:Fr,ap:Fa,of:Fd,chain:Fh},Fj={URI:Fv,fromEither:S$},FL={URI:Fv,fromReader:SJ},FN=/*#__PURE__*/tw(2,rs(F_)),FC=/*#__PURE__*/tw(2,rU(Fj,F_)),FP=/*#__PURE__*/tw(2,W_(FL,F_)),Fz={URI:Fv,bimap:Fo,mapLeft:Fp},FB={URI:Fv,map:Fr,alt:Fn},FD=/*#__PURE__*/WF(FL),FV=/*#__PURE__*/WT(FL),F$=/*#__PURE__*/Ww(FL),FJ=FP,FH=FP,FZ={URI:Fv,map:Fr,ap:Fa,of:Fd,chain:Fh,throwError:FR},FY=/*#__PURE__*/rI(Fj),FG=/*#__PURE__*/rR(Fj),FQ=/*#__PURE__*/rv(Fj,F_),FX=FQ,F0={fromEither:Fj.fromEither},F1={fromReader:FL.fromReader},F2=/*#__PURE__*/tZ(F0),F3=/*#__PURE__*/tY(F0),F4={flatMap:Fh},F5=/*#__PURE__*/tG(F0,F4),F7=/*#__PURE__*/tQ(F0,F4),F6=/*#__PURE__*/tX(F0,F4),F8=/*#__PURE__*/t2(F1,F4),F9=F6,Te=F6,Tt=FC,Tr=FC,Ta=F8,Tn=F8,Ti=/*#__PURE__*/rg(Fj),To=/*#__PURE__*/rO(Fj,F_),Tl=To,Tp=/*#__PURE__*/rW(Fj),Tc=/*#__PURE__*/Fd(t$),Tu=/*#__PURE__*/ro(FU),Tf=/*#__PURE__*/rl(FU),Td=/*#__PURE__*/rm(F_),Th=Td,Ts=/*#__PURE__*/t7(FS),Tm=Ts,TI=/*#__PURE__*/Fd(tV),Tg=e=>tW(WR(e),vB(RU(tS))),TR=e=>{let t=Tg(e);return e=>tz(e)?t(e):TI},Tv=TR,TW=e=>TR((t,r)=>e(r)),TM=/*#__PURE__*/TW(tf),Ty=Fh,TO=Fh,TU=FN,Tb=FN,Tx=S8,TE=S8,TA={URI:Fv,bimap:Fo,mapLeft:Fp,map:Fr,of:Fd,ap:Fa,chain:Fh,alt:Fn,throwError:Sz},TS=/*#__PURE__*/t6(FS),TF=/*#__PURE__*/rf(Fq),TT=e=>t6(v6)(gr(e));/**
 * Use [`getApplicativeReaderValidation`](#getapplicativereadervalidation) and [`getAltReaderValidation`](#getaltreadervalidation) instead.
 *
 * @category zone of death
 * @since 2.3.0
 * @deprecated
 */function Tw(e){let t=Fy(e),r=FO(e);return{URI:Fv,_E:void 0,map:Fr,ap:t.ap,of:Fd,chain:Fh,bimap:Fo,mapLeft:Fp,alt:r.alt,throwError:FR}}/**
 * The reader monad transformer, which adds a read-only environment to the given monad.
 *
 * The `of` function ignores the environment, while `chain` passes the inherited environment to both subcomputations.
 *
 * @since 2.0.0
 */function Tk(e){return t=>()=>e.of(t)}function Tq(e){return t=>r=>a=>e.map(r(a),t)}function T_(e){return t=>r=>a=>e.ap(r(a),t(a))}function TK(e){let t=Tj(e);return e=>r=>t(r,e)}/** @internal */function Tj(e){return(t,r)=>a=>e.chain(t(a),e=>r(e)(a))}function TL(e){return t=>tW(t,e.of)}function TN(e){return t=>tW(t,e)}/** @deprecated *//* istanbul ignore next */function TC(e){let t=T_(e),r=Tq(e),a=TK(e);return{map:(e,t)=>tE(e,r(t)),ap:(e,r)=>tE(e,t(r)),of:Tk(e),chain:(e,t)=>tE(e,a(t)),ask:()=>e.of,asks:t=>tW(t,e.of),local:(e,t)=>r=>e(t(r)),fromReader:TL(e),fromM:e=>()=>e}}/**
 * @since 2.13.0
 */// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.13.0
 */let TP=/*#__PURE__*/TL(yy),Tz=v$,TB=vK,TD=vj,TV=TD,T$=(e,t)=>tE(e,TH(t)),TJ=(e,t)=>tE(e,TZ(t)),TH=/*#__PURE__*/Tq(yR),TZ=/*#__PURE__*/T_(yO),TY=TZ,TG=/*#__PURE__*/Tk(yy),TQ=/*#__PURE__*/tw(2,Tj(yA)),TX=/*#__PURE__*/TQ(tf),T0=TX,T1="ReaderIO",T2={URI:T1,map:T$},T3=tw(2,rc(T2)),T4=ru(T2),T5=/*#__PURE__*/ri(T2),T7={URI:T1,of:TG},T6={URI:T1,map:T$,ap:TJ},T8=/*#__PURE__*/t4(T6),T9=/*#__PURE__*/t5(T6),we={URI:T1,map:T$,ap:TJ,of:TG},wt={URI:T1,map:T$,ap:TJ,chain:TQ},wr={URI:T1,map:T$,of:TG,ap:TJ,chain:TQ},wa={URI:T1,map:T$,of:TG,ap:TJ,chain:TQ,fromIO:Tz},wn={URI:T1,fromIO:Tz},wi={URI:T1,fromReader:TP},wo={flatMap:TQ},wl=t0({fromIO:wn.fromIO},wo),wp=/*#__PURE__*/t2({fromReader:TP},wo),wc=/*#__PURE__*/tw(2,rs(wt)),wu=/*#__PURE__*/tw(2,vk(wn,wt)),wf=/*#__PURE__*/tw(2,W_(wi,wt)),wd=/*#__PURE__*/vF(wn),wh=wl,ws=wu,wm=/*#__PURE__*/WF(wi),wI=/*#__PURE__*/WT(wi),wg=/*#__PURE__*/Ww(wi),wR=wp,wv=wp,wW=wf,wM=wf,wy=/*#__PURE__*/TG(t$),wO=/*#__PURE__*/ro(T2),wU=/*#__PURE__*/rm(wt),wb=wU,wx=/*#__PURE__*/t7(T6),wE=wx,wA=/*#__PURE__*/TG(tV),wS=e=>tW(WR(e),vB(yC(tS))),wF=e=>{let t=wS(e);return e=>tz(e)?t(e):wA},wT=wF,ww=e=>wF((t,r)=>e(r)),wk=/*#__PURE__*/ww(tf),wq=TQ,w_=TQ,wK=wc,wj=wc,wL=e=>()=>Promise.resolve().then(e);// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Creates a task that will complete after a time delay
 *
 * @example
 * import { sequenceT } from 'fp-ts/Apply'
 * import * as T from 'fp-ts/Task'
 * import { takeRight } from 'fp-ts/Array'
 *
 * async function test() {
 *   const log: Array<string> = []
 *   const append = (message: string): T.Task<void> =>
 *     T.fromIO(() => {
 *       log.push(message)
 *     })
 *   const fa = append('a')
 *   const fb = T.delay(20)(append('b'))
 *   const fc = T.delay(10)(append('c'))
 *   const fd = append('d')
 *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()
 *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])
 * }
 *
 * test()
 *
 * @since 2.0.0
 */function wN(e){return t=>()=>new Promise(r=>{setTimeout(()=>{Promise.resolve().then(t).then(r)},e)})}let wC=(e,t)=>tE(e,wB(t)),wP=(e,t)=>tE(e,wD(t)),wz=(e,t)=>w$(e,e=>tE(t,wB(e))),wB=e=>t=>()=>Promise.resolve().then(t).then(e),wD=e=>t=>()=>Promise.all([Promise.resolve().then(t),Promise.resolve().then(e)]).then(([e,t])=>e(t)),wV=e=>()=>Promise.resolve(e),w$=/*#__PURE__*/tw(2,(e,t)=>()=>Promise.resolve().then(e).then(e=>t(e)())),wJ=/*#__PURE__*/w$(tf),wH="Task";/**
 * Monoid returning the first completed task.
 *
 * Note: uses `Promise.race` internally.
 *
 * @example
 * import * as T from 'fp-ts/Task'
 *
 * async function test() {
 *   const S = T.getRaceMonoid<string>()
 *   const fa = T.delay(20)(T.of('a'))
 *   const fb = T.delay(10)(T.of('b'))
 *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')
 * }
 *
 * test()
 *
 * @category instances
 * @since 2.0.0
 */function wZ(){return{concat:(e,t)=>()=>Promise.race([Promise.resolve().then(e),Promise.resolve().then(t)]),empty:ku}}/**
 * @category instances
 * @since 2.7.0
 */let wY={URI:wH,map:wC},wG=tw(2,rc(wY)),wQ=ru(wY),wX=/*#__PURE__*/ri(wY),w0={URI:wH,of:wV},w1={URI:wH,map:wC,ap:wP},w2=/*#__PURE__*/t4(w1),w3=/*#__PURE__*/t5(w1),w4={URI:wH,map:wC,ap:wP,of:wV},w5={URI:wH,map:wC,ap:wz},w7={URI:wH,map:wC,ap:wz,of:wV},w6={URI:wH,map:wC,ap:wP,chain:w$},w8={URI:wH,map:wC,of:wV,ap:wP,chain:w$},w9={URI:wH,map:wC,of:wV,ap:wP,chain:w$,fromIO:wL},ke=tf,kt={URI:wH,map:wC,of:wV,ap:wP,chain:w$,fromIO:wL,fromTask:ke},kr={URI:wH,fromIO:wL},ka=t0({fromIO:kr.fromIO},{flatMap:w$}),kn=/*#__PURE__*/tw(2,rs(w6)),ki=/*#__PURE__*/tw(2,vk(kr,w6)),ko=/*#__PURE__*/vF(kr),kl=ka,kp=ki,kc={URI:wH,fromIO:wL,fromTask:ke},ku=()=>new Promise(e=>void 0),kf=/*#__PURE__*/wV(t$),kd=/*#__PURE__*/ro(wY),kh=/*#__PURE__*/rl(wY),ks=/*#__PURE__*/rm(w6),km=/*#__PURE__*/t7(w1),kI=/*#__PURE__*/wV(tV),kg=e=>t=>()=>Promise.all(t.map((t,r)=>Promise.resolve().then(()=>e(r,t)()))),kR=e=>{let t=kg(e);return e=>tz(e)?t(e):kI},kv=e=>t=>()=>tD(t).reduce((t,r,a)=>t.then(t=>Promise.resolve().then(e(a+1,r)).then(e=>(t.push(e),t))),Promise.resolve().then(e(0,tB(t))).then(tP)),kW=e=>{let t=kv(e);return e=>tz(e)?t(e):kI},kM=kR,ky=e=>kR((t,r)=>e(r)),kO=/*#__PURE__*/ky(tf),kU=kW,kb=e=>kW((t,r)=>e(r)),kx=/*#__PURE__*/kb(tf),kE=w$,kA=kn,kS={URI:wH,map:wC,of:wV,ap:wP,chain:w$,fromIO:wL,fromTask:ke},kF={URI:wH,map:wC,of:wV,ap:wz,chain:w$,fromIO:wL,fromTask:ke},kT=/*#__PURE__*/t6(w5),kw=/*#__PURE__*/rf(w7),kk=/*#__PURE__*/TL(w0),kq=v$,k_=/*#__PURE__*/tW(wL,kq),kK=vB(wL),kj=vK,kL=vj,kN=kL,kC=(e,t)=>tE(e,kB(t)),kP=(e,t)=>tE(e,kD(t)),kz=(e,t)=>kJ(e,e=>tE(t,kB(e))),kB=/*#__PURE__*/Tq(wY),kD=/*#__PURE__*/T_(w1),kV=kD,k$=/*#__PURE__*/Tk(w0),kJ=/*#__PURE__*/tw(2,Tj(w8)),kH=/*#__PURE__*/kJ(tf),kZ=kH,kY="ReaderTask",kG={URI:kY,map:kC},kQ=tw(2,rc(kG)),kX=ru(kG),k0=/*#__PURE__*/ri(kG),k1={URI:kY,of:k$},k2={URI:kY,map:kC,ap:kP},k3=/*#__PURE__*/t4(k2),k4=k3,k5=/*#__PURE__*/t5(k2),k7=k5,k6={URI:kY,map:kC,ap:kP,of:k$},k8={URI:kY,map:kC,ap:kz},k9={URI:kY,map:kC,ap:kz,of:k$},qe={URI:kY,map:kC,ap:kP,chain:kJ},qt={URI:kY,map:kC,of:k$,ap:kP,chain:kJ},qr={URI:kY,map:kC,of:k$,ap:kP,chain:kJ,fromIO:k_},qa={URI:kY,map:kC,of:k$,ap:kP,chain:kJ,fromIO:k_,fromTask:kq},qn={URI:kY,fromIO:k_},qi={URI:kY,fromIO:k_,fromTask:kq},qo={URI:kY,fromReader:kk},ql={flatMap:kJ},qp=t0({fromIO:qn.fromIO},ql),qc=t1({fromTask:kq},ql),qu=t2({fromReader:kk},ql),qf=/*#__PURE__*/tw(2,(e,t)=>kJ(e,qE(t))),qd=/*#__PURE__*/tw(2,rs(qe)),qh=/*#__PURE__*/tw(2,vk(qn,qe)),qs=/*#__PURE__*/tw(2,W_(qo,qe)),qm=/*#__PURE__*/tw(2,MW(qi,qe)),qI=/*#__PURE__*/tw(2,(e,t)=>qd(e,qE(t))),qg=/*#__PURE__*/vF(qn),qR=qp,qv=qh,qW=/*#__PURE__*/WF(qo),qM=/*#__PURE__*/WT(qo),qy=/*#__PURE__*/Ww(qo),qO=qu,qU=qu,qb=qs,qx=qs,qE=e=>(...t)=>kK(e(...t)),qA=qf,qS=qf,qF=qI,qT=qI,qw=/*#__PURE__*/Mg(qi),qk=qc,qq=qm,q_=/*#__PURE__*/k$(t$),qK=/*#__PURE__*/ro(kG),qj=/*#__PURE__*/rl(kG),qL=/*#__PURE__*/rm(qe),qN=qL,qC=/*#__PURE__*/t7(k2),qP=qC,qz=/*#__PURE__*/k$(tV),qB=e=>tW(WR(e),vB(kg(tS))),qD=e=>{let t=qB(e);return e=>tz(e)?t(e):qz},qV=e=>tW(WR(e),vB(kv(tS))),q$=e=>{let t=qV(e);return e=>tz(e)?t(e):qz},qJ=qD,qH=e=>qD((t,r)=>e(r)),qZ=/*#__PURE__*/qH(tf),qY=q$,qG=e=>q$((t,r)=>e(r)),qQ=kJ,qX=kJ,q0=qd,q1=qd,q2=/*#__PURE__*/qG(tf),q3={URI:kY,map:kC,of:k$,ap:kP,chain:kJ,fromIO:k_,fromTask:kq},q4={URI:kY,map:kC,of:k$,ap:kz,chain:kJ,fromIO:k_,fromTask:kq},q5=/*#__PURE__*/t6(k8),q7=/*#__PURE__*/rf(k9);/**
 * @category zone of death
 * @since 2.4.0
 * @deprecated
 *//* istanbul ignore next */function q6(e,t){return e(t)()}/**
 * ```ts
 * interface TaskEither<E, A> extends Task<Either<E, A>> {}
 * ```
 *
 * `TaskEither<E, A>` represents an asynchronous computation that either yields a value of type `A` or fails yielding an
 * error of type `E`. If you want to represent an asynchronous computation that never fails, please see `Task`.
 *
 * @since 2.0.0
 */function q8(e,t,r,a,n,i,o){try{var l=e[i](o),p=l.value}catch(e){r(e);return}l.done?t(p):Promise.resolve(p).then(a,n)}// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */let q9=/*#__PURE__*/Rz(w0),_e=/*#__PURE__*/RP(w0),_t=/*#__PURE__*/RB(wY),_r=/*#__PURE__*/RD(wY),_a=/*#__PURE__*/tW(wL,_t),_n=/*#__PURE__*/tW(wL,_r),_i=_a,_o=_t,_l=wV,_p=wL,_c=e=>wB(gC(e)),_u=/*#__PURE__*/R4(wY),_f=_u,_d=/*#__PURE__*/R5(w8),_h=_d,_s=_d,_m=_s,_I=/*#__PURE__*/R7(w8),_g=/*#__PURE__*/R6(w8),_R=(e,t)=>()=>{var r;return(r=function*(){try{return yield e().then(tC)}catch(e){return tN(t(e))}},function(){var e=this,t=arguments;return new Promise(function(a,n){var i=r.apply(e,t);function o(e){q8(i,a,n,o,l,"next",e)}function l(e){q8(i,a,n,o,l,"throw",e)}o(void 0)})})()},_v=(e,t)=>(...r)=>_R(()=>e(...r),t),_W=/*#__PURE__*/va(wY),_M=/*#__PURE__*/RV(w0),_y=/*#__PURE__*/R$(w0),_O=/*#__PURE__*/RJ(w8),_U=/*#__PURE__*/R8(w8),_b=_U,_x=/*#__PURE__*/tw(2,ve(w8)),_E=e=>_x(KV(e)),_A=e=>_x(KH(e)),_S=/*#__PURE__*/vt(w8),_F=/*#__PURE__*/vr(wY),_T=e=>{let t=_c(e);return e=>tW(e,t)},_w=e=>t=>r=>_$(r,_T(e)(t)),_k=_w,_q=e=>tW(e,_p),__=(e,t)=>tE(e,_N(t)),_K=(e,t)=>tE(e,_D(t)),_j=(e,t)=>_$(e,e=>tE(t,_N(e))),_L=(e,t)=>tE(e,_Z(t)),_N=/*#__PURE__*/RH(wY),_C=/*#__PURE__*/tw(3,R0(wY)),_P=_C,_z=/*#__PURE__*/tw(2,R2(wY)),_B=_z,_D=/*#__PURE__*/RZ(w1),_V=_D,_$=/*#__PURE__*/tw(2,RG(w8)),_J=/*#__PURE__*/_$(tf),_H=_J,_Z=/*#__PURE__*/RQ(w8),_Y=_Z,_G=_e,_Q=q9,_X="TaskEither";/**
 * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as S from 'fp-ts/Semigroup'
 * import * as string from 'fp-ts/string'
 * import * as T from 'fp-ts/Task'
 * import * as TE from 'fp-ts/TaskEither'
 *
 * interface User {
 *   readonly id: string
 *   readonly name: string
 * }
 *
 * const remoteDatabase: ReadonlyArray<User> = [
 *   { id: 'id1', name: 'John' },
 *   { id: 'id2', name: 'Mary' },
 *   { id: 'id3', name: 'Joey' }
 * ]
 *
 * const fetchUser = (id: string): TE.TaskEither<string, User> =>
 *   pipe(
 *     remoteDatabase,
 *     RA.findFirst((user) => user.id === id),
 *     TE.fromOption(() => `${id} not found`)
 *   )
 *
 * async function test() {
 *   assert.deepStrictEqual(
 *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),
 *     E.left('id4 not found') // <= first error
 *   )
 *
 *   const Applicative = TE.getApplicativeTaskValidation(
 *     T.ApplyPar,
 *     pipe(string.Semigroup, S.intercalate(', '))
 *   )
 *
 *   assert.deepStrictEqual(
 *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),
 *     E.left('id4 not found, id5 not found') // <= all errors
 *   )
 * }
 *
 * test()
 *
 * @category error handling
 * @since 2.7.0
 */function _0(e,t){let r=t3(e,go(t));return{URI:_X,_E:void 0,map:__,ap:(e,t)=>tE(e,r(t)),of:_G}}/**
 * The default [`Alt`](#alt) instance returns the last error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getAltValidation`](./Either.ts.html#getaltvalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function _1(e){let t=R3(w8,e);return{URI:_X,_E:void 0,map:__,alt:(e,r)=>tE(e,t(r))}}/**
 * @category filtering
 * @since 2.10.0
 */let _2=e=>{let t=ga(e);return{URI:_X,_E:void 0,compact:Ip(wY,t),separate:Ic(wY,t,gc)}};/**
 * @category filtering
 * @since 2.1.0
 */function _3(e){let t=gn(e),r=_2(e),a=vf(wY,t),n=vd(wY,t),i=vh(wY,t),o=vs(wY,t);return{URI:_X,_E:void 0,map:__,compact:r.compact,separate:r.separate,filter:(e,t)=>tE(e,a(t)),filterMap:(e,t)=>tE(e,n(t)),partition:(e,t)=>tE(e,i(t)),partitionMap:(e,t)=>tE(e,o(t))}}/**
 * @category instances
 * @since 2.7.0
 */let _4={URI:_X,map:__},_5=tw(2,rc(_4)),_7=ru(_4),_6=/*#__PURE__*/ri(_4),_8={URI:_X,of:_G},_9={URI:_X,map:__,ap:_K},Ke=/*#__PURE__*/t4(_9),Kt=Ke,Kr=/*#__PURE__*/t5(_9),Ka=Kr,Kn={URI:_X,map:__,ap:_K,of:_G},Ki={URI:_X,map:__,ap:_j},Ko={URI:_X,map:__,ap:_j,of:_G},Kl={URI:_X,map:__,ap:_K,chain:_$},Kp={URI:_X,map:__,ap:_K,chain:_$,of:_G},Kc={URI:_X,map:__,ap:_K,chain:_$,of:_G,fromIO:_i},Ku={URI:_X,map:__,ap:_K,chain:_$,of:_G,fromIO:_i,fromTask:_o},Kf={URI:_X,map:__,ap:_K,chain:_$,of:_G,throwError:_Q},Kd={URI:_X,fromEither:_l},Kh={URI:_X,fromIO:_i},Ks={URI:_X,fromIO:_i,fromTask:_o},Km=/*#__PURE__*/tw(2,rs(Kl)),KI=/*#__PURE__*/tw(2,rU(Kd,Kl)),Kg=/*#__PURE__*/tw(2,vk(Kh,Kl)),KR=/*#__PURE__*/tw(2,MW(Ks,Kl)),Kv={URI:_X,bimap:_C,mapLeft:_z},KW={URI:_X,map:__,alt:_L},KM=/*#__PURE__*/rI(Kd),Ky=/*#__PURE__*/rR(Kd),KO=/*#__PURE__*/rv(Kd,Kl),KU=KO,Kb={fromEither:Kd.fromEither},Kx=/*#__PURE__*/tZ(Kb),KE=/*#__PURE__*/tY(Kb),KA={flatMap:_$},KS={fromIO:Kh.fromIO},KF=/*#__PURE__*/tG(Kb,KA),KT=/*#__PURE__*/tQ(Kb,KA),Kw=/*#__PURE__*/tX(Kb,KA),Kk=/*#__PURE__*/t0(KS,KA),Kq=/*#__PURE__*/t1({fromTask:_o},KA),K_=/*#__PURE__*/tw(2,(e,t)=>_$(e,_q(t))),KK=/*#__PURE__*/tw(3,(e,t,r)=>_$(e,e=>_c(()=>r(e))(t(e)))),Kj=Kw,KL=Kw,KN=KI,KC=KI,KP=/*#__PURE__*/rg(Kd),Kz=/*#__PURE__*/rO(Kd,Kl),KB=Kz,KD=/*#__PURE__*/rW(Kd),KV=/*#__PURE__*/vF(Kh),K$=Kk,KJ=Kg,KH=/*#__PURE__*/Mg(Ks),KZ=Kq,KY=KR,KG=K_,KQ=K_;function KX(e){return function(){let t=Array.prototype.slice.call(arguments);return()=>new Promise(r=>{e.apply(null,t.concat((e,t)=>null!=e?r(tN(e)):r(tC(t))))})}}/**
 * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
 * whether the body action throws (\*) or returns.
 *
 * (\*) i.e. returns a `Left`
 *
 * @since 2.0.0
 */let K0=(e,t,r)=>K1(e,t,r),K1=(e,t,r)=>_$(e,e=>w$(t(e),t=>_$(r(e,t),()=>wV(t)))),K2=/*#__PURE__*/_G(t$),K3=/*#__PURE__*/ro(_4),K4=/*#__PURE__*/rl(_4),K5=/*#__PURE__*/rm(Kl),K7=K5,K6=/*#__PURE__*/t7(_9),K8=K6,K9=/*#__PURE__*/_G(tV),je=e=>tW(kg(e),wB(RU(tS))),jt=e=>{let t=je(e);return e=>tz(e)?t(e):K9},jr=e=>t=>()=>tD(t).reduce((t,r,a)=>t.then(n=>tj(n)?t:e(a+1,r)().then(e=>tj(e)?e:(n.right.push(e.right),n))),e(0,tB(t))().then(gp(tP))),ja=e=>{let t=jr(e);return e=>tz(e)?t(e):K9},jn=jt,ji=e=>jt((t,r)=>e(r)),jo=/*#__PURE__*/ji(tf),jl=ja,jp=e=>ja((t,r)=>e(r)),jc=/*#__PURE__*/jp(tf),ju=_$,jf=_$,jd=Km,jh=Km,js=_x,jm=_x,jI={URI:_X,bimap:_C,mapLeft:_z,map:__,of:_G,ap:_K,chain:_$,alt:_L,fromIO:_i,fromTask:_o,throwError:_Q},jg={URI:_X,bimap:_C,mapLeft:_z,map:__,of:_G,ap:_j,chain:_$,alt:_L,fromIO:_i,fromTask:_o,throwError:_Q},jR=/*#__PURE__*/t6(Ki),jv=/*#__PURE__*/rf(Ko),jW=e=>t6(w5)(gr(e));/**
 * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */function jM(e){let t=_0(w4,e),r=_1(e);return{URI:_X,_E:void 0,map:__,ap:t.ap,of:_G,chain:_$,bimap:_C,mapLeft:_z,alt:r.alt,fromIO:_i,fromTask:_o,throwError:_Q}}/**
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.0.0
 */let jy=v$,jO=/*#__PURE__*/Rz(k1),jU=/*#__PURE__*/RP(k1),jb=/*#__PURE__*/tW(_t,jy),jx=/*#__PURE__*/tW(_r,jy),jE=e=>tW(e,_e),jA=e=>tW(e,q9),jS=/*#__PURE__*/RB(kG),jF=/*#__PURE__*/RD(kG),jT=/*#__PURE__*/tW(_a,jy),jw=/*#__PURE__*/tW(_n,jy),jk=e=>tW(e,_a),jq=e=>tW(e,_n),j_=k$,jK=jE,jj=jT,jL=jb,jN=/*#__PURE__*/tW(_p,jy),jC=e=>tW(e,_l),jP=/*#__PURE__*/R4(kG),jz=jP,jB=/*#__PURE__*/R5(qe),jD=jB,jV=jB,j$=jV,jJ=/*#__PURE__*/R7(qt),jH=jJ,jZ=/*#__PURE__*/va(kG),jY=/*#__PURE__*/RV(k1),jG=/*#__PURE__*/R$(k1),jQ=/*#__PURE__*/RJ(qt),jX=vK,j0=vj,j1=j0,j2=/*#__PURE__*/R8(qt),j3=j2,j4=/*#__PURE__*/tw(2,ve(qt)),j5=/*#__PURE__*/vt(qt),j7=j5,j6=/*#__PURE__*/vr(kG),j8=e=>tW(e,jN),j9=e=>tW(e,jy),Le=e=>tW(e,jC),Lt=(e,t)=>tE(e,Li(t)),Lr=(e,t)=>tE(e,Lu(t)),La=(e,t)=>Lh(e,e=>tE(t,Li(e))),Ln=(e,t)=>tE(e,LI(t)),Li=/*#__PURE__*/RH(kG),Lo=/*#__PURE__*/tw(3,R0(kG)),Ll=Lo,Lp=/*#__PURE__*/tw(2,R2(kG)),Lc=Lp,Lu=/*#__PURE__*/RZ(k2),Lf=Lu,Ld=jU,Lh=/*#__PURE__*/tw(2,RG(qt)),Ls=/*#__PURE__*/Lh(tf),Lm=Ls,LI=/*#__PURE__*/RQ(qt),Lg=LI,LR=jO,Lv="ReaderTaskEither",LW=e=>{let t=ga(e);return{URI:Lv,_E:void 0,compact:Ip(kG,t),separate:Ic(kG,t,gc)}};/**
 * @category filtering
 * @since 2.10.0
 */function LM(e){let t=gn(e),r=LW(e),a=vf(kG,t),n=vd(kG,t),i=vh(kG,t),o=vs(kG,t);return{URI:Lv,_E:void 0,map:Lt,compact:r.compact,separate:r.separate,filter:(e,t)=>tE(e,a(t)),filterMap:(e,t)=>tE(e,n(t)),partition:(e,t)=>tE(e,i(t)),partitionMap:(e,t)=>tE(e,o(t))}}/**
 * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getApplicativeValidation`](./Either.ts.html#getapplicativevalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function Ly(e,t){let r=t3(v6,_0(e,t));return{URI:Lv,_E:void 0,map:Lt,ap:(e,t)=>tE(e,r(t)),of:Ld}}/**
 * The default [`Alt`](#alt) instance returns the last error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * See [`getAltValidation`](./Either.ts.html#getaltvalidation).
 *
 * @category error handling
 * @since 2.7.0
 */function LO(e){let t=R3(qt,e);return{URI:Lv,_E:void 0,map:Lt,alt:(e,r)=>tE(e,t(r))}}/**
 * @category instances
 * @since 2.7.0
 */let LU={URI:Lv,map:Lt},Lb=tw(2,rc(LU)),Lx=ru(LU),LE=/*#__PURE__*/ri(LU),LA={URI:Lv,of:Ld},LS={URI:Lv,map:Lt,ap:Lr},LF=/*#__PURE__*/t4(LS),LT=LF,Lw=/*#__PURE__*/t5(LS),Lk=Lw,Lq={URI:Lv,map:Lt,ap:Lr,of:Ld},L_={URI:Lv,map:Lt,ap:La},LK={URI:Lv,map:Lt,ap:La,of:Ld},Lj={URI:Lv,map:Lt,ap:Lr,chain:Lh},LL={URI:Lv,map:Lt,ap:Lr,chain:Lh,of:Ld},LN={URI:Lv,map:Lt,ap:Lr,chain:Lh,of:Ld,fromIO:jj},LC={URI:Lv,map:Lt,ap:Lr,chain:Lh,of:Ld,fromIO:jj,fromTask:jL},LP={URI:Lv,map:Lt,ap:Lr,chain:Lh,of:Ld,throwError:LR},Lz={URI:Lv,fromEither:j_},LB={URI:Lv,fromIO:jj},LD={URI:Lv,fromIO:jj,fromTask:jL},LV={URI:Lv,fromReader:jK},L$=/*#__PURE__*/tw(2,rs(Lj)),LJ=/*#__PURE__*/tw(2,rU(Lz,Lj)),LH=/*#__PURE__*/tw(2,vk(LB,Lj)),LZ=/*#__PURE__*/tw(2,MW(LD,Lj)),LY=/*#__PURE__*/tw(2,W_(LV,Lj)),LG=/*#__PURE__*/tw(2,(e,t)=>L$(e,Le(t))),LQ=/*#__PURE__*/tw(2,(e,t)=>L$(e,j9(t))),LX=/*#__PURE__*/tw(2,(e,t)=>L$(e,Nr(t))),L0=/*#__PURE__*/tw(2,(e,t)=>L$(e,Ni(t))),L1={URI:Lv,bimap:Lo,mapLeft:Lp},L2={URI:Lv,map:Lt,alt:Ln},L3=/*#__PURE__*/WF(LV),L4=/*#__PURE__*/WT(LV),L5=/*#__PURE__*/Ww(LV),L7=LY,L6=LY,L8=LG,L9=LG,Ne=LQ,Nt=LQ,Nr=e=>(...t)=>jS(e(...t)),Na=LX,Nn=LX,Ni=e=>(...t)=>jk(e(...t)),No=L0,Nl=L0,Np=/*#__PURE__*/rI(Lz),Nc=/*#__PURE__*/rR(Lz),Nu=/*#__PURE__*/rv(Lz,Lj),Nf=Nu,Nd={fromEither:Lz.fromEither},Nh=/*#__PURE__*/tZ(Nd),Ns=/*#__PURE__*/tY(Nd),Nm={flatMap:Lh},NI=/*#__PURE__*/tG(Nd,Nm),Ng=/*#__PURE__*/tQ(Nd,Nm),NR=/*#__PURE__*/tX(Nd,Nm),Nv=/*#__PURE__*/tw(2,(e,t)=>Lh(e,j9(t))),NW=/*#__PURE__*/tw(2,(e,t)=>Lh(e,Nr(t))),NM=/*#__PURE__*/t0({fromIO:jj},Nm),Ny=/*#__PURE__*/t1({fromTask:jL},Nm),NO=/*#__PURE__*/t2({fromReader:jK},Nm),NU=/*#__PURE__*/tw(2,(e,t)=>Lh(e,Ni(t))),Nb=/*#__PURE__*/tw(2,(e,t)=>Lh(e,j8(t))),Nx=/*#__PURE__*/tw(2,(e,t)=>Lh(e,Le(t))),NE=NR,NA=NR,NS=LJ,NF=LJ,NT=Nv,Nw=Nv,Nk=NW,Nq=NW,N_=/*#__PURE__*/rg(Lz),NK=/*#__PURE__*/rO(Lz,Lj),Nj=NK,NL=/*#__PURE__*/rW(Lz),NN=/*#__PURE__*/vF(LB),NC=NM,NP=LH,Nz=/*#__PURE__*/Mg(LD),NB=Ny,ND=LZ,NV=NO,N$=NO,NJ=NU,NH=NU,NZ=Nb,NY=Nb,NG=Nx,NQ=Nx;// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
 * whether the body action throws (\*) or returns.
 *
 * (\*) i.e. returns a `Left`
 *
 * @since 2.0.4
 */function NX(e,t,r){return N0(e,t,r)}/**
 * Less strict version of [`bracket`](#bracket).
 *
 * @since 2.12.0
 */function N0(e,t,r){return a=>K1(e(a),e=>t(e)(a),(e,t)=>r(e,t)(a))}// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */let N1=/*#__PURE__*/Ld(t$),N2=/*#__PURE__*/ro(LU),N3=/*#__PURE__*/rl(LU),N4=/*#__PURE__*/rm(Lj),N5=N4,N7=/*#__PURE__*/t7(LS),N6=N7,N8=/*#__PURE__*/Ld(tV),N9=e=>tW(WR(e),vB(je(tS))),Ce=e=>{let t=N9(e);return e=>tz(e)?t(e):N8},Ct=e=>tW(WR(e),vB(jr(tS))),Cr=e=>{let t=Ct(e);return e=>tz(e)?t(e):N8},Ca=Ce,Cn=e=>Ce((t,r)=>e(r)),Ci=/*#__PURE__*/Cn(tf),Co=Cr,Cl=e=>Cr((t,r)=>e(r)),Cp=/*#__PURE__*/Cl(tf),Cc=Lh,Cu=Lh,Cf=L$,Cd=L$,Ch=j4,Cs=j4,Cm={URI:Lv,map:Lt,of:Ld,ap:Lr,chain:Lh,alt:Ln,bimap:Lo,mapLeft:Lp,fromIO:jj,fromTask:jL,throwError:LR},CI={URI:Lv,map:Lt,of:Ld,ap:La,chain:Lh,alt:Ln,bimap:Lo,mapLeft:Lp,fromIO:jj,fromTask:jL,throwError:LR},Cg=/*#__PURE__*/t6(L_),CR=/*#__PURE__*/rf(LK),Cv=e=>t6(k8)(gr(e));/**
 * Use [`getApplicativeReaderTaskValidation`](#getapplicativereadertaskvalidation) and [`getAltReaderTaskValidation`](#getaltreadertaskvalidation) instead.
 *
 * @category instances
 * @since 2.3.0
 * @deprecated
 */function CW(e){let t=Ly(w4,e),r=LO(e);return{URI:Lv,_E:void 0,map:Lt,of:Ld,chain:Lh,bimap:Lo,mapLeft:Lp,ap:t.ap,alt:r.alt,fromIO:jj,fromTask:jL,throwError:LR}}/**
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 *//* istanbul ignore next */function CM(e,t){return e(t)()}/**
 * @since 2.10.0
 */// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)
 * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)
 *
 * @category instances
 * @since 2.10.0
 */let Cy={equals:(e,t)=>e===t},CO={concat:(e,t)=>e+t},CU="",Cb={concat:CO.concat,empty:CU},Cx={equals:Cy.equals,compare:(e,t)=>e<t?-1:+(e>t)},CE={show:e=>JSON.stringify(e)},CA=e=>"string"==typeof e,CS=e=>e.toUpperCase(),CF=e=>e.toLowerCase(),CT=(e,t)=>r=>r.replace(e,t),Cw=e=>e.trim(),Ck=e=>e.trimLeft(),Cq=e=>e.trimRight(),C_=(e,t)=>r=>r.slice(e,t),CK=e=>0===e.length,Cj=e=>e.length,CL=e=>t=>{let r=t.split(e);return aN(r)?r:[t]},CN=(e,t)=>r=>r.includes(e,t),CC=(e,t)=>r=>r.startsWith(e,t),CP=(e,t)=>r=>r.endsWith(e,t),Cz=e=>Object.assign({},e),CB=e=>Object.assign({},e),CD=e=>Object.keys(e).length,CV=e=>{for(let t in e)if(tJ.call(e,t))return!1;return!0},C$=e=>t=>Object.keys(t).sort(e.compare),CJ=/*#__PURE__*/C$(Cx);function CH(e){if("function"==typeof e)return CH(Cx)(e);let t=C$(e);return e=>r=>{let a=[];for(let n of t(r))a.push(e(n,r[n]));return a}}/**
 * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.
 *
 * @example
 * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'
 *
 * const x = { c: 3, a: "foo", b: false };
 * assert.deepStrictEqual(toReadonlyArray(x), [
 *   ["a", "foo"],
 *   ["b", false],
 *   ["c", 3],
 * ]);
 *
 * @category conversions
 * @since 2.5.0
 */let CZ=/*#__PURE__*/CH(Cx)((e,t)=>[e,t]);function CY(e){return t=>{let r=CZ(t),a=r.length;return e.unfold(0,e=>e<a?tK([r[e],e+1]):t_)}}/**
 * Insert or replace a key/value pair in a `ReadonlyRecord`.
 *
 * @example
 * import { upsertAt } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.10.0
 */let CG=(e,t)=>r=>{if(tJ.call(r,e)&&r[e]===t)return r;let a=Object.assign({},r);return a[e]=t,a},CQ=(e,t)=>tJ.call(t,e);function CX(e){return t=>{if(!tJ.call(t,e))return t;let r=Object.assign({},t);return delete r[e],r}}/**
 * Replace a key/value pair in a `ReadonlyRecord`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { updateAt } from 'fp-ts/ReadonlyRecord'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.5.0
 */let C0=(e,t)=>r=>{if(!CQ(e,r))return t_;if(r[e]===t)return tK(r);let a=Object.assign({},r);return a[e]=t,tK(a)},C1=(e,t)=>r=>{if(!CQ(e,r))return t_;let a=t(r[e]);if(a===r[e])return tK(r);let n=Object.assign({},r);return n[e]=a,tK(n)};function C2(e){let t=CX(e);return r=>{let a=C4(e,r);return tk(a)?t_:tK([a.value,t(r)])}}function C3(e){return(t,r)=>{if(void 0===r){let r=C3(e);return e=>r(e,t)}for(let a in t)if(!tJ.call(r,a)||!e.equals(t[a],r[a]))return!1;return!0}}function C4(e,t){return void 0===t?t=>C4(e,t):tJ.call(t,e)?tK(t[e]):t_}/**
 * @since 2.5.0
 */let C5={};function C7(e){return t=>{let r={};for(let a in t)tJ.call(t,a)&&(r[a]=e(a,t[a]));return r}}function C6(e){return C7((t,r)=>e(r))}function C8(...e){if(2===e.length)return C8(Cx)(...e);let t=C$(e[0]);return(e,r)=>a=>{let n=e,i=t(a),o=i.length;for(let e=0;e<o;e++){let t=i[e];n=r(t,n,a[t])}return n}}function C9(e){if("compare"in e){let t=C$(e);return e=>r=>a=>{let n=e.empty,i=t(a),o=i.length;for(let t=0;t<o;t++){let o=i[t];n=e.concat(n,r(o,a[o]))}return n}}return C9(Cx)(e)}function Pe(...e){if(2===e.length)return Pe(Cx)(...e);let t=C$(e[0]);return(e,r)=>a=>{let n=e,i=t(a),o=i.length;for(let e=o-1;e>=0;e--){let t=i[e];n=r(t,a[t],n)}return n}}/**
 * Create a `ReadonlyRecord` with one key/value pair.
 *
 * @example
 * import { singleton } from "fp-ts/ReadonlyRecord";
 *
 * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
 *
 * @category constructors
 * @since 2.5.0
 */let Pt=(e,t)=>({[e]:t});function Pr(e){let t=PN(Cx)(e);return e=>r=>t(r,e)}function Pa(e){let t=Pj(Cx)(e);return e=>r=>t(r,e)}function Pn(e){return PL(Cx)(e)}/**
 * @category filtering
 * @since 2.6.5
 */let Pi=e=>{let t=Pa(e);return r=>a=>e.map(tE(a,t(r)),PJ)},Po=e=>{let t=Pa(e);return r=>a=>e.map(tE(a,t(r)),PH)};function Pl(e){return t=>{let r={},a={};for(let n in t)if(tJ.call(t,n)){let i=e(n,t[n]);switch(i._tag){case"Left":r[n]=i.left;break;case"Right":a[n]=i.right}}return lN(r,a)}}function Pp(e){return t=>{let r={},a={};for(let n in t)if(tJ.call(t,n)){let i=t[n];e(n,i)?a[n]=i:r[n]=i}return lN(r,a)}}function Pc(e){return t=>{let r={};for(let a in t)if(tJ.call(t,a)){let n=e(a,t[a]);tq(n)&&(r[a]=n.value)}return r}}function Pu(e){return t=>{let r={},a=!1;for(let n in t)if(tJ.call(t,n)){let i=t[n];e(n,i)?r[n]=i:a=!0}return a?r:t}}function Pf(e,t){let r=Pd(e,t);return e=>r(e,tf)}function Pd(e,t){return(r,a)=>t.reduce(r,{},(t,r)=>{let[n,i]=a(r);return t[n]=tJ.call(t,n)?e.concat(t[n],i):i,t})}/**
 * Alias of [`toReadonlyArray`](#toreadonlyarray).
 *
 * @example
 * import { toEntries } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])
 *
 * @category conversions
 * @since 2.12.0
 */let Ph=CZ,Ps=e=>{let t={};for(let r of e)t[r[0]]=r[1];return t};function Pm(e){return t=>{for(let r in t)if(!e(t[r]))return!1;return!0}}/**
 * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.
 *
 * @example
 * import { some } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);
 *
 * @since 2.5.0
 */function PI(e){return t=>{for(let r in t)if(e(t[r]))return!0;return!1}}function Pg(e){return(t,r)=>{if(void 0===r){let r=Pg(e);return e=>r(t,e)}for(let a in r)if(e.equals(r[a],t))return!0;return!1}}/**
 * Union of two `ReadonlyRecord`s.
 * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the
 * entries of the two inputs.
 * It uses the `concat` function of the provided `Magma` to
 * combine the elements with the same key.
 *
 * @example
 * import { union } from "fp-ts/ReadonlyRecord";
 * import { Magma } from "fp-ts/Magma";
 *
 * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
 * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });
 * const m2: Magma<number> = { concat: (x: number) => x };
 * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });
 *
 * @since 2.11.0
 */let PR=e=>t=>r=>{if(CV(r))return t;if(CV(t))return r;let a={};for(let n in r)CQ(n,t)?a[n]=e.concat(r[n],t[n]):a[n]=r[n];for(let e in t)CQ(e,a)||(a[e]=t[e]);return a},Pv=e=>t=>r=>{if(CV(r)||CV(t))return C5;let a={};for(let n in r)CQ(n,t)&&(a[n]=e.concat(r[n],t[n]));return a},PW=e=>t=>{if(CV(t))return e;if(CV(e))return t;let r={};for(let a in t)CQ(a,e)||(r[a]=t[a]);for(let a in e)CQ(a,t)||(r[a]=e[a]);return r},PM=(e,t)=>tE(e,C6(t)),Py=(e,t)=>tE(e,C7(t)),PO=e=>{let t=PD(e);return(e,r,a)=>tE(e,t(r,a))},PU=e=>t=>{let r=PV(e)(t);return(e,t)=>tE(e,r(t))},Pb=e=>{let t=P$(e);return(e,r,a)=>tE(e,t(r,a))},Px=(e,t)=>tE(e,PC(t)),PE=(e,t)=>tE(e,PP(t)),PA=(e,t)=>tE(e,Pz(t)),PS=(e,t)=>tE(e,PB(t)),PF=e=>{let t=C8(e);return(e,r,a)=>tE(e,t(r,a))},PT=e=>{let t=C9(e);return e=>{let r=t(e);return(e,t)=>tE(e,r(t))}},Pw=e=>{let t=Pe(e);return(e,r,a)=>tE(e,t(r,a))},Pk=(e,t)=>tE(e,Pl(t)),Pq=(e,t)=>tE(e,Pp(t)),P_=(e,t)=>tE(e,Pc(t)),PK=(e,t)=>tE(e,Pu(t)),Pj=e=>{let t=PN(e);return e=>{let r=t(e);return(e,t)=>r(e,tW(tS,t))}},PL=e=>{let t=Pj(e);return e=>{let r=t(e);return e=>r(e,tf)}},PN=e=>t=>{let r=C$(e);return(e,a)=>{let n=r(e);if(0===n.length)return t.of(C5);let i=t.of({});for(let r of n)i=t.ap(t.map(i,e=>t=>Object.assign({},e,{[r]:t})),a(r,e[r]));return i}},PC=e=>Pu((t,r)=>e(r)),PP=e=>Pc((t,r)=>e(r)),Pz=e=>Pp((t,r)=>e(r)),PB=e=>Pl((t,r)=>e(r));function PD(...e){if(1===e.length){let t=C8(e[0]);return(e,r)=>t(e,(e,t,a)=>r(t,a))}return PD(Cx)(...e)}function PV(e){if("compare"in e){let t=C9(e);return e=>{let r=t(e);return e=>r((t,r)=>e(r))}}return PV(Cx)(e)}function P$(...e){if(1===e.length){let t=Pe(e[0]);return(e,r)=>t(e,(e,t,a)=>r(t,a))}return P$(Cx)(...e)}/**
 * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and
 * keeping the `Some` values.
 *
 * @example
 * import { compact } from 'fp-ts/ReadonlyRecord'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
 *   a: "foo",
 *   c: "bar",
 * });
 *
 * @category filtering
 * @since 2.5.0
 */let PJ=e=>{let t={};for(let r in e)if(tJ.call(e,r)){let a=e[r];tq(a)&&(t[r]=a.value)}return t},PH=e=>{let t={},r={};for(let a in e)if(tJ.call(e,a)){let n=e[a];tj(n)?t[a]=n.left:r[a]=n.right}return lN(t,r)},PZ="ReadonlyRecord";function PY(e){return"compare"in e?t=>({show:r=>{let a=CH(e)((e,r)=>`${JSON.stringify(e)}: ${t.show(r)}`)(r).join(", ");return""===a?"{}":`{ ${a} }`}}):PY(Cx)(e)}function PG(e){let t=C3(e);return rb((e,r)=>t(e)(r)&&t(r)(e))}function PQ(e){return{concat:(t,r)=>{if(CV(t))return r;if(CV(r))return t;let a=Object.assign({},t);for(let n in r)tJ.call(r,n)&&(a[n]=tJ.call(t,n)?e.concat(t[n],r[n]):r[n]);return a},empty:C5}}/**
 * @category instances
 * @since 2.7.0
 */let PX={URI:PZ,map:PM},P0=/*#__PURE__*/ri(PX),P1={URI:PZ,map:PM,mapWithIndex:Py},P2=e=>({URI:PZ,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e)}),P3=e=>({URI:PZ,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),reduceWithIndex:PF(e),foldMapWithIndex:PT(e),reduceRightWithIndex:Pw(e)}),P4={URI:PZ,compact:PJ,separate:PH},P5={URI:PZ,map:PM,compact:PJ,separate:PH,filter:Px,filterMap:PE,partition:PA,partitionMap:PS},P7={URI:PZ,map:PM,mapWithIndex:Py,compact:PJ,separate:PH,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,filterMapWithIndex:P_,filterWithIndex:PK,partitionMapWithIndex:Pk,partitionWithIndex:Pq},P6=e=>({URI:PZ,map:PM,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),traverse:Pj(e),sequence:PL(e)}),P8=e=>({URI:PZ,map:PM,mapWithIndex:Py,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),reduceWithIndex:PF(e),foldMapWithIndex:PT(e),reduceRightWithIndex:Pw(e),traverse:Pj(e),sequence:PL(e),traverseWithIndex:PN(e)}),P9=e=>{let t=P6(e);return{URI:PZ,map:PM,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),traverse:t.traverse,sequence:t.sequence,compact:PJ,separate:PH,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,wither:lY(t,P4),wilt:lZ(t,P4)}},ze=e=>{let t=PR(e);return{concat:(e,r)=>t(r)(e)}},zt=e=>({concat:ze(e).concat,empty:C5}),zr=e=>{let t=Pv(e);return{concat:(e,r)=>t(r)(e)}},za=()=>({concat:(e,t)=>PW(t)(e)}),zn={URI:PZ,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx)},zi={URI:PZ,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx)},zo={URI:PZ,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:Pn},zl={URI:PZ,map:PM,mapWithIndex:Py,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:Pn,traverseWithIndex:/*#__PURE__*/PN(Cx)},zp=/*#__PURE__*/lY(zo,P4),zc=/*#__PURE__*/lZ(zo,P4),zu={URI:PZ,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:Pn,compact:PJ,separate:PH,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,wither:zp,wilt:zc},zf=CG;function zd(e,t){return tJ.call(void 0===t?this:t,e)}/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`
 * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */let zh={URI:PZ,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:Pn,compact:PJ,separate:PH,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,mapWithIndex:Py,reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx),filterMapWithIndex:P_,filterWithIndex:PK,partitionMapWithIndex:Pk,partitionWithIndex:Pq,traverseWithIndex:/*#__PURE__*/PN(Cx),wither:zp,wilt:zc},zs=e=>new Set(e),zm=e=>new Set([e]),zI=e=>t=>{let r=t.length,a=new Set,n=zP(e);for(let e=0;e<r;e++){let r=t[e];n(r,a)||a.add(r)}return a};/**
 * @category conversions
 * @since 2.5.0
 */function zg(e){return new Set(e)}/**
 * Projects a Set through a function
 *
 * @since 2.5.0
 */function zR(e){let t=zP(e);return e=>r=>{let a=new Set;return r.forEach(r=>{let n=e(r);t(n,a)||a.add(n)}),a}}/**
 * @since 2.5.0
 */function zv(e){let t=zP(e);return e=>r=>{let a=new Set;return r.forEach(r=>{e(r).forEach(e=>{t(e,a)||a.add(e)})}),a}}function zW(e){return t=>{let r,a=t.values(),n=new Set;for(;!(r=a.next()).done;){let t=r.value;e(t)&&n.add(t)}return n}}function zM(e){return t=>{let r,a=t.values(),n=new Set,i=new Set;for(;!(r=a.next()).done;){let t=r.value;e(t)?n.add(t):i.add(t)}return lN(i,n)}}function zy(e){let t=zP(e);return(r,a)=>{if(void 0===a){let t=zy(e);return e=>t(r,e)}if(zK(r))return a;if(zK(a))return r;let n=new Set(r);return a.forEach(e=>{t(e,n)||n.add(e)}),n}}function zO(e){let t=zP(e);return(r,a)=>{if(void 0===a){let t=zO(e);return e=>t(e,r)}if(zK(r)||zK(a))return z_;let n=new Set;return r.forEach(e=>{t(e,a)&&n.add(e)}),n}}/**
 * @since 2.5.0
 */function zU(e,t){return r=>a=>{let n,i=a.values(),o=new Set,l=new Set,p=zP(e),c=zP(t);for(;!(n=i.next()).done;){let e=r(n.value);switch(e._tag){case"Left":p(e.left,o)||o.add(e.left);break;case"Right":c(e.right,l)||l.add(e.right)}}return lN(o,l)}}function zb(e){let t=zP(e);return(r,a)=>{if(void 0===a){let t=zb(e);return e=>t(e,r)}return zW(e=>!t(e,a))(r)}}/**
 * @since 2.5.0
 */function zx(e){let t=zz(e);return(e,r)=>a=>t(a).reduce(r,e)}/**
 * @since 2.5.0
 */function zE(e,t){let r=zz(e);return e=>a=>r(a).reduce((r,a)=>t.concat(r,e(a)),t.empty)}/**
 * @category folding
 * @since 2.11.0
 */let zA=e=>{let t=zz(e);return(e,r)=>a=>t(a).reduceRight((e,t)=>r(t,e),e)};/**
 * Insert a value into a set
 *
 * @since 2.5.0
 */function zS(e){let t=zP(e);return e=>r=>{if(t(e)(r))return r;{let t=new Set(r);return t.add(e),t}}}/**
 * Delete a value from a set
 *
 * @since 2.5.0
 */let zF=e=>t=>r=>zW(r=>!e.equals(t,r))(r),zT=e=>{let t=zP(e),r=zF(e),a=zS(e);return e=>n=>(t(e,n)?r:a)(e)(n)},zw=e=>zq(e)(tf);/**
 * @since 2.5.0
 */function zk(e,t){return r=>{let a=zP(e),n=zP(t),i=new Set,o=new Set;return r.forEach(e=>{switch(e._tag){case"Left":a(e.left,i)||i.add(e.left);break;case"Right":n(e.right,o)||o.add(e.right)}}),lN(i,o)}}/**
 * @since 2.5.0
 */function zq(e){let t=zP(e);return e=>r=>{let a=new Set;return r.forEach(r=>{let n=e(r);"Some"!==n._tag||t(n.value,a)||a.add(n.value)}),a}}// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.5.0
 */let z_=new Set,zK=e=>0===e.size,zj=e=>e.size,zL=e=>t=>{let r,a=t.values(),n=!1;for(;!n&&!(r=a.next()).done;)n=e(r.value);return n};function zN(e){return sR(zL(sR(e)))}function zC(e){let t=zP(e);return(r,a)=>{if(void 0===a){let t=zC(e);return e=>t(e,r)}return zN(e=>t(e,a))(r)}}function zP(e){return(t,r)=>{let a;if(void 0===r){let r=zP(e);return e=>r(t,e)}let n=r.values(),i=!1;for(;!i&&!(a=n.next()).done;)i=e.equals(t,a.value);return i}}/**
 * Get a sorted `ReadonlyArray` of the values contained in a `ReadonlySet`.
 *
 * @category conversions
 * @since 2.5.0
 */let zz=e=>t=>{let r=[];return t.forEach(e=>r.push(e)),r.sort(e.compare)},zB="ReadonlySet";/**
 * @category instances
 * @since 2.5.0
 */function zD(e){return{show:t=>{let r=[];return t.forEach(t=>{r.push(e.show(t))}),`new Set([${r.sort().join(", ")}])`}}}/**
 * @category instances
 * @since 2.5.0
 */function zV(e){let t=zC(e);return rb((e,r)=>t(e,r)&&t(r,e))}/**
 * @category instances
 * @since 2.11.0
 */let z$=e=>({concat:zy(e)}),zJ=e=>({concat:z$(e).concat,empty:z_}),zH=e=>({concat:zO(e)}),zZ=e=>({concat:zb(e)}),zY=zI;/**
 * @since 2.5.0
 */// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * @since 2.5.0
 */function zG(e){return e[0]}/**
 * @since 2.5.0
 */function zQ(e){return e[1]}/**
 * @since 2.5.0
 */let zX=e=>[zQ(e),e[0]];/**
 * @category instances
 * @since 2.5.0
 */function z0(e){return{URI:Bg,_E:void 0,map:z6,ap:(t,r)=>[t[0](r[0]),e.concat(zQ(t),zQ(r))]}}let z1=e=>t=>[t,e.empty];/**
 * @category instances
 * @since 2.5.0
 */function z2(e){return{URI:Bg,_E:void 0,map:z6,ap:z0(e).ap,of:z1(e)}}/**
 * @category instances
 * @since 2.5.0
 */function z3(e){return{URI:Bg,_E:void 0,map:z6,ap:z0(e).ap,chain:(t,r)=>{let[a,n]=r(t[0]);return[a,e.concat(zQ(t),n)]}}}/**
 * @category instances
 * @since 2.5.0
 */function z4(e){let t=z3(e);return{URI:Bg,_E:void 0,map:z6,ap:t.ap,chain:t.chain,of:z1(e)}}/**
 * @category instances
 * @since 2.5.0
 */function z5(e){let t=z3(e);return{URI:Bg,_E:void 0,map:z6,ap:t.ap,chain:t.chain,chainRec:(t,r)=>{let a=r(t),n=e.empty,i=a[0];for(;"Left"===i._tag;)n=e.concat(n,zQ(a)),i=(a=r(i.left))[0];return[i.right,e.concat(n,zQ(a))]}}}/* istanbul ignore next */let z7=(e,t)=>tE(e,Bp(t)),z6=(e,t)=>tE(e,Bo(t)),z8=(e,t,r)=>tE(e,Bi(t,r)),z9=(e,t)=>tE(e,Bl(t)),Be=(e,t)=>tE(e,Bc(t)),Bt=(e,t,r)=>tE(e,Bd(t,r)),Br=e=>{let t=Bh(e);return(e,r)=>tE(e,t(r))},Ba=(e,t,r)=>tE(e,Bs(t,r)),Bn=e=>{let t=Bm(e);return(e,r)=>tE(e,t(r))},Bi=(e,t)=>r=>[t(r[0]),e(zQ(r))],Bo=e=>t=>[e(t[0]),zQ(t)],Bl=e=>t=>[t[0],e(zQ(t))],Bp=e=>t=>[t[0],zQ(e)],Bc=e=>t=>[e(t),zQ(t)],Bu=zG,Bf=/*#__PURE__*/Bc(tf),Bd=(e,t)=>r=>t(e,r[0]),Bh=()=>e=>t=>e(t[0]),Bs=(e,t)=>r=>t(r[0],e),Bm=e=>t=>r=>e.map(t(r[0]),e=>[e,zQ(r)]),BI=e=>t=>e.map(t[0],e=>[e,zQ(t)]),Bg="ReadonlyTuple",BR={URI:Bg,map:z6},Bv=/*#__PURE__*/ri(BR),BW=Bo,BM=Bl,By={URI:Bg,bimap:z8,mapLeft:z9},BO={URI:Bg,compose:z7},BU={URI:Bg,map:z6,extend:Be,extract:Bu},Bb={URI:Bg,reduce:Bt,foldMap:Br,reduceRight:Ba},Bx={URI:Bg,map:z6,reduce:Bt,foldMap:Br,reduceRight:Ba,traverse:Bn,sequence:BI},BE={URI:Bg,compose:z7,map:z6,bimap:z8,mapLeft:z9,extract:Bu,extend:Be,reduce:Bt,foldMap:Br,reduceRight:Ba,traverse:Bn,sequence:BI};function BA(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},a=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),a.forEach(function(t){var a;a=r[t],t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a})}return e}// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * Calculate the number of key/value pairs in a `Record`.
 *
 * @example
 * import { size } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(size({ a: true, b: 2, c: "three" }), 3);
 *
 * @since 2.0.0
 */let BS=CD,BF=CV,BT=e=>t=>Object.keys(t).sort(e.compare),Bw=/*#__PURE__*/BT(Cx);function Bk(e){if("function"==typeof e)return Bk(Cx)(e);let t=BT(e);return e=>r=>{let a=[];for(let n of t(r))a.push(e(n,r[n]));return a}}/**
 * Get a sorted `Array` of the key/value pairs contained in a `Record`.
 * Sorted alphabetically by key.
 *
 * @example
 * import { toArray } from 'fp-ts/Record'
 *
 * const x = { c: 3, a: "foo", b: false };
 * assert.deepStrictEqual(toArray(x), [
 *   ["a", "foo"],
 *   ["b", false],
 *   ["c", 3],
 * ]);
 *
 * @category conversions
 * @since 2.0.0
 */let Bq=/*#__PURE__*/Bk(Cx)((e,t)=>[e,t]);function B_(e){return t=>{let r=Bq(t),a=r.length;return e.unfold(0,e=>e<a?tK([r[e],e+1]):t_)}}/**
 * Insert or replace a key/value pair in a `Record`.
 *
 * @example
 * import { upsertAt } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.10.0
 */let BK=CG,Bj=CQ;function BL(e){return t=>{if(!tJ.call(t,e))return t;let r=Object.assign({},t);return delete r[e],r}}/**
 * Replace a key/value pair in a `Record`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { updateAt } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.0.0
 */let BN=(e,t)=>BC(e,()=>t),BC=(e,t)=>r=>{if(!Bj(e,r))return t_;let a=Object.assign({},r);return a[e]=t(r[e]),tK(a)};function BP(e){let t=BL(e);return r=>{let a=BB(e,r);return tk(a)?t_:tK([a.value,t(r)])}}// TODO: remove non-curried overloading in v3
/**
 * Test whether one `Record` contains all of the keys and values
 * contained in another `Record`.
 *
 * @example
 * import { isSubrecord } from 'fp-ts/Record'
 * import { string } from 'fp-ts'
 *
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "bar", c: "baz" }),
 *   true
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", c: "baz" }),
 *   true
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "not-bar", c: "baz" }),
 *   false
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar" })({ a: "foo", b: "bar", c: "baz" }),
 *   false
 * );
 *
 * @since 2.0.0
 */let Bz=C3,BB=C4,BD=C7,BV=C6;function B$(...e){return 1===e.length?C8(e[0]):C8(Cx)(...e)}function BJ(e){return"compare"in e?C9(e):C9(Cx)(e)}function BH(...e){return 1===e.length?Pe(e[0]):Pe(Cx)(...e)}/**
 * Create a `Record` with one key/value pair.
 *
 * @example
 * import { singleton } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
 *
 * @since 2.0.0
 */let BZ=Pt;function BY(e){return Pr(e)}function BG(e){return Pa(e)}function BQ(e){return Pn(e)}/**
 * @category filtering
 * @since 2.6.5
 */let BX=e=>{let t=Pa(e);return r=>a=>e.map(tE(a,t(r)),Dh)},B0=e=>{let t=Pa(e);return r=>a=>e.map(tE(a,t(r)),Ds)},B1=Pl;function B2(e){return Pp(e)}/**
 * Maps a `Record` with an iterating function that takes key and value and
 * returns an `Option`, keeping only the `Some` values and discarding `None`s.
 *
 * @example
 * import { filterMapWithIndex } from "fp-ts/Record"
 * import { option } from "fp-ts"
 *
 * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);
 * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {
 *   b: "b2",
 *   c: "c3",
 * });
 *
 * @since 2.0.0
 */let B3=Pc;function B4(e){return Pu(e)}function B5(e,t){return Pf(e,t)}/**
 * Alias of [`toArray`](#toArray).
 *
 * @example
 * import { toEntries } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])
 *
 * @since 2.12.0
 * @category conversions
 */let B7=Bq,B6=e=>Pf(av(),hs)(e);function B8(e,t){return Pd(e,t)}/**
 * Test if every value in a `Record` satisfies the predicate.
 *
 * @example
 * import { every } from "fp-ts/Record"
 *
 * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
 * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
 *
 * @since 2.0.0
 */let B9=Pm,De=PI,Dt=Pg,Dr=e=>{let t=PR(e);return e=>r=>BF(r)?BA({},e):BF(e)?BA({},r):t(e)(r)},Da=e=>t=>r=>BF(r)||BF(t)?{}:Pv(e)(t)(r),Dn=e=>t=>BF(t)?BA({},e):BF(e)?BA({},t):PW(e)(t),Di=e=>t=>{let r=BT(e);return(e,a)=>{let n=r(e);if(0===n.length)return t.of({});let i=t.of({});for(let r of n)i=t.ap(t.map(i,e=>t=>(e[r]=t,e)),a(r,e[r]));return i}},Do=PC,Dl=PP,Dp=Pz,Dc=PB;function Du(...e){return 1===e.length?PD(e[0]):PD(Cx)(...e)}function Df(e){return"compare"in e?PV(e):PV(Cx)(e)}function Dd(...e){return 1===e.length?P$(e[0]):P$(Cx)(...e)}/**
 * Compact a `Record` of `Option`s discarding the `None` values and
 * keeping the `Some` values.
 *
 * @example
 * import { compact } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
 *   a: "foo",
 *   c: "bar",
 * });
 *
 * @category filtering
 * @since 2.0.0
 */let Dh=PJ,Ds=PH,Dm="Record";function DI(e){return"compare"in e?PY(e):PY(Cx)(e)}/**
 * Given an `Eq` for the base type, it produces an `Eq`
 * for a `Record` of that base type.
 *
 * @example
 * import { getEq } from "fp-ts/Record";
 * import { string } from "fp-ts";
 * import { Eq } from "fp-ts/Eq";
 *
 * const eq: Eq<Record<string, string>> = getEq(string.Eq);
 * assert.deepStrictEqual(eq.equals({ a: "foo" }, { b: "bar" }), false);
 * assert.deepStrictEqual(eq.equals({ a: "foo" }, { a: "foo" }), true);
 *
 * @category instances
 * @since 2.0.0
 */let Dg=PG,DR=PQ,Dv={URI:Dm,map:PM},DW=/*#__PURE__*/ri(Dv),DM={URI:Dm,map:PM,mapWithIndex:Py},Dy=e=>({URI:Dm,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e)}),DO=e=>({URI:Dm,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),reduceWithIndex:PF(e),foldMapWithIndex:PT(e),reduceRightWithIndex:Pw(e)}),DU={URI:Dm,compact:Dh,separate:Ds},Db={URI:Dm,map:PM,compact:Dh,separate:Ds,filter:Px,filterMap:PE,partition:PA,partitionMap:PS},Dx={URI:Dm,map:PM,mapWithIndex:Py,compact:Dh,separate:Ds,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,filterMapWithIndex:P_,filterWithIndex:PK,partitionMapWithIndex:Pk,partitionWithIndex:Pq},DE=e=>({URI:Dm,map:PM,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),traverse:Pj(e),sequence:PL(e)}),DA=e=>({URI:Dm,map:PM,mapWithIndex:Py,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),reduceWithIndex:PF(e),foldMapWithIndex:PT(e),reduceRightWithIndex:Pw(e),traverse:Pj(e),sequence:PL(e),traverseWithIndex:Di(e)}),DS=e=>{let t=DE(e);return{URI:Dm,map:PM,reduce:PO(e),foldMap:PU(e),reduceRight:Pb(e),traverse:t.traverse,sequence:t.sequence,compact:Dh,separate:Ds,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,wither:lY(t,DU),wilt:lZ(t,DU)}},DF=e=>{let t=Dr(e);return{concat:(e,r)=>t(r)(e)}},DT=e=>({concat:DF(e).concat,empty:{}}),Dw=e=>{let t=Da(e);return{concat:(e,r)=>t(r)(e)}},Dk=()=>({concat:(e,t)=>Dn(t)(e)}),Dq={URI:Dm,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx)},D_={URI:Dm,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx)},DK={URI:Dm,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:BQ},Dj={URI:Dm,map:PM,mapWithIndex:Py,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:BQ,traverseWithIndex:/*#__PURE__*/Di(Cx)},DL=/*#__PURE__*/lY(DK,DU),DN=/*#__PURE__*/lZ(DK,DU),DC={URI:Dm,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:BQ,compact:Dh,separate:Ds,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,wither:DL,wilt:DN},DP={},Dz=BK,DB=zd,DD={URI:Dm,map:PM,reduce:/*#__PURE__*/PO(Cx),foldMap:/*#__PURE__*/PU(Cx),reduceRight:/*#__PURE__*/Pb(Cx),traverse:/*#__PURE__*/Pj(Cx),sequence:BQ,compact:Dh,separate:Ds,filter:Px,filterMap:PE,partition:PA,partitionMap:PS,mapWithIndex:Py,reduceWithIndex:/*#__PURE__*/PF(Cx),foldMapWithIndex:/*#__PURE__*/PT(Cx),reduceRightWithIndex:/*#__PURE__*/Pw(Cx),filterMapWithIndex:P_,filterWithIndex:PK,partitionMapWithIndex:Pk,partitionWithIndex:Pq,traverseWithIndex:/*#__PURE__*/Di(Cx),wither:DL,wilt:DN},DV=e=>t=>tq(e(t)),D$=e=>t=>tL(e(t)),DJ=()=>e=>!0,DH=e=>t=>!e(t),DZ=e=>t=>r=>t(r)||e(r),DY=e=>t=>r=>t(r)&&e(r),DG=()=>e=>!1,DQ=e=>t=>r=>t(r)&&e(r),DX=(...e)=>({add:(t,r)=>e.map((e,a)=>e.add(t[a],r[a])),zero:e.map(e=>e.zero),mul:(t,r)=>e.map((e,a)=>e.mul(t[a],r[a])),one:e.map(e=>e.one),sub:(t,r)=>e.map((e,a)=>e.sub(t[a],r[a]))}),D0=e=>t=>e.sub(e.zero,t),D1=DX,D2=tc,D3=tp,D4=zD,D5=zV;/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @since 2.0.0
 */function D7(e){let t=Vb(e);return e=>r=>{let a=new Set;return r.forEach(r=>{let n=e(r);t(n,a)||a.add(n)}),a}}/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation.
 *
 * @since 2.0.0
 */function D6(e){let t=Vb(e);return e=>r=>{let a=new Set;return r.forEach(r=>{e(r).forEach(e=>{t(e,a)||a.add(e)})}),a}}function D8(e){return t=>{let r,a=t.values(),n=new Set;for(;!(r=a.next()).done;){let t=r.value;e(t)&&n.add(t)}return n}}function D9(e){return t=>{let r,a=t.values(),n=new Set,i=new Set;for(;!(r=a.next()).done;){let t=r.value;e(t)?n.add(t):i.add(t)}return lN(i,n)}}function Ve(e){let t=Vb(e);return(r,a)=>{if(void 0===a){let t=Ve(e);return e=>t(r,e)}if(VW(r))return a;if(VW(a))return r;let n=new Set(r);return a.forEach(e=>{t(e,n)||n.add(e)}),n}}function Vt(e){let t=Vb(e);return(r,a)=>{if(void 0===a){let t=Vt(e);return e=>t(e,r)}if(VW(r)||VW(a))return new Set;let n=new Set;return r.forEach(e=>{t(e,a)&&n.add(e)}),n}}/**
 * @since 2.0.0
 */function Vr(e,t){return r=>a=>{let n,i=a.values(),o=new Set,l=new Set,p=Vb(e),c=Vb(t);for(;!(n=i.next()).done;){let e=r(n.value);switch(e._tag){case"Left":p(e.left,o)||o.add(e.left);break;case"Right":c(e.right,l)||l.add(e.right)}}return lN(o,l)}}function Va(e){let t=Vb(e);return(r,a)=>{if(void 0===a){let t=Va(e);return e=>t(e,r)}return D8(e=>!t(e,a))(r)}}/**
 * @category instances
 * @since 2.11.0
 */let Vn=e=>({concat:Ve(e)}),Vi=e=>({concat:Vn(e).concat,empty:new Set}),Vo=e=>({concat:Vt(e)}),Vl=e=>({concat:Va(e)}),Vp=zx,Vc=zE,Vu=zA,Vf=e=>new Set([e]);/**
 * Insert a value into a set
 *
 * @since 2.0.0
 */function Vd(e){let t=Vb(e);return e=>r=>{if(t(e)(r))return r;{let t=new Set(r);return t.add(e),t}}}/**
 * Delete a value from a set
 *
 * @since 2.0.0
 */let Vh=e=>t=>r=>D8(r=>!e.equals(t,r))(r),Vs=e=>{let t=Vb(e),r=Vh(e),a=Vd(e);return e=>n=>(t(e,n)?r:a)(e)(n)},Vm=e=>t=>{let r=t.length,a=new Set,n=Vb(e);for(let e=0;e<r;e++){let r=t[e];n(r,a)||a.add(r)}return a},VI=e=>VR(e)(tf);/**
 * @since 2.0.0
 */function Vg(e,t){return r=>{let a=Vb(e),n=Vb(t),i=new Set,o=new Set;return r.forEach(e=>{switch(e._tag){case"Left":a(e.left,i)||i.add(e.left);break;case"Right":n(e.right,o)||o.add(e.right)}}),lN(i,o)}}/**
 * @since 2.0.0
 */function VR(e){let t=Vb(e);return e=>r=>{let a=new Set;return r.forEach(r=>{let n=e(r);"Some"!==n._tag||t(n.value,a)||a.add(n.value)}),a}}// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 */let Vv=new Set,VW=e=>0===e.size,VM=e=>e.size,Vy=zL,VO=zN,VU=zC,Vb=zP,Vx=e=>t=>{let r=[];return t.forEach(e=>r.push(e)),r.sort(e.compare)},VE=zC,VA=e=>({show:t=>{let r="{";for(let a in e)tJ.call(e,a)&&(r+=` ${a}: ${e[a].show(t[a])},`);return r.length>1&&(r=r.slice(0,-1)+" "),r+="}"}}),VS=(...e)=>({show:t=>`[${t.map((t,r)=>e[r].show(t)).join(", ")}]`}),VF=VS,VT=VA,Vw={show:e=>JSON.stringify(e)},Vk={show:e=>JSON.stringify(e)},Vq={show:e=>JSON.stringify(e)};/**
 * The state monad transformer. It can be used to add state to other monads.
 *
 * The `of` function leaves the state unchanged, while `chain` uses the final state of the first computation
 * as the initial state of the second.
 *
 * @since 2.0.0
 */function V_(e){return t=>r=>e.of([t,r])}function VK(e){return t=>r=>a=>e.map(r(a),([e,r])=>[t(e),r])}function Vj(e){return t=>r=>a=>e.chain(r(a),([r,a])=>e.map(t(a),([e,t])=>[r(e),t]))}function VL(e){let t=VN(e);return e=>r=>t(r,e)}/** @internal */function VN(e){return(t,r)=>a=>e.chain(t(a),([e,t])=>r(e)(t))}function VC(e){return t=>r=>e.of(t(r))}function VP(e){return t=>r=>e.map(t,e=>[e,r])}function Vz(e){return t=>r=>e.map(r(t),([e])=>e)}function VB(e){return t=>r=>e.map(r(t),zQ)}/** @deprecated *//* istanbul ignore next */function VD(e){let t=Vj(e),r=VK(e),a=VL(e),n=Vz(e),i=VB(e);return{map:(e,t)=>tE(e,r(t)),ap:(e,r)=>tE(e,t(r)),of:V_(e),chain:(e,t)=>tE(e,a(t)),get:()=>t=>e.of([t,t]),put:t=>()=>e.of([void 0,t]),modify:t=>r=>e.of([void 0,t(r)]),gets:t=>r=>e.of([t(r),r]),fromState:VC(e),fromM:VP(e),evalState:(e,t)=>tE(e,n(t)),execState:(e,t)=>tE(e,i(t))}}/**
 * @since 2.0.0
 */// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */let VV=e=>()=>jO(e),V$=/*#__PURE__*/V_(LA);/**
 * @category constructors
 * @since 2.0.0
 */function VJ(e){return V9(jb(e))}/**
 * @category constructors
 * @since 2.0.0
 */function VH(e){return V9(jx(e))}/**
 * @category constructors
 * @since 2.0.0
 */function VZ(e){return V9(jE(e))}/**
 * @category constructors
 * @since 2.0.0
 */function VY(e){return V9(jA(e))}/**
 * @category constructors
 * @since 2.0.0
 */function VG(e){return V9(jT(e))}/**
 * @category constructors
 * @since 2.0.0
 */function VQ(e){return V9(jw(e))}/**
 * @category constructors
 * @since 2.0.0
 */let VX=e=>tW(e,jU),V0=e=>t=>jO(e(t)[0]),V1=/*#__PURE__*/gV(e=>VV(e),V$),V2=VZ,V3=VG,V4=VJ,V5=/*#__PURE__*/VC(LA),V7=e=>V9(jy(e)),V6=e=>V9(jN(e)),V8=e=>V9(jC(e)),V9=/*#__PURE__*/VP(LU),$e=e=>t=>tW(t,vK(e)),$t=e=>t=>r=>e(r)(t)(r),$r=$t,$a=e=>(...t)=>V6(e(...t)),$n=e=>(...t)=>V7(e(...t)),$i=e=>(...t)=>V9(e(...t)),$o=e=>t=>$W(t,$i(e)),$l=$o,$p=(e,t)=>tE(e,$h(t)),$c=(e,t)=>tE(e,$I(t)),$u=(e,t)=>r=>tE(e(r),LI(()=>t()(r))),$f=(e,t,r)=>a=>tE(e(a),Ll(t,([e,t])=>[r(e),t])),$d=(e,t)=>r=>tE(e(r),Lc(t)),$h=/*#__PURE__*/VK(LU),$s=(e,t)=>r=>$f(r,e,t),$m=e=>t=>$d(t,e),$I=/*#__PURE__*/Vj(Lj),$g=$I,$R=V$,$v={fromEither:V1},$W=/*#__PURE__*/tw(2,VN(LL)),$M={flatMap:$W},$y=/*#__PURE__*/tw(2,(e,t)=>$W(e,e=>$n(t)(e))),$O=/*#__PURE__*/t0({fromIO:V3},$M),$U=/*#__PURE__*/t1({fromTask:V4},$M),$b=/*#__PURE__*/t2({fromReader:V2},$M),$x=/*#__PURE__*/tw(2,(e,t)=>$W(e,e=>$a(t)(e))),$E=/*#__PURE__*/tw(2,tX($v,$M)),$A=/*#__PURE__*/tQ($v,$M),$S=/*#__PURE__*/tw(2,(e,t)=>$W(e,e=>$i(t)(e))),$F=/*#__PURE__*/tw(2,(e,t)=>$W(e,$0(t))),$T=/*#__PURE__*/$W(tf),$w=$T,$k=e=>t=>r=>tE(t(r),Lg(()=>e()(r))),$q=$k,$_=VV,$K="StateReaderTaskEither",$j={URI:$K,map:$p},$L=tw(2,rc($j)),$N=ru($j),$C=/*#__PURE__*/ri($j),$P={URI:$K,of:$R},$z={URI:$K,map:$p,ap:$c},$B=/*#__PURE__*/t4($z),$D=$B,$V=/*#__PURE__*/t5($z),$$=$V,$J={URI:$K,map:$p,ap:$c,of:$R},$H={URI:$K,map:$p,ap:$c,chain:$W},$Z={URI:$K,fromState:V5},$Y=/*#__PURE__*/Mf($Z),$G=/*#__PURE__*/Md($Z),$Q=/*#__PURE__*/Mh($Z),$X=/*#__PURE__*/Ms($Z),$0=/*#__PURE__*/Mm($Z),$1=/*#__PURE__*/MI($Z,$H),$2={URI:$K,map:$p,ap:$c,of:$R,chain:$W},$3={URI:$K,map:$p,ap:$c,of:$R,chain:$W,fromIO:V3},$4={URI:$K,map:$p,ap:$c,of:$R,chain:$W,fromIO:V3,fromTask:V4},$5={URI:$K,map:$p,ap:$c,of:$R,chain:$W,throwError:$_},$7={URI:$K,fromEither:V1},$6={URI:$K,fromIO:V3},$8={URI:$K,fromIO:V3,fromTask:V4},$9={URI:$K,fromReader:V2},Je=/*#__PURE__*/tw(2,rs($H)),Jt=/*#__PURE__*/tw(2,rU($7,$H)),Jr=/*#__PURE__*/tw(2,vk($6,$H)),Ja=/*#__PURE__*/tw(2,MW($8,$H)),Jn=/*#__PURE__*/tw(2,W_($9,$H)),Ji={URI:$K,bimap:$f,mapLeft:$d},Jo={URI:$K,map:$p,alt:$u},Jl=/*#__PURE__*/WF($9),Jp=/*#__PURE__*/WT($9),Jc=/*#__PURE__*/Ww($9),Ju=$b,Jf=$b,Jd=Jn,Jh=Jn,Js=/*#__PURE__*/rI($7),Jm=/*#__PURE__*/rR($7),JI=/*#__PURE__*/rv($7,$H),Jg=JI,JR=$E,Jv=$E,JW=Jt,JM=Jt,Jy=/*#__PURE__*/rg($7),JO=/*#__PURE__*/rO($7,$H),JU=JO,Jb=/*#__PURE__*/rW($7),Jx=/*#__PURE__*/vF($6),JE=$O,JA=Jr,JS=$y,JF=$y,JT=$x,Jw=$x,Jk=/*#__PURE__*/Mg($8),Jq=$U,J_=Ja,JK=/*#__PURE__*/Vz(LU),Jj=/*#__PURE__*/VB(LU),JL=/*#__PURE__*/ro($j),JN=/*#__PURE__*/rl($j),JC=/*#__PURE__*/rm($H),JP=JC,Jz=/*#__PURE__*/t7($z),JB=Jz,JD=e=>t=>r=>a=>()=>tD(t).reduce((t,r,n)=>t.then(i=>tj(i)?t:e(n+1,r)(i.right[1])(a)().then(e=>{if(tj(e))return e;let[t,r]=e.right;return i.right[0].push(t),i.right[1]=r,i})),e(0,tB(t))(r)(a)().then(gp(([e,t])=>[[e],t]))),JV=e=>{let t=JD(e);return e=>tz(e)?t(e):$R(tV)},J$=JV,JJ=e=>JV((t,r)=>e(r)),JH=/*#__PURE__*/JJ(tf),JZ=$W,JY=$W,JG=Je,JQ=Je,JX={URI:$K,map:$p,of:$R,ap:$c,chain:$W,bimap:$f,mapLeft:$d,alt:$u,fromIO:V3,fromTask:V4,throwError:$_},J0={URI:$K,map:$p,of:$R,ap:$c,chain:$W,bimap:$f,mapLeft:$d,alt:$u,fromIO:V3,fromTask:V4,throwError:$_},J1=(e,t)=>tE(e(t),Li(([e])=>e)),J2=(e,t)=>tE(e(t),Li(([e,t])=>t));/**
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 *//* istanbul ignore next */function J3(e,t,r){return e(t)(r)()}/**
 * @since 2.0.0
 *//**
 * Reposition the focus at the specified position
 *
 * @since 2.0.0
 */function J4(e){return t=>({peek:t.peek,pos:e})}/**
 * Reposition the focus at the specified position, which depends on the current position
 *
 * @since 2.0.0
 */function J5(e){return t=>({peek:t.peek,pos:e(t.pos)})}/**
 * Extract a value from a position which depends on the current position
 *
 * @since 2.0.0
 */function J7(e){return t=>t.peek(e(t.pos))}function J6(e){return t=>r=>e.map(t(r.pos),e=>r.peek(e))}/* istanbul ignore next */let J8=(e,t)=>tE(e,Hr(t)),J9=e=>t=>({peek:r=>e({peek:t.peek,pos:r}),pos:t.pos}),He=e=>e.peek(e.pos),Ht=/*#__PURE__*/J9(tf),Hr=e=>t=>({peek:r=>e(t.peek(r)),pos:t.pos}),Ha="Store",Hn={URI:Ha,map:J8},Hi=/*#__PURE__*/ri(Hn),Ho={URI:Ha,map:J8,extend:(e,t)=>tE(e,J9(t)),extract:He},Hl=Ho;/**
 * The `Strong` class extends `Profunctor` with combinators for working with product types.
 *
 * `first` and `second` lift values in a `Profunctor` to act on the first and second components of a tuple,
 * respectively.
 *
 * Another way to think about Strong is to piggyback on the intuition of
 * inputs and outputs.  Rewriting the type signature in this light then yields:
 *
 * ```purescript
 * first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 * second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 * ```
 *
 * If we specialize the profunctor p to the function arrow, we get the following type
 * signatures, which may look a bit more familiar:
 *
 * ```purescript
 * first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 * second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 * ```
 *
 * So, when the `profunctor` is `Function` application, `first` essentially applies your function
 * to the first element of a tuple, and `second` applies it to the second element (same as `map` would do).
 *
 * Adapted from https://github.com/purescript/purescript-profunctor/blob/master/src/Data/Profunctor/Strong.purs
 *
 * @since 2.0.0
 */function Hp(e,t){return(r,a)=>t.compose(e.second(a),e.first(r))}function Hc(e,t){let r=Hp(e,t);return(a,n)=>t.compose(r(a,n),e.promap(t.id(),tf,e=>[e,e]))}function Hu(e){return Hp(e,e)}function Hf(e){return Hc(e,e)}/**
 * @since 2.10.0
 */// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * Return a semigroup which works like `Object.assign`.
 *
 * @example
 * import { getAssignSemigroup } from 'fp-ts/struct'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age: number
 * }
 *
 * const S = getAssignSemigroup<Person>()
 * assert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })
 *
 * @category instances
 * @since 2.10.0
 */let Hd=()=>({concat:(e,t)=>Object.assign({},e,t)}),Hh=e=>t=>{let r={};for(let a in t)tJ.call(t,a)&&(r[a]=e[a](t[a]));return r};/**
 * @since 2.10.0
 */function Hs(e,t,r,a,n,i,o){try{var l=e[i](o),p=l.value}catch(e){r(e);return}l.done?t(p):Promise.resolve(p).then(a,n)}// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.10.0
 */let Hm=/*#__PURE__*/UV(w0),HI=/*#__PURE__*/UX(w0),Hg=wV,HR=/*#__PURE__*/U0(w0),Hv=e=>HW(wL(e)),HW=/*#__PURE__*/UJ(wY),HM=/*#__PURE__*/wB(mU),Hy=/*#__PURE__*/U1(wY),HO=Hy,HU=/*#__PURE__*/U2(w6),Hb=HU,Hx=HU,HE=Hx,HA=/*#__PURE__*/U3(w8),HS=HA,HF=/*#__PURE__*/UH(w0),HT=e=>()=>{var t;return(t=function*(){try{return yield e().then(tK)}catch(e){return t_}},function(){var e=this,r=arguments;return new Promise(function(a,n){var i=t.apply(e,r);function o(e){Hs(i,a,n,o,l,"next",e)}function l(e){Hs(i,a,n,o,l,"throw",e)}o(void 0)})})()},Hw=e=>(...t)=>HT(()=>e(...t)),Hk=/*#__PURE__*/UZ(w0),Hq=/*#__PURE__*/UY(w8),H_=/*#__PURE__*/UG(w0),HK=/*#__PURE__*/UQ(w8),Hj=/*#__PURE__*/U4(wY),HL=/*#__PURE__*/U5(w1),HN=Hm,HC=/*#__PURE__*/tw(2,U6(w8)),HP={flatMap:HC},Hz=/*#__PURE__*/t0({fromIO:Hv},HP),HB=/*#__PURE__*/t1({fromTask:HW},HP),HD=/*#__PURE__*/HC(tf),HV=/*#__PURE__*/U8(w8),H$=HV,HJ=/*#__PURE__*/U$(w0),HH=/*#__PURE__*/HJ(),HZ=/*#__PURE__*/Ip(wY,mp),HY=/*#__PURE__*/Ic(wY,mp,sD),HG=/*#__PURE__*/vf(wY,mh),HQ=/*#__PURE__*/vd(wY,mh),HX=/*#__PURE__*/vh(wY,mh),H0=/*#__PURE__*/vs(wY,mh),H1=(e,t)=>tE(e,Hj(t)),H2=(e,t)=>tE(e,HL(t)),H3=(e,t)=>tE(e,HV(t)),H4="TaskOption",H5={URI:H4,map:H1},H7=tw(2,rc(H5)),H6=ru(H5),H8=/*#__PURE__*/ri(H5),H9={URI:H4,of:HN},Ze={URI:H4,map:H1,ap:H2},Zt=/*#__PURE__*/t4(Ze),Zr=/*#__PURE__*/t5(Ze),Za={URI:H4,map:H1,ap:H2,of:HN},Zn=(e,t)=>HC(e,e=>tE(t,Hj(e))),Zi={URI:H4,map:H1,ap:Zn},Zo={URI:H4,map:H1,ap:Zn,of:HN},Zl={URI:H4,map:H1,ap:H2,chain:HC},Zp={URI:H4,fromEither:HR},Zc={URI:H4,fromIO:Hv},Zu={URI:H4,fromIO:Hv,fromTask:HW},Zf=/*#__PURE__*/tw(2,rs(Zl)),Zd=/*#__PURE__*/tw(2,rU(Zp,Zl)),Zh=/*#__PURE__*/tw(2,vk(Zc,Zl)),Zs=/*#__PURE__*/tw(2,MW(Zu,Zl)),Zm={URI:H4,map:H1,alt:H3},ZI={URI:H4,zero:HJ},Zg=/*#__PURE__*/lQ(ZI,H9),ZR={URI:H4,map:H1,ap:H2,of:HN,alt:H3,zero:HJ},Zv={URI:H4,map:H1,ap:H2,of:HN,chain:HC},ZW={URI:H4,map:H1,ap:H2,of:HN,chain:HC,fromIO:Hv},ZM={URI:H4,map:H1,ap:H2,of:HN,chain:HC,fromIO:Hv,fromTask:HW},Zy={URI:H4,compact:HZ,separate:HY},ZO={URI:H4,map:H1,compact:HZ,separate:HY,filter:(e,t)=>tE(e,HG(t)),filterMap:(e,t)=>tE(e,HQ(t)),partition:(e,t)=>tE(e,HX(t)),partitionMap:(e,t)=>tE(e,H0(t))},ZU=/*#__PURE__*/vF(Zc),Zb=Hz,Zx=Zh,ZE=/*#__PURE__*/rW(Zp),ZA=/*#__PURE__*/rM(Zp,Zl),ZS=Zd,ZF=/*#__PURE__*/Mg(Zu),ZT=HB,Zw=Zs,Zk=/*#__PURE__*/HN(t$),Zq=/*#__PURE__*/ro(H5),Z_=/*#__PURE__*/rl(H5),ZK=/*#__PURE__*/rm(Zl),Zj=/*#__PURE__*/t7(Ze),ZL=/*#__PURE__*/HN(tV),ZN=e=>tW(kg(e),wB(m4(tS))),ZC=e=>{let t=ZN(e);return e=>tz(e)?t(e):ZL},ZP=e=>t=>()=>tD(t).reduce((t,r,a)=>t.then(n=>tk(n)?t:e(a+1,r)().then(e=>tk(e)?e:(n.value.push(e.value),n))),e(0,tB(t))().then(sB(tP))),Zz=e=>{let t=ZP(e);return e=>tz(e)?t(e):ZL},ZB=ZC,ZD=e=>ZC((t,r)=>e(r)),ZV=/*#__PURE__*/ZD(tf),Z$=Zz,ZJ=e=>Zz((t,r)=>e(r)),ZH=/*#__PURE__*/ZJ(tf),ZZ=HC,ZY=Zf,ZG=e=>"Left"===e._tag,ZQ=e=>"Right"===e._tag;/**
 * Returns `true` if the these is an instance of `Both`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */function ZX(e){return"Both"===e._tag}// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */function Z0(e){return{_tag:"Left",left:e}}/**
 * @category constructors
 * @since 2.0.0
 */function Z1(e){return{_tag:"Right",right:e}}/**
 * @category constructors
 * @since 2.0.0
 */function Z2(e,t){return{_tag:"Both",left:e,right:t}}/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.10.0
 */let Z3=(e,t,r)=>a=>{switch(a._tag){case"Left":return e(a.left);case"Right":return t(a.right);case"Both":return r(a.left,a.right)}},Z4=Z3,Z5=Z3,Z7=Z5,Z6=Z5(Z1,Z0,(e,t)=>Z2(t,e));/**
 * @category instances
 * @since 2.0.0
 */function Z8(e,t){return{show:Z5(t=>`left(${e.show(t)})`,e=>`right(${t.show(e)})`,(r,a)=>`both(${e.show(r)}, ${t.show(a)})`)}}/**
 * @category instances
 * @since 2.0.0
 */function Z9(e,t){return rb((r,a)=>ZG(r)?ZG(a)&&e.equals(r.left,a.left):ZQ(r)?ZQ(a)&&t.equals(r.right,a.right):ZX(a)&&e.equals(r.left,a.left)&&t.equals(r.right,a.right))}/**
 * @category instances
 * @since 2.0.0
 */function Ye(e,t){return{concat:(r,a)=>ZG(r)?ZG(a)?Z0(e.concat(r.left,a.left)):ZQ(a)?Z2(r.left,a.right):Z2(e.concat(r.left,a.left),a.right):ZQ(r)?ZG(a)?Z2(a.left,r.right):ZQ(a)?Z1(t.concat(r.right,a.right)):Z2(a.left,t.concat(r.right,a.right)):ZG(a)?Z2(e.concat(r.left,a.left),r.right):ZQ(a)?Z2(r.left,t.concat(r.right,a.right)):Z2(e.concat(r.left,a.left),t.concat(r.right,a.right))}}/**
 * @category instances
 * @since 2.10.0
 */let Yt=e=>({URI:YA,_E:void 0,map:Yd,ap:(t,r)=>ZG(t)?ZG(r)?Z0(e.concat(t.left,r.left)):ZQ(r)?Z0(t.left):Z0(e.concat(t.left,r.left)):ZQ(t)?ZG(r)?Z0(r.left):ZQ(r)?Z1(t.right(r.right)):Z2(r.left,t.right(r.right)):ZG(r)?Z0(e.concat(t.left,r.left)):ZQ(r)?Z2(t.left,t.right(r.right)):Z2(e.concat(t.left,r.left),t.right(r.right))});/**
 * @category instances
 * @since 2.7.0
 */function Yr(e){return{URI:YA,_E:void 0,map:Yd,ap:Yt(e).ap,of:YE}}/**
 * @category instances
 * @since 2.10.0
 */function Ya(e){return{URI:YA,_E:void 0,map:Yd,ap:Yt(e).ap,chain:(t,r)=>{if(ZG(t))return t;if(ZQ(t))return r(t.right);let a=r(t.right);return ZG(a)?Z0(e.concat(t.left,a.left)):ZQ(a)?Z2(t.left,a.right):Z2(e.concat(t.left,a.left),a.right)}}}/**
 * @category instances
 * @since 2.0.0
 */function Yn(e){let t=Ya(e);return{URI:YA,_E:void 0,map:Yd,of:YE,ap:t.ap,chain:t.chain,throwError:Z0}}/**
 * Returns an `E` value if possible
 *
 * @example
 * import { getLeft, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
 * assert.deepStrictEqual(getLeft(right(1)), none)
 * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))
 *
 * @category conversions
 * @since 2.0.0
 */function Yi(e){return ZG(e)?tK(e.left):ZQ(e)?t_:tK(e.left)}/**
 * Returns an `A` value if possible
 *
 * @example
 * import { getRight, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRight(left('a')), none)
 * assert.deepStrictEqual(getRight(right(1)), some(1))
 * assert.deepStrictEqual(getRight(both('a', 1)), some(1))
 *
 * @category conversions
 * @since 2.0.0
 */function Yo(e){return ZG(e)?t_:(ZQ(e),tK(e.right))}// TODO: make lazy in v3
/**
 * @example
 * import { leftOrBoth, left, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))
 * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */function Yl(e){return t=>tk(t)?Z0(e):Z2(e,t.value)}// TODO: make lazy in v3
/**
 * @example
 * import { rightOrBoth, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))
 * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */function Yp(e){return t=>tk(t)?Z1(e):Z2(t.value,e)}/**
 * Returns the `E` value if and only if the value is constructed with `Left`
 *
 * @example
 * import { getLeftOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))
 * assert.deepStrictEqual(getLeftOnly(right(1)), none)
 * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)
 *
 * @category conversions
 * @since 2.0.0
 */function Yc(e){return ZG(e)?tK(e.left):t_}/**
 * Returns the `A` value if and only if the value is constructed with `Right`
 *
 * @example
 * import { getRightOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRightOnly(left('a')), none)
 * assert.deepStrictEqual(getRightOnly(right(1)), some(1))
 * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)
 *
 * @category conversions
 * @since 2.0.0
 */function Yu(e){return ZQ(e)?tK(e.right):t_}/**
 * Takes a pair of `Option`s and attempts to create a `These` from them
 *
 * @example
 * import { fromOptions, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(fromOptions(none, none), none)
 * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))
 * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))
 * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))
 *
 * @category conversions
 * @since 2.0.0
 */let Yf=(e,t)=>tk(e)?tk(t)?t_:tK(Z1(t.value)):tk(t)?tK(Z0(e.value)):tK(Z2(e.value,t.value)),Yd=(e,t)=>tE(e,YM(t)),Yh=(e,t,r)=>tE(e,Yv(t,r)),Ys=(e,t)=>tE(e,YW(t)),Ym=(e,t,r)=>tE(e,Yy(t,r)),YI=e=>{let t=YO(e);return(e,r)=>tE(e,t(r))},Yg=(e,t,r)=>tE(e,YU(t,r)),YR=e=>{let t=Yb(e);return(e,r)=>tE(e,t(r))},Yv=(e,t)=>r=>ZG(r)?Z0(e(r.left)):ZQ(r)?Z1(t(r.right)):Z2(e(r.left),t(r.right)),YW=e=>t=>ZG(t)?Z0(e(t.left)):ZX(t)?Z2(e(t.left),t.right):t,YM=e=>t=>ZG(t)?t:ZQ(t)?Z1(e(t.right)):Z2(t.left,e(t.right)),Yy=(e,t)=>r=>ZG(r)?e:t(e,r.right),YO=e=>t=>r=>ZG(r)?e.empty:t(r.right),YU=(e,t)=>r=>ZG(r)?e:t(r.right,e),Yb=e=>t=>r=>ZG(r)?e.of(r):ZQ(r)?e.map(t(r.right),Z1):e.map(t(r.right),e=>Z2(r.left,e)),Yx=e=>t=>ZG(t)?e.of(t):ZQ(t)?e.map(t.right,Z1):e.map(t.right,e=>Z2(t.left,e)),YE=Z1,YA="These",YS={URI:YA,map:Yd},YF=/*#__PURE__*/ri(YS),YT={URI:YA,of:YE},Yw={URI:YA,bimap:Yh,mapLeft:Ys},Yk={URI:YA,fromThese:tf},Yq={URI:YA,reduce:Ym,foldMap:YI,reduceRight:Yg},Y_={URI:YA,map:Yd,reduce:Ym,foldMap:YI,reduceRight:Yg,traverse:YR,sequence:Yx},YK={URI:YA,fromEither:tf},Yj=/*#__PURE__*/rg(YK),YL=/*#__PURE__*/rI(YK),YN=/*#__PURE__*/rR(YK),YC=e=>t=>r=>!ZG(r)&&e.equals(t,r.right),YP=e=>t=>!ZG(t)&&e(t.right),Yz=(e,t)=>r=>ZG(r)?[r.left,t()]:ZQ(r)?[e(),r.right]:[r.left,r.right],YB=(e,t)=>Yz(()=>e,()=>t),YD=/*#__PURE__*/YE(tV),YV=e=>t=>r=>{let a=t_,n=t(0,tB(r));if(ZG(n))return n;ZX(n)&&(a=tK(n.left));let i=[n.right];for(let n=1;n<r.length;n++){let o=t(n,r[n]);if(ZG(o))return o;ZX(o)&&(a=tk(a)?tK(o.left):tK(e.concat(a.value,o.left))),i.push(o.right)}return tk(a)?Z1(i):Z2(a.value,i)},Y$=e=>t=>{let r=YV(e)(t);return e=>tz(e)?r(e):YD},YJ={URI:YA,map:Yd,bimap:Yh,mapLeft:Ys,reduce:Ym,foldMap:YI,reduceRight:Yg,traverse:YR,sequence:Yx};/**
 * @since 2.4.0
 */function YH(e){return tW(Z1,e.of)}function YZ(e){return tW(Z0,e.of)}function YY(e){return tW(Z2,e.of)}function YG(e){return t=>e.map(t,Z1)}function YQ(e){return t=>e.map(t,Z0)}function YX(e){return rn(e,YS)}function Y0(e,t){return t3(e,Yt(t))}function Y1(e,t){let r=YZ(e);return a=>n=>e.chain(n,Z5(r,a,(r,n)=>e.map(a(n),Z5(e=>Z0(t.concat(r,e)),e=>Z2(r,e),(e,a)=>Z2(t.concat(r,e),a)))))}function Y2(e){return(t,r)=>a=>e.map(a,Yv(t,r))}function Y3(e){return t=>r=>e.map(r,YW(t))}function Y4(e){return(t,r,a)=>n=>e.map(n,Z5(t,r,a))}function Y5(e){return(t,r,a)=>n=>e.chain(n,Z5(t,r,a))}function Y7(e){return t=>e.map(t,Z6)}function Y6(e){return(t,r)=>a=>e.map(a,Yz(t,r))}/** @deprecated *//* istanbul ignore next */function Y8(e){let t=YX(e),r=Y2(e),a=Y3(e),n=Y5(e),i=Y6(e),o=YH(e),l=(e,r)=>tE(e,t(r));return{map:l,bimap:(e,t,a)=>tE(e,r(t,a)),mapLeft:(e,t)=>tE(e,a(t)),fold:(e,t,r,a)=>tE(e,n(t,r,a)),swap:Y7(e),rightM:YG(e),leftM:YQ(e),left:YZ(e),right:YH(e),both:YY(e),toTuple:(e,t,r)=>tE(e,i(()=>t,()=>r)),getMonad:t=>{let r=Y0(e,t),a=Y1(e,t);return{_E:void 0,map:l,of:o,ap:(e,t)=>tE(e,r(t)),chain:(e,t)=>tE(e,a(t))}}}}/**
 * @since 2.4.0
 *//**
 * @category constructors
 * @since 2.4.0
 */let Y9=/*#__PURE__*/YZ(w0),Ge=/*#__PURE__*/YH(w0),Gt=/*#__PURE__*/YY(w0),Gr=/*#__PURE__*/YG(wY),Ga=/*#__PURE__*/YQ(wY),Gn=/*#__PURE__*/tW(wL,Gr),Gi=/*#__PURE__*/tW(wL,Ga),Go=wV,Gl=wV,Gp=Gn,Gc=wL,Gu=Gr,Gf=/*#__PURE__*/Y4(wY),Gd=Gf,Gh=/*#__PURE__*/Y5(w8),Gs=Gh,Gm=Gs,GI=Gm,Gg=/*#__PURE__*/Y7(wY),GR=(e,t)=>tE(e,GM(t)),Gv=(e,t,r)=>tE(e,Gy(t,r)),GW=(e,t)=>tE(e,GO(t)),GM=/*#__PURE__*/YX(wY),Gy=/*#__PURE__*/Y2(wY),GO=/*#__PURE__*/Y3(wY),GU=Ge,Gb="TaskThese",Gx=(e,t)=>{let r=Y0(e,t);return{URI:Gb,_E:void 0,map:GR,ap:(e,t)=>tE(e,r(t))}};/**
 * @category instances
 * @since 2.7.0
 */function GE(e,t){let{ap:r}=Gx(e,t);return{URI:Gb,_E:void 0,map:GR,ap:r,of:GU}}/**
 * @category instances
 * @since 2.10.0
 */function GA(e){let t=Gx(w4,e),r=Y1(w8,e);return{URI:Gb,_E:void 0,map:GR,ap:t.ap,chain:(e,t)=>tE(e,r(t))}}/**
 * @category instances
 * @since 2.4.0
 */function GS(e){let t=GE(w4,e),r=GA(e);return{URI:Gb,_E:void 0,map:GR,ap:t.ap,of:GU,chain:r.chain,fromIO:Gp,fromTask:Gu}}/**
 * @category instances
 * @since 2.10.0
 */let GF={URI:Gb,map:GR},GT=/*#__PURE__*/ri(GF),Gw={URI:Gb,of:GU},Gk={URI:Gb,bimap:Gv,mapLeft:GW},Gq={URI:Gb,fromEither:Go},G_=/*#__PURE__*/rI(Gq),GK=/*#__PURE__*/rR(Gq),Gj=/*#__PURE__*/rg(Gq),GL={URI:Gb,fromThese:Gl},GN=/*#__PURE__*/MM(GL),GC={URI:Gb,fromIO:Gp},GP=/*#__PURE__*/vF(GC),Gz={URI:Gb,fromIO:Gp,fromTask:Gu},GB=/*#__PURE__*/Mg(Gz),GD=/*#__PURE__*/Y6(wY),GV=/*#__PURE__*/GU(tV),G$=e=>{let t=YV(e);return e=>tW(kg(e),wB(t(tS)))},GJ=e=>t=>{let r=G$(e)(t);return e=>tz(e)?r(e):GV},GH=e=>t=>r=>()=>tD(r).reduce((r,a,n)=>r.then(i=>ZG(i)?r:t(n+1,a)().then(t=>{if(ZG(t))return t;if(ZX(t)){let r=i.right;return r.push(t.right),ZX(i)?Z2(e.concat(i.left,t.left),r):Z2(t.left,r)}return i.right.push(t.right),i})),t(0,tB(r))().then(YM(tP))),GZ=e=>t=>{let r=GH(e)(t);return e=>tz(e)?r(e):GV},GY={URI:Gb,map:GR},GG={URI:Gb,bimap:Gv,mapLeft:GW},GQ=(e,t)=>GD(()=>e,()=>t),GX={URI:Gb,map:GR,bimap:Gv,mapLeft:GW},G0=(e,t)=>t6(w5)(Ye(e,t));/**
 * @since 2.0.0
 */// TODO: curry in v3
/**
 * Extracts a value at a relative position which depends on the current value.
 *
 * @since 2.0.0
 */function G1(e,t){return r=>r(t(r(e.empty)))}/**
 * Get the current position
 *
 * @since 2.0.0
 */function G2(e){return t=>[e(t),t]}/**
 * Get a value which depends on the current position
 *
 * @since 2.0.0
 */function G3(e){return t=>r=>[t(r),e(r)]}/**
 * Apply a function to the current position
 *
 * @since 2.0.0
 */function G4(e){return t=>r=>t(e(r))}/**
 * @category instances
 * @since 2.0.0
 */function G5(e){return{URI:G8,_E:void 0,map:G7,extend:function(t,r){return a=>r(r=>t(e.concat(a,r)))},extract:function(t){return t(e.empty)}}}/* istanbul ignore next */let G7=(e,t)=>tE(e,G6(t)),G6=e=>t=>r=>e(t(r)),G8="Traced",G9={URI:G8,map:G7},Qe=/*#__PURE__*/ri(G9),Qt=G9;/**
 * `Traversable` represents data structures which can be _traversed_ accumulating results and effects in some
 * `Applicative` functor.
 *
 * - `traverse` runs an action for every element in a data structure, and accumulates the results.
 * - `sequence` runs the actions _contained_ in a data structure, and accumulates the results.
 *
 * The `traverse` and `sequence` functions should be compatible in the following sense:
 *
 * - `traverse(A)(xs, f) <-> sequence(A)(A.map(xs, f))`
 * - `sequence(A)(xs) <-> traverse(A)(xs, identity)`
 *
 * where `A` is an `Applicative` instance
 *
 * `Traversable` instances should also be compatible with the corresponding `Foldable` instances, in the following sense:
 *
 * ```ts
 * import { getApplicative, make } from 'fp-ts/Const'
 *
 * const A = getApplicative(M)
 *
 * foldMap(M)(xs, f) = traverse(A)(xs, a => make(f(a)))
 * ```
 *
 * where `M` is a `Monoid` instance
 *
 * @since 2.0.0
 */function Qr(e,t){return r=>{let a=e.traverse(r),n=t.traverse(r);return e=>t=>a(t,t=>n(t,e))}}function Qa(e,t){return r=>{let a=e.sequence(r),n=t.sequence(r);return t=>a(e.map(t,n))}}/** @deprecated */function Qn(e,t){let r=rp(e,t).map,a=vb(e,t),n=Qr(e,t),i=Qa(e,t);return{map:r,reduce:a.reduce,foldMap:a.foldMap,reduceRight:a.reduceRight,traverse:e=>{let t=n(e);return(e,r)=>tE(e,t(r))},sequence:e=>{let t=i(e);return e=>tE(e,t)}}}/**
 * A `Traversable` with an additional index.
 * A `TraversableWithIndex` instance must be compatible with its `Traversable` instance
 *
 * ```ts
 * traverse(F)(ta, f) = traverseWithIndex(F)(ta, (_, a) => f(a))
 * ```
 *
 * with its `FoldableWithIndex` instance
 *
 * ```ts
 * foldMapWithIndex(M)(ta, f) = traverseWithIndex(getApplicative(M))(ta, (i, a) => new Const(f(i, a))).value
 * ```
 *
 * and with its `FunctorWithIndex` instance
 *
 * ```purescript
 * mapWithIndex(ta, f) = traverseWithIndex(identity)(ta, (i, a) => new Identity(f(i, a))).value
 * ```
 *
 * @since 2.0.0
 *//**
 * @since 2.6.3
 *//**
 * Multi-way trees (aka rose trees) and forests, where a forest is
 *
 * ```ts
 * type Forest<A> = Array<Tree<A>>
 * ```
 *
 * @since 2.0.0
 *//**
 * @category constructors
 * @since 2.0.0
 */function Qi(e,t=[]){return{value:e,forest:t}}/**
 * @category instances
 * @since 2.0.0
 */function Qo(e){let t=r=>uG(r.forest)?`make(${e.show(r.value)})`:`make(${e.show(r.value)}, [${r.forest.map(t).join(", ")}])`;return{show:t}}/**
 * @category instances
 * @since 2.0.0
 */function Ql(e){let t,r=rb((r,a)=>e.equals(r.value,a.value)&&t.equals(r.forest,a.forest));return t=dQ(r),r}let Qp=(e,t)=>{let r,a="",n=t.length;for(let i=0;i<n;i++){r=t[i];let o=i===n-1;a+=e+(o?"":"")+" "+r.value,a+=Qp(e+(n>1&&!o?"  ":"   "),r.forest)}return a};/**
 * Neat 2-dimensional drawing of a forest
 *
 * @since 2.0.0
 */function Qc(e){return Qp("\n",e)}/**
 * Neat 2-dimensional drawing of a tree
 *
 * @example
 * import { make, drawTree } from 'fp-ts/Tree'
 *
 * const fa = make('a', [
 *   make('b'),
 *   make('c'),
 *   make('d', [make('e'), make('f')])
 * ])
 *
 * assert.strictEqual(drawTree(fa), `a
 *  b
 *  c
 *  d
 *     e
 *     f`)
 *
 *
 * @since 2.0.0
 */function Qu(e){return e.value+Qc(e.forest)}/**
 * Build a (possibly infinite) tree from a seed value in breadth-first order.
 *
 * @category constructors
 * @since 2.0.0
 */function Qf(e,t){let[r,a]=t(e);return{value:r,forest:Qd(a,t)}}/**
 * Build a (possibly infinite) forest from a list of seed values in breadth-first order.
 *
 * @category constructors
 * @since 2.0.0
 */function Qd(e,t){return e.map(e=>Qf(e,t))}function Qh(e){let t=Qs(e);return(r,a)=>e.chain(a(r),([r,n])=>e.map(t(n,a),e=>({value:r,forest:e})))}function Qs(e){let t=dz(e);return(r,a)=>tE(r,t(t=>Qh(e)(t,a)))}/**
 * Fold a tree into a "summary" value in depth-first order.
 *
 * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.
 *
 * This is also known as the catamorphism on trees.
 *
 * @example
 * import { fold, make } from 'fp-ts/Tree'
 * import { concatAll } from 'fp-ts/Monoid'
 * import { MonoidSum } from 'fp-ts/number'
 *
 * const t = make(1, [make(2), make(3)])
 *
 * const sum = concatAll(MonoidSum)
 *
 * // Sum the values in a tree:
 * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)
 *
 * // Find the maximum value in the tree:
 * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)
 *
 * // Count the number of leaves in the tree:
 * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)
 *
 * @category folding
 * @since 2.6.0
 */function Qm(e){let t=r=>e(r.value,r.forest.map(t));return t}/* istanbul ignore next */let QI=(e,t)=>tE(e,QA(t)),Qg=(e,t)=>QU(e,e=>tE(t,QA(e))),QR=(e,t,r)=>tE(e,QS(t,r)),Qv=e=>{let t=QF(e);return(e,r)=>tE(e,t(r))},QW=(e,t,r)=>tE(e,QT(t,r)),QM=(e,t)=>tE(e,Qb(t)),Qy=e=>{let t=Qk(e);return(e,r)=>tE(e,t(r))},QO=e=>t=>Qg(t,e),QU=/*#__PURE__*/tw(2,(e,t)=>{let{value:r,forest:a}=t(e.value);return{value:r,forest:(0,dG().concat)(a,e.forest.map(QU(t)))}}),Qb=e=>t=>({value:e(t),forest:t.forest.map(Qb(e))}),Qx=/*#__PURE__*/Qb(tf),QE=/*#__PURE__*/QU(tf),QA=e=>t=>({value:e(t.value),forest:t.forest.map(QA(e))}),QS=(e,t)=>r=>{let a=t(e,r.value),n=r.forest.length;for(let e=0;e<n;e++)a=tE(r.forest[e],QS(a,t));return a},QF=e=>t=>QS(e.empty,(r,a)=>e.concat(r,t(a))),QT=(e,t)=>r=>{let a=e,n=r.forest.length;for(let e=n-1;e>=0;e--)a=tE(r.forest[e],QT(a,t));return t(r.value,a)},Qw=e=>e.value,Qk=e=>{let t=dz(e),r=a=>n=>e.ap(e.map(a(n.value),e=>t=>({value:e,forest:t})),tE(n.forest,t(r(a))));return r},Qq=e=>Qk(e)(tf),Q_=e=>Qi(e),QK="Tree",Qj={URI:QK,map:QI},QL=/*#__PURE__*/ri(Qj),QN={URI:QK,of:Q_},QC={URI:QK,map:QI,ap:Qg},QP=/*#__PURE__*/t4(QC),Qz=/*#__PURE__*/t5(QC),QB={URI:QK,map:QI,ap:Qg,of:Q_},QD={URI:QK,map:QI,ap:Qg,chain:QU},QV={URI:QK,map:QI,ap:Qg,of:Q_,chain:QU},Q$=/*#__PURE__*/rh(QD),QJ={URI:QK,reduce:QR,foldMap:Qv,reduceRight:QW},QH={URI:QK,map:QI,reduce:QR,foldMap:Qv,reduceRight:QW,traverse:Qy,sequence:Qq},QZ={URI:QK,map:QI,extend:QM,extract:Qw},QY=/*#__PURE__*/Q_(t$),QG=/*#__PURE__*/ro(Qj),QQ=/*#__PURE__*/rl(Qj),QX=/*#__PURE__*/rm(QD),Q0=/*#__PURE__*/t7(QC);// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 */function Q1(e){let t=(r,a)=>e.equals(r,a.value)||a.forest.some(e=>t(r,e));return t}/**
 * @since 2.11.0
 */let Q2=e=>t=>e(t.value)||t.forest.some(Q2(e)),Q3=QU,Q4={URI:QK,map:QI,of:Q_,ap:Qg,chain:QU,reduce:QR,foldMap:Qv,reduceRight:QW,traverse:Qy,sequence:Qq,extract:Qw,extend:QM},Q5=zG,Q7=zQ,Q6=e=>[Q7(e),Q5(e)];/**
 * @category instances
 * @since 2.0.0
 */function Q8(e){return{URI:Xb,_E:void 0,map:Xi,ap:(t,r)=>[Q5(t)(Q5(r)),e.concat(Q7(t),Q7(r))]}}let Q9=e=>t=>[t,e.empty];/**
 * @category instances
 * @since 2.0.0
 */function Xe(e){let t=Q8(e);return{URI:Xb,_E:void 0,map:t.map,ap:t.ap,of:Q9(e)}}/**
 * @category instances
 * @since 2.0.0
 */function Xt(e){let t=Q8(e);return{URI:Xb,_E:void 0,map:t.map,ap:t.ap,chain:(t,r)=>{let[a,n]=r(Q5(t));return[a,e.concat(Q7(t),n)]}}}/**
 * @category instances
 * @since 2.0.0
 */function Xr(e){let t=Xt(e);return{URI:Xb,_E:void 0,map:t.map,ap:t.ap,chain:t.chain,of:Q9(e)}}/**
 * @category instances
 * @since 2.0.0
 */function Xa(e){let t=Xt(e);return{URI:Xb,_E:void 0,map:t.map,ap:t.ap,chain:t.chain,chainRec:(t,r)=>{let a=r(t),n=e.empty,i=Q5(a);for(;"Left"===i._tag;)n=e.concat(n,Q7(a)),i=Q5(a=r(i.left));return[i.right,e.concat(n,Q7(a))]}}}/* istanbul ignore next */let Xn=(e,t)=>tE(e,XI(t)),Xi=(e,t)=>tE(e,Xs(t)),Xo=(e,t,r)=>tE(e,Xh(t,r)),Xl=(e,t)=>tE(e,Xm(t)),Xp=(e,t)=>tE(e,Xg(t)),Xc=(e,t,r)=>tE(e,XM(t,r)),Xu=e=>{let t=XW(e);return(e,r)=>tE(e,t(r))},Xf=(e,t,r)=>tE(e,Xy(t,r));/* istanbul ignore next */function Xd(e){let t=XO(e);return(e,r)=>tE(e,t(r))}/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category mapping
 * @since 2.0.0
 */let Xh=(e,t)=>r=>[t(Q5(r)),e(Q7(r))],Xs=e=>t=>[e(Q5(t)),Q7(t)],Xm=e=>t=>[Q5(t),e(Q7(t))],XI=e=>t=>[Q5(t),Q7(e)],Xg=e=>t=>[e(t),Q7(t)],XR=/*#__PURE__*/Xg(tf),Xv=Bu,XW=Bh,XM=Bd,Xy=Bs,XO=e=>t=>r=>e.map(t(Q5(r)),e=>[e,Q7(r)]),XU=e=>t=>e.map(Q5(t),e=>[e,Q7(t)]),Xb="Tuple",Xx={URI:Xb,map:Xi},XE=/*#__PURE__*/ri(Xx),XA={URI:Xb,bimap:Xo,mapLeft:Xl},XS={URI:Xb,compose:Xn},XF={URI:Xb,map:Xi,extend:Xp,extract:Xv},XT={URI:Xb,reduce:Xc,foldMap:Xu,reduceRight:Xf},Xw={URI:Xb,map:Xi,reduce:Xc,foldMap:Xu,reduceRight:Xf,traverse:Xd,sequence:XU},Xk=Xs,Xq=Xm,X_={URI:Xb,compose:Xn,map:Xi,bimap:Xo,mapLeft:Xl,extract:Xv,extend:Xp,reduce:Xc,foldMap:Xu,reduceRight:Xf,traverse:Xd,sequence:XU};/**
 * This class identifies data structures which can be _unfolded_, generalizing `unfold` on arrays.
 *
 * @since 2.0.0
 *//**
 * @category model
 * @since 2.0.0
 *//**
 * @since 2.0.0
 *//** @deprecated */function XK(e,t){let r=rd(t,go(e));return{map:r.map,ap:r.ap,of:r.of,chain:(e,r)=>t.chain(e,e=>tj(e)?t.of(tN(e.left)):r(e.right)),alt:(r,a)=>t.chain(r,r=>tL(r)?t.of(r):t.map(a(),t=>tj(t)?tN(e.concat(r.left,t.left)):t))}}/**
 * @since 2.11.0
 */// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.11.0
 */let Xj=ah(void 0),XL={concat:Xj.concat,empty:void 0},XN=e=>()=>[void 0,e],XC=e=>()=>{let[t,r]=e();return[[t,r],r]},XP=e=>()=>{let[[t,r],a]=e();return[t,r(a)]},Xz=e=>t=>()=>{let[r,a]=t();return[[r,e(a)],a]},XB=e=>t=>()=>{let[r,a]=t();return[r,e(a)]},XD=(e,t)=>tE(e,XV(t)),XV=e=>t=>()=>{let[r,a]=t();return[e(r),a]},X$="Writer",XJ=e=>({URI:X$,_E:void 0,of:t=>()=>[t,e.empty]}),XH=e=>({URI:X$,_E:void 0,map:XD,ap:(t,r)=>()=>{let[a,n]=t(),[i,o]=r();return[a(i),e.concat(n,o)]}}),XZ=e=>{let t=XH(e),r=XJ(e);return{URI:X$,_E:void 0,map:XD,ap:t.ap,of:r.of}};/**
 * @category instances
 * @since 2.10.0
 */function XY(e){return{URI:X$,_E:void 0,map:XD,ap:XH(e).ap,chain:(t,r)=>()=>{let[a,n]=t(),[i,o]=r(a)();return[i,e.concat(n,o)]}}}/**
 * @category instances
 * @since 2.0.0
 */function XG(e){let t=XZ(e),r=XY(e);return{URI:X$,_E:void 0,map:XD,ap:t.ap,of:t.of,chain:r.chain}}/**
 * @category instances
 * @since 2.7.0
 */let XQ={URI:X$,map:XD},XX=/*#__PURE__*/ri(XQ),X0=e=>e()[0],X1=e=>e()[1],X2=e=>e()[0],X3=e=>e()[1],X4=XQ;/**
 * @since 2.4.0
 */function X5(e){let t=(t,r)=>()=>e.map(t(),([e,t])=>[r(e),t]);return{map:t,evalWriter:t=>e.map(t(),([e])=>e),execWriter:t=>e.map(t(),([e,t])=>t),tell:t=>()=>e.of([void 0,t]),listen:t=>()=>e.map(t(),([e,t])=>[[e,t],t]),pass:t=>()=>e.map(t(),([[e,t],r])=>[e,t(r)]),listens:(t,r)=>()=>e.map(t(),([e,t])=>[[e,r(t)],t]),censor:(t,r)=>()=>e.map(t(),([e,t])=>[e,r(t)]),getMonad:r=>({_E:void 0,map:t,of:t=>()=>e.of([t,r.empty]),ap:(t,a)=>()=>e.chain(t(),([t,n])=>e.map(a(),([e,a])=>[t(e),r.concat(n,a)])),chain:(t,a)=>()=>e.chain(t(),([t,n])=>e.map(a(t)(),([e,t])=>[e,r.concat(n,t)]))})}}export{t as alt,r as alternative,a as applicative,n as apply,i as array,o as bifunctor,l as booleanAlgebra,c as boundedDistributiveLattice,u as boundedJoinSemilattice,f as boundedLattice,d as boundedMeetSemilattice,p as bounded,h as category,m as chainRec,s as chain,I as choice,g as comonad,R as compactable,v as console,W as const,M as contravariant,y as date,O as distributiveLattice,b as eitherT,U as either,x as endomorphism,E as eq,A as extend,S as field,T as filterableWithIndex,F as filterable,k as foldableWithIndex,w as foldable,q as fromEither,_ as fromIO,K as fromReader,j as fromState,L as fromTask,N as fromThese,P as functorWithIndex,C as functor,z as group,B as hkt,D as heytingAlgebra,$ as ioEither,J as ioOption,H as ioRef,V as io,Z as identity,Y as invariant,G as joinSemilattice,Q as json,X as lattice,ee as magma,et as map,er as meetSemilattice,en as monadIO,ei as monadTask,eo as monadThrow,ea as monad,el as monoid,ep as naturalTransformation,ec as nonEmptyArray,ef as optionT,eu as option,ed as ord,eh as ordering,es as pointed,em as predicate,eI as profunctor,eg as random,ev as readerEither,eW as readerIO,eM as readerT,eO as readerTaskEither,ey as readerTask,eR as reader,eU as readonlyArray,eb as readonlyMap,ex as readonlyNonEmptyArray,eE as readonlyRecord,eA as readonlySet,eS as readonlyTuple,eF as record,eT as refinement,ew as ring,ek as semigroup,eq as semigroupoid,e_ as semiring,eK as separated,ej as set,eL as show,eC as stateReaderTaskEither,eP as stateT,eN as state,ez as store,eB as strong,eV as taskEither,e$ as taskOption,eJ as taskThese,eD as task,eZ as theseT,eH as these,eY as traced,eQ as traversableWithIndex,eG as traversable,eX as tree,e0 as tuple,e1 as unfoldable,e2 as validationT,e3 as witherable,e5 as writerT,e4 as writer,e7 as zero,e6 as boolean,e8 as function,e9 as number,te as pipeable,tt as string,tr as struct,ta as void};